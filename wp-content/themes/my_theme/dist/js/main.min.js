/*! choices.js v9.0.1 | © 2019 Josh Johnson | https://github.com/jshjohnson/Choices#readme */
(function webpackUniversalModuleDefinition(root, factory) {
  if (typeof exports === 'object' && typeof module === 'object') module.exports = factory();else if (typeof define === 'function' && define.amd) define([], factory);else if (typeof exports === 'object') exports["Choices"] = factory();else root["Choices"] = factory();
})(window, function () {
  return (
    /******/
    function (modules) {
      // webpackBootstrap

      /******/
      // The module cache

      /******/
      var installedModules = {};
      /******/

      /******/
      // The require function

      /******/

      function __webpack_require__(moduleId) {
        /******/

        /******/
        // Check if module is in cache

        /******/
        if (installedModules[moduleId]) {
          /******/
          return installedModules[moduleId].exports;
          /******/
        }
        /******/
        // Create a new module (and put it into the cache)

        /******/


        var module = installedModules[moduleId] = {
          /******/
          i: moduleId,

          /******/
          l: false,

          /******/
          exports: {}
          /******/

        };
        /******/

        /******/
        // Execute the module function

        /******/

        modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
        /******/

        /******/
        // Flag the module as loaded

        /******/

        module.l = true;
        /******/

        /******/
        // Return the exports of the module

        /******/

        return module.exports;
        /******/
      }
      /******/

      /******/

      /******/
      // expose the modules object (__webpack_modules__)

      /******/


      __webpack_require__.m = modules;
      /******/

      /******/
      // expose the module cache

      /******/

      __webpack_require__.c = installedModules;
      /******/

      /******/
      // define getter function for harmony exports

      /******/

      __webpack_require__.d = function (exports, name, getter) {
        /******/
        if (!__webpack_require__.o(exports, name)) {
          /******/
          Object.defineProperty(exports, name, {
            enumerable: true,
            get: getter
          });
          /******/
        }
        /******/

      };
      /******/

      /******/
      // define __esModule on exports

      /******/


      __webpack_require__.r = function (exports) {
        /******/
        if (typeof Symbol !== 'undefined' && Symbol.toStringTag) {
          /******/
          Object.defineProperty(exports, Symbol.toStringTag, {
            value: 'Module'
          });
          /******/
        }
        /******/


        Object.defineProperty(exports, '__esModule', {
          value: true
        });
        /******/
      };
      /******/

      /******/
      // create a fake namespace object

      /******/
      // mode & 1: value is a module id, require it

      /******/
      // mode & 2: merge all properties of value into the ns

      /******/
      // mode & 4: return value when already ns object

      /******/
      // mode & 8|1: behave like require

      /******/


      __webpack_require__.t = function (value, mode) {
        /******/
        if (mode & 1) value = __webpack_require__(value);
        /******/

        if (mode & 8) return value;
        /******/

        if (mode & 4 && typeof value === 'object' && value && value.__esModule) return value;
        /******/

        var ns = Object.create(null);
        /******/

        __webpack_require__.r(ns);
        /******/


        Object.defineProperty(ns, 'default', {
          enumerable: true,
          value: value
        });
        /******/

        if (mode & 2 && typeof value != 'string') for (var key in value) __webpack_require__.d(ns, key, function (key) {
          return value[key];
        }.bind(null, key));
        /******/

        return ns;
        /******/
      };
      /******/

      /******/
      // getDefaultExport function for compatibility with non-harmony modules

      /******/


      __webpack_require__.n = function (module) {
        /******/
        var getter = module && module.__esModule ?
        /******/
        function getDefault() {
          return module['default'];
        } :
        /******/
        function getModuleExports() {
          return module;
        };
        /******/

        __webpack_require__.d(getter, 'a', getter);
        /******/


        return getter;
        /******/
      };
      /******/

      /******/
      // Object.prototype.hasOwnProperty.call

      /******/


      __webpack_require__.o = function (object, property) {
        return Object.prototype.hasOwnProperty.call(object, property);
      };
      /******/

      /******/
      // __webpack_public_path__

      /******/


      __webpack_require__.p = "/public/assets/scripts/";
      /******/

      /******/

      /******/
      // Load entry module and return exports

      /******/

      return __webpack_require__(__webpack_require__.s = 4);
      /******/
    }(
    /************************************************************************/

    /******/
    [
    /* 0 */

    /***/
    function (module, exports, __webpack_require__) {
      "use strict";

      var isMergeableObject = function isMergeableObject(value) {
        return isNonNullObject(value) && !isSpecial(value);
      };

      function isNonNullObject(value) {
        return !!value && typeof value === 'object';
      }

      function isSpecial(value) {
        var stringValue = Object.prototype.toString.call(value);
        return stringValue === '[object RegExp]' || stringValue === '[object Date]' || isReactElement(value);
      } // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25


      var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
      var REACT_ELEMENT_TYPE = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

      function isReactElement(value) {
        return value.$$typeof === REACT_ELEMENT_TYPE;
      }

      function emptyTarget(val) {
        return Array.isArray(val) ? [] : {};
      }

      function cloneUnlessOtherwiseSpecified(value, options) {
        return options.clone !== false && options.isMergeableObject(value) ? deepmerge(emptyTarget(value), value, options) : value;
      }

      function defaultArrayMerge(target, source, options) {
        return target.concat(source).map(function (element) {
          return cloneUnlessOtherwiseSpecified(element, options);
        });
      }

      function getMergeFunction(key, options) {
        if (!options.customMerge) {
          return deepmerge;
        }

        var customMerge = options.customMerge(key);
        return typeof customMerge === 'function' ? customMerge : deepmerge;
      }

      function getEnumerableOwnPropertySymbols(target) {
        return Object.getOwnPropertySymbols ? Object.getOwnPropertySymbols(target).filter(function (symbol) {
          return target.propertyIsEnumerable(symbol);
        }) : [];
      }

      function getKeys(target) {
        return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target));
      } // Protects from prototype poisoning and unexpected merging up the prototype chain.


      function propertyIsUnsafe(target, key) {
        try {
          return key in target && // Properties are safe to merge if they don't exist in the target yet,
          !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
          && Object.propertyIsEnumerable.call(target, key)); // and also unsafe if they're nonenumerable.
        } catch (unused) {
          // Counterintuitively, it's safe to merge any property on a target that causes the `in` operator to throw.
          // This happens when trying to copy an object in the source over a plain string in the target.
          return false;
        }
      }

      function mergeObject(target, source, options) {
        var destination = {};

        if (options.isMergeableObject(target)) {
          getKeys(target).forEach(function (key) {
            destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
          });
        }

        getKeys(source).forEach(function (key) {
          if (propertyIsUnsafe(target, key)) {
            return;
          }

          if (!options.isMergeableObject(source[key]) || !target[key]) {
            destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
          } else {
            destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
          }
        });
        return destination;
      }

      function deepmerge(target, source, options) {
        options = options || {};
        options.arrayMerge = options.arrayMerge || defaultArrayMerge;
        options.isMergeableObject = options.isMergeableObject || isMergeableObject; // cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
        // implementations can use it. The caller may not replace it.

        options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;
        var sourceIsArray = Array.isArray(source);
        var targetIsArray = Array.isArray(target);
        var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

        if (!sourceAndTargetTypesMatch) {
          return cloneUnlessOtherwiseSpecified(source, options);
        } else if (sourceIsArray) {
          return options.arrayMerge(target, source, options);
        } else {
          return mergeObject(target, source, options);
        }
      }

      deepmerge.all = function deepmergeAll(array, options) {
        if (!Array.isArray(array)) {
          throw new Error('first argument should be an array');
        }

        return array.reduce(function (prev, next) {
          return deepmerge(prev, next, options);
        }, {});
      };

      var deepmerge_1 = deepmerge;
      module.exports = deepmerge_1;
      /***/
    },
    /* 1 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* WEBPACK VAR INJECTION */

      (function (global, module) {
        /* harmony import */
        var _ponyfill_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(3);
        /* global window */


        var root;

        if (typeof self !== 'undefined') {
          root = self;
        } else if (typeof window !== 'undefined') {
          root = window;
        } else if (typeof global !== 'undefined') {
          root = global;
        } else if (true) {
          root = module;
        } else {}

        var result = Object(_ponyfill_js__WEBPACK_IMPORTED_MODULE_0__[
        /* default */
        "a"])(root);
        /* harmony default export */

        __webpack_exports__["a"] = result;
        /* WEBPACK VAR INJECTION */
      }).call(this, __webpack_require__(5), __webpack_require__(6)(module));
      /***/
    },
    /* 2 */

    /***/
    function (module, exports, __webpack_require__) {
      /*!
       * Fuse.js v3.4.5 - Lightweight fuzzy-search (http://fusejs.io)
       * 
       * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
       * All Rights Reserved. Apache Software License 2.0
       * 
       * http://www.apache.org/licenses/LICENSE-2.0
       */
      !function (e, t) {
        true ? module.exports = t() : undefined;
      }(this, function () {
        return function (e) {
          var t = {};

          function n(r) {
            if (t[r]) return t[r].exports;
            var o = t[r] = {
              i: r,
              l: !1,
              exports: {}
            };
            return e[r].call(o.exports, o, o.exports, n), o.l = !0, o.exports;
          }

          return n.m = e, n.c = t, n.d = function (e, t, r) {
            n.o(e, t) || Object.defineProperty(e, t, {
              enumerable: !0,
              get: r
            });
          }, n.r = function (e) {
            "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(e, Symbol.toStringTag, {
              value: "Module"
            }), Object.defineProperty(e, "__esModule", {
              value: !0
            });
          }, n.t = function (e, t) {
            if (1 & t && (e = n(e)), 8 & t) return e;
            if (4 & t && "object" == typeof e && e && e.__esModule) return e;
            var r = Object.create(null);
            if (n.r(r), Object.defineProperty(r, "default", {
              enumerable: !0,
              value: e
            }), 2 & t && "string" != typeof e) for (var o in e) n.d(r, o, function (t) {
              return e[t];
            }.bind(null, o));
            return r;
          }, n.n = function (e) {
            var t = e && e.__esModule ? function () {
              return e.default;
            } : function () {
              return e;
            };
            return n.d(t, "a", t), t;
          }, n.o = function (e, t) {
            return Object.prototype.hasOwnProperty.call(e, t);
          }, n.p = "", n(n.s = 1);
        }([function (e, t) {
          e.exports = function (e) {
            return Array.isArray ? Array.isArray(e) : "[object Array]" === Object.prototype.toString.call(e);
          };
        }, function (e, t, n) {
          function r(e) {
            return (r = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (e) {
              return typeof e;
            } : function (e) {
              return e && "function" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? "symbol" : typeof e;
            })(e);
          }

          function o(e, t) {
            for (var n = 0; n < t.length; n++) {
              var r = t[n];
              r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
            }
          }

          var i = n(2),
              a = n(8),
              s = n(0),
              c = function () {
            function e(t, n) {
              var r = n.location,
                  o = void 0 === r ? 0 : r,
                  i = n.distance,
                  s = void 0 === i ? 100 : i,
                  c = n.threshold,
                  h = void 0 === c ? .6 : c,
                  l = n.maxPatternLength,
                  u = void 0 === l ? 32 : l,
                  f = n.caseSensitive,
                  d = void 0 !== f && f,
                  v = n.tokenSeparator,
                  p = void 0 === v ? / +/g : v,
                  g = n.findAllMatches,
                  y = void 0 !== g && g,
                  m = n.minMatchCharLength,
                  k = void 0 === m ? 1 : m,
                  S = n.id,
                  x = void 0 === S ? null : S,
                  b = n.keys,
                  M = void 0 === b ? [] : b,
                  _ = n.shouldSort,
                  L = void 0 === _ || _,
                  w = n.getFn,
                  A = void 0 === w ? a : w,
                  C = n.sortFn,
                  I = void 0 === C ? function (e, t) {
                return e.score - t.score;
              } : C,
                  O = n.tokenize,
                  j = void 0 !== O && O,
                  P = n.matchAllTokens,
                  F = void 0 !== P && P,
                  T = n.includeMatches,
                  z = void 0 !== T && T,
                  E = n.includeScore,
                  K = void 0 !== E && E,
                  $ = n.verbose,
                  J = void 0 !== $ && $;
              !function (e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
              }(this, e), this.options = {
                location: o,
                distance: s,
                threshold: h,
                maxPatternLength: u,
                isCaseSensitive: d,
                tokenSeparator: p,
                findAllMatches: y,
                minMatchCharLength: k,
                id: x,
                keys: M,
                includeMatches: z,
                includeScore: K,
                shouldSort: L,
                getFn: A,
                sortFn: I,
                verbose: J,
                tokenize: j,
                matchAllTokens: F
              }, this.setCollection(t);
            }

            var t, n, c;
            return t = e, (n = [{
              key: "setCollection",
              value: function (e) {
                return this.list = e, e;
              }
            }, {
              key: "search",
              value: function (e) {
                var t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : {
                  limit: !1
                };

                this._log('---------\nSearch pattern: "'.concat(e, '"'));

                var n = this._prepareSearchers(e),
                    r = n.tokenSearchers,
                    o = n.fullSearcher,
                    i = this._search(r, o),
                    a = i.weights,
                    s = i.results;

                return this._computeScore(a, s), this.options.shouldSort && this._sort(s), t.limit && "number" == typeof t.limit && (s = s.slice(0, t.limit)), this._format(s);
              }
            }, {
              key: "_prepareSearchers",
              value: function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : "",
                    t = [];
                if (this.options.tokenize) for (var n = e.split(this.options.tokenSeparator), r = 0, o = n.length; r < o; r += 1) t.push(new i(n[r], this.options));
                return {
                  tokenSearchers: t,
                  fullSearcher: new i(e, this.options)
                };
              }
            }, {
              key: "_search",
              value: function () {
                var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [],
                    t = arguments.length > 1 ? arguments[1] : void 0,
                    n = this.list,
                    r = {},
                    o = [];

                if ("string" == typeof n[0]) {
                  for (var i = 0, a = n.length; i < a; i += 1) this._analyze({
                    key: "",
                    value: n[i],
                    record: i,
                    index: i
                  }, {
                    resultMap: r,
                    results: o,
                    tokenSearchers: e,
                    fullSearcher: t
                  });

                  return {
                    weights: null,
                    results: o
                  };
                }

                for (var s = {}, c = 0, h = n.length; c < h; c += 1) for (var l = n[c], u = 0, f = this.options.keys.length; u < f; u += 1) {
                  var d = this.options.keys[u];

                  if ("string" != typeof d) {
                    if (s[d.name] = {
                      weight: 1 - d.weight || 1
                    }, d.weight <= 0 || d.weight > 1) throw new Error("Key weight has to be > 0 and <= 1");
                    d = d.name;
                  } else s[d] = {
                    weight: 1
                  };

                  this._analyze({
                    key: d,
                    value: this.options.getFn(l, d),
                    record: l,
                    index: c
                  }, {
                    resultMap: r,
                    results: o,
                    tokenSearchers: e,
                    fullSearcher: t
                  });
                }

                return {
                  weights: s,
                  results: o
                };
              }
            }, {
              key: "_analyze",
              value: function (e, t) {
                var n = e.key,
                    r = e.arrayIndex,
                    o = void 0 === r ? -1 : r,
                    i = e.value,
                    a = e.record,
                    c = e.index,
                    h = t.tokenSearchers,
                    l = void 0 === h ? [] : h,
                    u = t.fullSearcher,
                    f = void 0 === u ? [] : u,
                    d = t.resultMap,
                    v = void 0 === d ? {} : d,
                    p = t.results,
                    g = void 0 === p ? [] : p;

                if (null != i) {
                  var y = !1,
                      m = -1,
                      k = 0;

                  if ("string" == typeof i) {
                    this._log("\nKey: ".concat("" === n ? "-" : n));

                    var S = f.search(i);

                    if (this._log('Full text: "'.concat(i, '", score: ').concat(S.score)), this.options.tokenize) {
                      for (var x = i.split(this.options.tokenSeparator), b = [], M = 0; M < l.length; M += 1) {
                        var _ = l[M];

                        this._log('\nPattern: "'.concat(_.pattern, '"'));

                        for (var L = !1, w = 0; w < x.length; w += 1) {
                          var A = x[w],
                              C = _.search(A),
                              I = {};

                          C.isMatch ? (I[A] = C.score, y = !0, L = !0, b.push(C.score)) : (I[A] = 1, this.options.matchAllTokens || b.push(1)), this._log('Token: "'.concat(A, '", score: ').concat(I[A]));
                        }

                        L && (k += 1);
                      }

                      m = b[0];

                      for (var O = b.length, j = 1; j < O; j += 1) m += b[j];

                      m /= O, this._log("Token score average:", m);
                    }

                    var P = S.score;
                    m > -1 && (P = (P + m) / 2), this._log("Score average:", P);
                    var F = !this.options.tokenize || !this.options.matchAllTokens || k >= l.length;

                    if (this._log("\nCheck Matches: ".concat(F)), (y || S.isMatch) && F) {
                      var T = v[c];
                      T ? T.output.push({
                        key: n,
                        arrayIndex: o,
                        value: i,
                        score: P,
                        matchedIndices: S.matchedIndices
                      }) : (v[c] = {
                        item: a,
                        output: [{
                          key: n,
                          arrayIndex: o,
                          value: i,
                          score: P,
                          matchedIndices: S.matchedIndices
                        }]
                      }, g.push(v[c]));
                    }
                  } else if (s(i)) for (var z = 0, E = i.length; z < E; z += 1) this._analyze({
                    key: n,
                    arrayIndex: z,
                    value: i[z],
                    record: a,
                    index: c
                  }, {
                    resultMap: v,
                    results: g,
                    tokenSearchers: l,
                    fullSearcher: f
                  });
                }
              }
            }, {
              key: "_computeScore",
              value: function (e, t) {
                this._log("\n\nComputing score:\n");

                for (var n = 0, r = t.length; n < r; n += 1) {
                  for (var o = t[n].output, i = o.length, a = 1, s = 1, c = 0; c < i; c += 1) {
                    var h = e ? e[o[c].key].weight : 1,
                        l = (1 === h ? o[c].score : o[c].score || .001) * h;
                    1 !== h ? s = Math.min(s, l) : (o[c].nScore = l, a *= l);
                  }

                  t[n].score = 1 === s ? a : s, this._log(t[n]);
                }
              }
            }, {
              key: "_sort",
              value: function (e) {
                this._log("\n\nSorting...."), e.sort(this.options.sortFn);
              }
            }, {
              key: "_format",
              value: function (e) {
                var t = [];

                if (this.options.verbose) {
                  var n = [];
                  this._log("\n\nOutput:\n\n", JSON.stringify(e, function (e, t) {
                    if ("object" === r(t) && null !== t) {
                      if (-1 !== n.indexOf(t)) return;
                      n.push(t);
                    }

                    return t;
                  })), n = null;
                }

                var o = [];
                this.options.includeMatches && o.push(function (e, t) {
                  var n = e.output;
                  t.matches = [];

                  for (var r = 0, o = n.length; r < o; r += 1) {
                    var i = n[r];

                    if (0 !== i.matchedIndices.length) {
                      var a = {
                        indices: i.matchedIndices,
                        value: i.value
                      };
                      i.key && (a.key = i.key), i.hasOwnProperty("arrayIndex") && i.arrayIndex > -1 && (a.arrayIndex = i.arrayIndex), t.matches.push(a);
                    }
                  }
                }), this.options.includeScore && o.push(function (e, t) {
                  t.score = e.score;
                });

                for (var i = 0, a = e.length; i < a; i += 1) {
                  var s = e[i];

                  if (this.options.id && (s.item = this.options.getFn(s.item, this.options.id)[0]), o.length) {
                    for (var c = {
                      item: s.item
                    }, h = 0, l = o.length; h < l; h += 1) o[h](s, c);

                    t.push(c);
                  } else t.push(s.item);
                }

                return t;
              }
            }, {
              key: "_log",
              value: function () {
                var e;
                this.options.verbose && (e = console).log.apply(e, arguments);
              }
            }]) && o(t.prototype, n), c && o(t, c), e;
          }();

          e.exports = c;
        }, function (e, t, n) {
          function r(e, t) {
            for (var n = 0; n < t.length; n++) {
              var r = t[n];
              r.enumerable = r.enumerable || !1, r.configurable = !0, "value" in r && (r.writable = !0), Object.defineProperty(e, r.key, r);
            }
          }

          var o = n(3),
              i = n(4),
              a = n(7),
              s = function () {
            function e(t, n) {
              var r = n.location,
                  o = void 0 === r ? 0 : r,
                  i = n.distance,
                  s = void 0 === i ? 100 : i,
                  c = n.threshold,
                  h = void 0 === c ? .6 : c,
                  l = n.maxPatternLength,
                  u = void 0 === l ? 32 : l,
                  f = n.isCaseSensitive,
                  d = void 0 !== f && f,
                  v = n.tokenSeparator,
                  p = void 0 === v ? / +/g : v,
                  g = n.findAllMatches,
                  y = void 0 !== g && g,
                  m = n.minMatchCharLength,
                  k = void 0 === m ? 1 : m;
              !function (e, t) {
                if (!(e instanceof t)) throw new TypeError("Cannot call a class as a function");
              }(this, e), this.options = {
                location: o,
                distance: s,
                threshold: h,
                maxPatternLength: u,
                isCaseSensitive: d,
                tokenSeparator: p,
                findAllMatches: y,
                minMatchCharLength: k
              }, this.pattern = this.options.isCaseSensitive ? t : t.toLowerCase(), this.pattern.length <= u && (this.patternAlphabet = a(this.pattern));
            }

            var t, n, s;
            return t = e, (n = [{
              key: "search",
              value: function (e) {
                if (this.options.isCaseSensitive || (e = e.toLowerCase()), this.pattern === e) return {
                  isMatch: !0,
                  score: 0,
                  matchedIndices: [[0, e.length - 1]]
                };
                var t = this.options,
                    n = t.maxPatternLength,
                    r = t.tokenSeparator;
                if (this.pattern.length > n) return o(e, this.pattern, r);
                var a = this.options,
                    s = a.location,
                    c = a.distance,
                    h = a.threshold,
                    l = a.findAllMatches,
                    u = a.minMatchCharLength;
                return i(e, this.pattern, this.patternAlphabet, {
                  location: s,
                  distance: c,
                  threshold: h,
                  findAllMatches: l,
                  minMatchCharLength: u
                });
              }
            }]) && r(t.prototype, n), s && r(t, s), e;
          }();

          e.exports = s;
        }, function (e, t) {
          var n = /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;

          e.exports = function (e, t) {
            var r = arguments.length > 2 && void 0 !== arguments[2] ? arguments[2] : / +/g,
                o = new RegExp(t.replace(n, "\\$&").replace(r, "|")),
                i = e.match(o),
                a = !!i,
                s = [];
            if (a) for (var c = 0, h = i.length; c < h; c += 1) {
              var l = i[c];
              s.push([e.indexOf(l), l.length - 1]);
            }
            return {
              score: a ? .5 : 1,
              isMatch: a,
              matchedIndices: s
            };
          };
        }, function (e, t, n) {
          var r = n(5),
              o = n(6);

          e.exports = function (e, t, n, i) {
            for (var a = i.location, s = void 0 === a ? 0 : a, c = i.distance, h = void 0 === c ? 100 : c, l = i.threshold, u = void 0 === l ? .6 : l, f = i.findAllMatches, d = void 0 !== f && f, v = i.minMatchCharLength, p = void 0 === v ? 1 : v, g = s, y = e.length, m = u, k = e.indexOf(t, g), S = t.length, x = [], b = 0; b < y; b += 1) x[b] = 0;

            if (-1 !== k) {
              var M = r(t, {
                errors: 0,
                currentLocation: k,
                expectedLocation: g,
                distance: h
              });

              if (m = Math.min(M, m), -1 !== (k = e.lastIndexOf(t, g + S))) {
                var _ = r(t, {
                  errors: 0,
                  currentLocation: k,
                  expectedLocation: g,
                  distance: h
                });

                m = Math.min(_, m);
              }
            }

            k = -1;

            for (var L = [], w = 1, A = S + y, C = 1 << S - 1, I = 0; I < S; I += 1) {
              for (var O = 0, j = A; O < j;) {
                r(t, {
                  errors: I,
                  currentLocation: g + j,
                  expectedLocation: g,
                  distance: h
                }) <= m ? O = j : A = j, j = Math.floor((A - O) / 2 + O);
              }

              A = j;
              var P = Math.max(1, g - j + 1),
                  F = d ? y : Math.min(g + j, y) + S,
                  T = Array(F + 2);
              T[F + 1] = (1 << I) - 1;

              for (var z = F; z >= P; z -= 1) {
                var E = z - 1,
                    K = n[e.charAt(E)];

                if (K && (x[E] = 1), T[z] = (T[z + 1] << 1 | 1) & K, 0 !== I && (T[z] |= (L[z + 1] | L[z]) << 1 | 1 | L[z + 1]), T[z] & C && (w = r(t, {
                  errors: I,
                  currentLocation: E,
                  expectedLocation: g,
                  distance: h
                })) <= m) {
                  if (m = w, (k = E) <= g) break;
                  P = Math.max(1, 2 * g - k);
                }
              }

              if (r(t, {
                errors: I + 1,
                currentLocation: g,
                expectedLocation: g,
                distance: h
              }) > m) break;
              L = T;
            }

            return {
              isMatch: k >= 0,
              score: 0 === w ? .001 : w,
              matchedIndices: o(x, p)
            };
          };
        }, function (e, t) {
          e.exports = function (e, t) {
            var n = t.errors,
                r = void 0 === n ? 0 : n,
                o = t.currentLocation,
                i = void 0 === o ? 0 : o,
                a = t.expectedLocation,
                s = void 0 === a ? 0 : a,
                c = t.distance,
                h = void 0 === c ? 100 : c,
                l = r / e.length,
                u = Math.abs(s - i);
            return h ? l + u / h : u ? 1 : l;
          };
        }, function (e, t) {
          e.exports = function () {
            for (var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : [], t = arguments.length > 1 && void 0 !== arguments[1] ? arguments[1] : 1, n = [], r = -1, o = -1, i = 0, a = e.length; i < a; i += 1) {
              var s = e[i];
              s && -1 === r ? r = i : s || -1 === r || ((o = i - 1) - r + 1 >= t && n.push([r, o]), r = -1);
            }

            return e[i - 1] && i - r >= t && n.push([r, i - 1]), n;
          };
        }, function (e, t) {
          e.exports = function (e) {
            for (var t = {}, n = e.length, r = 0; r < n; r += 1) t[e.charAt(r)] = 0;

            for (var o = 0; o < n; o += 1) t[e.charAt(o)] |= 1 << n - o - 1;

            return t;
          };
        }, function (e, t, n) {
          var r = n(0);

          e.exports = function (e, t) {
            return function e(t, n, o) {
              if (n) {
                var i = n.indexOf("."),
                    a = n,
                    s = null;
                -1 !== i && (a = n.slice(0, i), s = n.slice(i + 1));
                var c = t[a];
                if (null != c) if (s || "string" != typeof c && "number" != typeof c) {
                  if (r(c)) for (var h = 0, l = c.length; h < l; h += 1) e(c[h], s, o);else s && e(c, s, o);
                } else o.push(c.toString());
              } else o.push(t);

              return o;
            }(e, t, []);
          };
        }]);
      });
      /***/
    },
    /* 3 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";
      /* harmony export (binding) */

      __webpack_require__.d(__webpack_exports__, "a", function () {
        return symbolObservablePonyfill;
      });

      function symbolObservablePonyfill(root) {
        var result;
        var Symbol = root.Symbol;

        if (typeof Symbol === 'function') {
          if (Symbol.observable) {
            result = Symbol.observable;
          } else {
            result = Symbol('observable');
            Symbol.observable = result;
          }
        } else {
          result = '@@observable';
        }

        return result;
      }

      ;
      /***/
    },
    /* 4 */

    /***/
    function (module, exports, __webpack_require__) {
      module.exports = __webpack_require__(7);
      /***/
    },
    /* 5 */

    /***/
    function (module, exports) {
      var g; // This works in non-strict mode

      g = function () {
        return this;
      }();

      try {
        // This works if eval is allowed (see CSP)
        g = g || new Function("return this")();
      } catch (e) {
        // This works if the window reference is available
        if (typeof window === "object") g = window;
      } // g can still be undefined, but nothing to do about it...
      // We return undefined, instead of nothing here, so it's
      // easier to handle this case. if(!global) { ...}


      module.exports = g;
      /***/
    },
    /* 6 */

    /***/
    function (module, exports) {
      module.exports = function (originalModule) {
        if (!originalModule.webpackPolyfill) {
          var module = Object.create(originalModule); // module.parent = undefined by default

          if (!module.children) module.children = [];
          Object.defineProperty(module, "loaded", {
            enumerable: true,
            get: function () {
              return module.l;
            }
          });
          Object.defineProperty(module, "id", {
            enumerable: true,
            get: function () {
              return module.i;
            }
          });
          Object.defineProperty(module, "exports", {
            enumerable: true
          });
          module.webpackPolyfill = 1;
        }

        return module;
      };
      /***/

    },
    /* 7 */

    /***/
    function (module, __webpack_exports__, __webpack_require__) {
      "use strict";

      __webpack_require__.r(__webpack_exports__); // EXTERNAL MODULE: ./node_modules/fuse.js/dist/fuse.js


      var dist_fuse = __webpack_require__(2);

      var fuse_default = /*#__PURE__*/__webpack_require__.n(dist_fuse); // EXTERNAL MODULE: ./node_modules/deepmerge/dist/cjs.js


      var cjs = __webpack_require__(0);

      var cjs_default = /*#__PURE__*/__webpack_require__.n(cjs); // EXTERNAL MODULE: ./node_modules/symbol-observable/es/index.js


      var es = __webpack_require__(1); // CONCATENATED MODULE: ./node_modules/redux/es/redux.js

      /**
       * These are private action types reserved by Redux.
       * For any unknown actions, you must return the current state.
       * If the current state is undefined, you must return the initial state.
       * Do not reference these action types directly in your code.
       */


      var randomString = function randomString() {
        return Math.random().toString(36).substring(7).split('').join('.');
      };

      var ActionTypes = {
        INIT: "@@redux/INIT" + randomString(),
        REPLACE: "@@redux/REPLACE" + randomString(),
        PROBE_UNKNOWN_ACTION: function PROBE_UNKNOWN_ACTION() {
          return "@@redux/PROBE_UNKNOWN_ACTION" + randomString();
        }
      };
      /**
       * @param {any} obj The object to inspect.
       * @returns {boolean} True if the argument appears to be a plain object.
       */

      function isPlainObject(obj) {
        if (typeof obj !== 'object' || obj === null) return false;
        var proto = obj;

        while (Object.getPrototypeOf(proto) !== null) {
          proto = Object.getPrototypeOf(proto);
        }

        return Object.getPrototypeOf(obj) === proto;
      }
      /**
       * Creates a Redux store that holds the state tree.
       * The only way to change the data in the store is to call `dispatch()` on it.
       *
       * There should only be a single store in your app. To specify how different
       * parts of the state tree respond to actions, you may combine several reducers
       * into a single reducer function by using `combineReducers`.
       *
       * @param {Function} reducer A function that returns the next state tree, given
       * the current state tree and the action to handle.
       *
       * @param {any} [preloadedState] The initial state. You may optionally specify it
       * to hydrate the state from the server in universal apps, or to restore a
       * previously serialized user session.
       * If you use `combineReducers` to produce the root reducer function, this must be
       * an object with the same shape as `combineReducers` keys.
       *
       * @param {Function} [enhancer] The store enhancer. You may optionally specify it
       * to enhance the store with third-party capabilities such as middleware,
       * time travel, persistence, etc. The only store enhancer that ships with Redux
       * is `applyMiddleware()`.
       *
       * @returns {Store} A Redux store that lets you read the state, dispatch actions
       * and subscribe to changes.
       */


      function createStore(reducer, preloadedState, enhancer) {
        var _ref2;

        if (typeof preloadedState === 'function' && typeof enhancer === 'function' || typeof enhancer === 'function' && typeof arguments[3] === 'function') {
          throw new Error('It looks like you are passing several store enhancers to ' + 'createStore(). This is not supported. Instead, compose them ' + 'together to a single function.');
        }

        if (typeof preloadedState === 'function' && typeof enhancer === 'undefined') {
          enhancer = preloadedState;
          preloadedState = undefined;
        }

        if (typeof enhancer !== 'undefined') {
          if (typeof enhancer !== 'function') {
            throw new Error('Expected the enhancer to be a function.');
          }

          return enhancer(createStore)(reducer, preloadedState);
        }

        if (typeof reducer !== 'function') {
          throw new Error('Expected the reducer to be a function.');
        }

        var currentReducer = reducer;
        var currentState = preloadedState;
        var currentListeners = [];
        var nextListeners = currentListeners;
        var isDispatching = false;
        /**
         * This makes a shallow copy of currentListeners so we can use
         * nextListeners as a temporary list while dispatching.
         *
         * This prevents any bugs around consumers calling
         * subscribe/unsubscribe in the middle of a dispatch.
         */

        function ensureCanMutateNextListeners() {
          if (nextListeners === currentListeners) {
            nextListeners = currentListeners.slice();
          }
        }
        /**
         * Reads the state tree managed by the store.
         *
         * @returns {any} The current state tree of your application.
         */


        function getState() {
          if (isDispatching) {
            throw new Error('You may not call store.getState() while the reducer is executing. ' + 'The reducer has already received the state as an argument. ' + 'Pass it down from the top reducer instead of reading it from the store.');
          }

          return currentState;
        }
        /**
         * Adds a change listener. It will be called any time an action is dispatched,
         * and some part of the state tree may potentially have changed. You may then
         * call `getState()` to read the current state tree inside the callback.
         *
         * You may call `dispatch()` from a change listener, with the following
         * caveats:
         *
         * 1. The subscriptions are snapshotted just before every `dispatch()` call.
         * If you subscribe or unsubscribe while the listeners are being invoked, this
         * will not have any effect on the `dispatch()` that is currently in progress.
         * However, the next `dispatch()` call, whether nested or not, will use a more
         * recent snapshot of the subscription list.
         *
         * 2. The listener should not expect to see all state changes, as the state
         * might have been updated multiple times during a nested `dispatch()` before
         * the listener is called. It is, however, guaranteed that all subscribers
         * registered before the `dispatch()` started will be called with the latest
         * state by the time it exits.
         *
         * @param {Function} listener A callback to be invoked on every dispatch.
         * @returns {Function} A function to remove this change listener.
         */


        function subscribe(listener) {
          if (typeof listener !== 'function') {
            throw new Error('Expected the listener to be a function.');
          }

          if (isDispatching) {
            throw new Error('You may not call store.subscribe() while the reducer is executing. ' + 'If you would like to be notified after the store has been updated, subscribe from a ' + 'component and invoke store.getState() in the callback to access the latest state. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
          }

          var isSubscribed = true;
          ensureCanMutateNextListeners();
          nextListeners.push(listener);
          return function unsubscribe() {
            if (!isSubscribed) {
              return;
            }

            if (isDispatching) {
              throw new Error('You may not unsubscribe from a store listener while the reducer is executing. ' + 'See https://redux.js.org/api-reference/store#subscribe(listener) for more details.');
            }

            isSubscribed = false;
            ensureCanMutateNextListeners();
            var index = nextListeners.indexOf(listener);
            nextListeners.splice(index, 1);
          };
        }
        /**
         * Dispatches an action. It is the only way to trigger a state change.
         *
         * The `reducer` function, used to create the store, will be called with the
         * current state tree and the given `action`. Its return value will
         * be considered the **next** state of the tree, and the change listeners
         * will be notified.
         *
         * The base implementation only supports plain object actions. If you want to
         * dispatch a Promise, an Observable, a thunk, or something else, you need to
         * wrap your store creating function into the corresponding middleware. For
         * example, see the documentation for the `redux-thunk` package. Even the
         * middleware will eventually dispatch plain object actions using this method.
         *
         * @param {Object} action A plain object representing “what changed”. It is
         * a good idea to keep actions serializable so you can record and replay user
         * sessions, or use the time travelling `redux-devtools`. An action must have
         * a `type` property which may not be `undefined`. It is a good idea to use
         * string constants for action types.
         *
         * @returns {Object} For convenience, the same action object you dispatched.
         *
         * Note that, if you use a custom middleware, it may wrap `dispatch()` to
         * return something else (for example, a Promise you can await).
         */


        function dispatch(action) {
          if (!isPlainObject(action)) {
            throw new Error('Actions must be plain objects. ' + 'Use custom middleware for async actions.');
          }

          if (typeof action.type === 'undefined') {
            throw new Error('Actions may not have an undefined "type" property. ' + 'Have you misspelled a constant?');
          }

          if (isDispatching) {
            throw new Error('Reducers may not dispatch actions.');
          }

          try {
            isDispatching = true;
            currentState = currentReducer(currentState, action);
          } finally {
            isDispatching = false;
          }

          var listeners = currentListeners = nextListeners;

          for (var i = 0; i < listeners.length; i++) {
            var listener = listeners[i];
            listener();
          }

          return action;
        }
        /**
         * Replaces the reducer currently used by the store to calculate the state.
         *
         * You might need this if your app implements code splitting and you want to
         * load some of the reducers dynamically. You might also need this if you
         * implement a hot reloading mechanism for Redux.
         *
         * @param {Function} nextReducer The reducer for the store to use instead.
         * @returns {void}
         */


        function replaceReducer(nextReducer) {
          if (typeof nextReducer !== 'function') {
            throw new Error('Expected the nextReducer to be a function.');
          }

          currentReducer = nextReducer; // This action has a similiar effect to ActionTypes.INIT.
          // Any reducers that existed in both the new and old rootReducer
          // will receive the previous state. This effectively populates
          // the new state tree with any relevant data from the old one.

          dispatch({
            type: ActionTypes.REPLACE
          });
        }
        /**
         * Interoperability point for observable/reactive libraries.
         * @returns {observable} A minimal observable of state changes.
         * For more information, see the observable proposal:
         * https://github.com/tc39/proposal-observable
         */


        function observable() {
          var _ref;

          var outerSubscribe = subscribe;
          return _ref = {
            /**
             * The minimal observable subscription method.
             * @param {Object} observer Any object that can be used as an observer.
             * The observer object should have a `next` method.
             * @returns {subscription} An object with an `unsubscribe` method that can
             * be used to unsubscribe the observable from the store, and prevent further
             * emission of values from the observable.
             */
            subscribe: function subscribe(observer) {
              if (typeof observer !== 'object' || observer === null) {
                throw new TypeError('Expected the observer to be an object.');
              }

              function observeState() {
                if (observer.next) {
                  observer.next(getState());
                }
              }

              observeState();
              var unsubscribe = outerSubscribe(observeState);
              return {
                unsubscribe: unsubscribe
              };
            }
          }, _ref[es["a"
          /* default */
          ]] = function () {
            return this;
          }, _ref;
        } // When a store is created, an "INIT" action is dispatched so that every
        // reducer returns their initial state. This effectively populates
        // the initial state tree.


        dispatch({
          type: ActionTypes.INIT
        });
        return _ref2 = {
          dispatch: dispatch,
          subscribe: subscribe,
          getState: getState,
          replaceReducer: replaceReducer
        }, _ref2[es["a"
        /* default */
        ]] = observable, _ref2;
      }
      /**
       * Prints a warning in the console if it exists.
       *
       * @param {String} message The warning message.
       * @returns {void}
       */


      function warning(message) {
        /* eslint-disable no-console */
        if (typeof console !== 'undefined' && typeof console.error === 'function') {
          console.error(message);
        }
        /* eslint-enable no-console */


        try {
          // This error was thrown as a convenience so that if you enable
          // "break on all exceptions" in your console,
          // it would pause the execution at this line.
          throw new Error(message);
        } catch (e) {} // eslint-disable-line no-empty

      }

      function getUndefinedStateErrorMessage(key, action) {
        var actionType = action && action.type;
        var actionDescription = actionType && "action \"" + String(actionType) + "\"" || 'an action';
        return "Given " + actionDescription + ", reducer \"" + key + "\" returned undefined. " + "To ignore an action, you must explicitly return the previous state. " + "If you want this reducer to hold no value, you can return null instead of undefined.";
      }

      function getUnexpectedStateShapeWarningMessage(inputState, reducers, action, unexpectedKeyCache) {
        var reducerKeys = Object.keys(reducers);
        var argumentName = action && action.type === ActionTypes.INIT ? 'preloadedState argument passed to createStore' : 'previous state received by the reducer';

        if (reducerKeys.length === 0) {
          return 'Store does not have a valid reducer. Make sure the argument passed ' + 'to combineReducers is an object whose values are reducers.';
        }

        if (!isPlainObject(inputState)) {
          return "The " + argumentName + " has unexpected type of \"" + {}.toString.call(inputState).match(/\s([a-z|A-Z]+)/)[1] + "\". Expected argument to be an object with the following " + ("keys: \"" + reducerKeys.join('", "') + "\"");
        }

        var unexpectedKeys = Object.keys(inputState).filter(function (key) {
          return !reducers.hasOwnProperty(key) && !unexpectedKeyCache[key];
        });
        unexpectedKeys.forEach(function (key) {
          unexpectedKeyCache[key] = true;
        });
        if (action && action.type === ActionTypes.REPLACE) return;

        if (unexpectedKeys.length > 0) {
          return "Unexpected " + (unexpectedKeys.length > 1 ? 'keys' : 'key') + " " + ("\"" + unexpectedKeys.join('", "') + "\" found in " + argumentName + ". ") + "Expected to find one of the known reducer keys instead: " + ("\"" + reducerKeys.join('", "') + "\". Unexpected keys will be ignored.");
        }
      }

      function assertReducerShape(reducers) {
        Object.keys(reducers).forEach(function (key) {
          var reducer = reducers[key];
          var initialState = reducer(undefined, {
            type: ActionTypes.INIT
          });

          if (typeof initialState === 'undefined') {
            throw new Error("Reducer \"" + key + "\" returned undefined during initialization. " + "If the state passed to the reducer is undefined, you must " + "explicitly return the initial state. The initial state may " + "not be undefined. If you don't want to set a value for this reducer, " + "you can use null instead of undefined.");
          }

          if (typeof reducer(undefined, {
            type: ActionTypes.PROBE_UNKNOWN_ACTION()
          }) === 'undefined') {
            throw new Error("Reducer \"" + key + "\" returned undefined when probed with a random type. " + ("Don't try to handle " + ActionTypes.INIT + " or other actions in \"redux/*\" ") + "namespace. They are considered private. Instead, you must return the " + "current state for any unknown actions, unless it is undefined, " + "in which case you must return the initial state, regardless of the " + "action type. The initial state may not be undefined, but can be null.");
          }
        });
      }
      /**
       * Turns an object whose values are different reducer functions, into a single
       * reducer function. It will call every child reducer, and gather their results
       * into a single state object, whose keys correspond to the keys of the passed
       * reducer functions.
       *
       * @param {Object} reducers An object whose values correspond to different
       * reducer functions that need to be combined into one. One handy way to obtain
       * it is to use ES6 `import * as reducers` syntax. The reducers may never return
       * undefined for any action. Instead, they should return their initial state
       * if the state passed to them was undefined, and the current state for any
       * unrecognized action.
       *
       * @returns {Function} A reducer function that invokes every reducer inside the
       * passed object, and builds a state object with the same shape.
       */


      function combineReducers(reducers) {
        var reducerKeys = Object.keys(reducers);
        var finalReducers = {};

        for (var i = 0; i < reducerKeys.length; i++) {
          var key = reducerKeys[i];

          if (false) {}

          if (typeof reducers[key] === 'function') {
            finalReducers[key] = reducers[key];
          }
        }

        var finalReducerKeys = Object.keys(finalReducers); // This is used to make sure we don't warn about the same
        // keys multiple times.

        var unexpectedKeyCache;

        if (false) {}

        var shapeAssertionError;

        try {
          assertReducerShape(finalReducers);
        } catch (e) {
          shapeAssertionError = e;
        }

        return function combination(state, action) {
          if (state === void 0) {
            state = {};
          }

          if (shapeAssertionError) {
            throw shapeAssertionError;
          }

          if (false) {
            var warningMessage;
          }

          var hasChanged = false;
          var nextState = {};

          for (var _i = 0; _i < finalReducerKeys.length; _i++) {
            var _key = finalReducerKeys[_i];
            var reducer = finalReducers[_key];
            var previousStateForKey = state[_key];
            var nextStateForKey = reducer(previousStateForKey, action);

            if (typeof nextStateForKey === 'undefined') {
              var errorMessage = getUndefinedStateErrorMessage(_key, action);
              throw new Error(errorMessage);
            }

            nextState[_key] = nextStateForKey;
            hasChanged = hasChanged || nextStateForKey !== previousStateForKey;
          }

          return hasChanged ? nextState : state;
        };
      }

      function bindActionCreator(actionCreator, dispatch) {
        return function () {
          return dispatch(actionCreator.apply(this, arguments));
        };
      }
      /**
       * Turns an object whose values are action creators, into an object with the
       * same keys, but with every function wrapped into a `dispatch` call so they
       * may be invoked directly. This is just a convenience method, as you can call
       * `store.dispatch(MyActionCreators.doSomething())` yourself just fine.
       *
       * For convenience, you can also pass an action creator as the first argument,
       * and get a dispatch wrapped function in return.
       *
       * @param {Function|Object} actionCreators An object whose values are action
       * creator functions. One handy way to obtain it is to use ES6 `import * as`
       * syntax. You may also pass a single function.
       *
       * @param {Function} dispatch The `dispatch` function available on your Redux
       * store.
       *
       * @returns {Function|Object} The object mimicking the original object, but with
       * every action creator wrapped into the `dispatch` call. If you passed a
       * function as `actionCreators`, the return value will also be a single
       * function.
       */


      function bindActionCreators(actionCreators, dispatch) {
        if (typeof actionCreators === 'function') {
          return bindActionCreator(actionCreators, dispatch);
        }

        if (typeof actionCreators !== 'object' || actionCreators === null) {
          throw new Error("bindActionCreators expected an object or a function, instead received " + (actionCreators === null ? 'null' : typeof actionCreators) + ". " + "Did you write \"import ActionCreators from\" instead of \"import * as ActionCreators from\"?");
        }

        var boundActionCreators = {};

        for (var key in actionCreators) {
          var actionCreator = actionCreators[key];

          if (typeof actionCreator === 'function') {
            boundActionCreators[key] = bindActionCreator(actionCreator, dispatch);
          }
        }

        return boundActionCreators;
      }

      function _defineProperty(obj, key, value) {
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }

        return obj;
      }

      function ownKeys(object, enumerableOnly) {
        var keys = Object.keys(object);

        if (Object.getOwnPropertySymbols) {
          keys.push.apply(keys, Object.getOwnPropertySymbols(object));
        }

        if (enumerableOnly) keys = keys.filter(function (sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        });
        return keys;
      }

      function _objectSpread2(target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i] != null ? arguments[i] : {};

          if (i % 2) {
            ownKeys(source, true).forEach(function (key) {
              _defineProperty(target, key, source[key]);
            });
          } else if (Object.getOwnPropertyDescriptors) {
            Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
          } else {
            ownKeys(source).forEach(function (key) {
              Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
            });
          }
        }

        return target;
      }
      /**
       * Composes single-argument functions from right to left. The rightmost
       * function can take multiple arguments as it provides the signature for
       * the resulting composite function.
       *
       * @param {...Function} funcs The functions to compose.
       * @returns {Function} A function obtained by composing the argument functions
       * from right to left. For example, compose(f, g, h) is identical to doing
       * (...args) => f(g(h(...args))).
       */


      function compose() {
        for (var _len = arguments.length, funcs = new Array(_len), _key = 0; _key < _len; _key++) {
          funcs[_key] = arguments[_key];
        }

        if (funcs.length === 0) {
          return function (arg) {
            return arg;
          };
        }

        if (funcs.length === 1) {
          return funcs[0];
        }

        return funcs.reduce(function (a, b) {
          return function () {
            return a(b.apply(void 0, arguments));
          };
        });
      }
      /**
       * Creates a store enhancer that applies middleware to the dispatch method
       * of the Redux store. This is handy for a variety of tasks, such as expressing
       * asynchronous actions in a concise manner, or logging every action payload.
       *
       * See `redux-thunk` package as an example of the Redux middleware.
       *
       * Because middleware is potentially asynchronous, this should be the first
       * store enhancer in the composition chain.
       *
       * Note that each middleware will be given the `dispatch` and `getState` functions
       * as named arguments.
       *
       * @param {...Function} middlewares The middleware chain to be applied.
       * @returns {Function} A store enhancer applying the middleware.
       */


      function applyMiddleware() {
        for (var _len = arguments.length, middlewares = new Array(_len), _key = 0; _key < _len; _key++) {
          middlewares[_key] = arguments[_key];
        }

        return function (createStore) {
          return function () {
            var store = createStore.apply(void 0, arguments);

            var _dispatch = function dispatch() {
              throw new Error('Dispatching while constructing your middleware is not allowed. ' + 'Other middleware would not be applied to this dispatch.');
            };

            var middlewareAPI = {
              getState: store.getState,
              dispatch: function dispatch() {
                return _dispatch.apply(void 0, arguments);
              }
            };
            var chain = middlewares.map(function (middleware) {
              return middleware(middlewareAPI);
            });
            _dispatch = compose.apply(void 0, chain)(store.dispatch);
            return _objectSpread2({}, store, {
              dispatch: _dispatch
            });
          };
        };
      }
      /*
       * This is a dummy function to check if the function name has been altered by minification.
       * If the function has been minified and NODE_ENV !== 'production', warn the user.
       */


      function isCrushed() {}

      if (false) {} // CONCATENATED MODULE: ./src/scripts/reducers/items.js


      var defaultState = [];

      function items_items(state, action) {
        if (state === void 0) {
          state = defaultState;
        }

        switch (action.type) {
          case 'ADD_ITEM':
            {
              // Add object to items array
              var newState = [].concat(state, [{
                id: action.id,
                choiceId: action.choiceId,
                groupId: action.groupId,
                value: action.value,
                label: action.label,
                active: true,
                highlighted: false,
                customProperties: action.customProperties,
                placeholder: action.placeholder || false,
                keyCode: null
              }]);
              return newState.map(function (obj) {
                var item = obj;
                item.highlighted = false;
                return item;
              });
            }

          case 'REMOVE_ITEM':
            {
              // Set item to inactive
              return state.map(function (obj) {
                var item = obj;

                if (item.id === action.id) {
                  item.active = false;
                }

                return item;
              });
            }

          case 'HIGHLIGHT_ITEM':
            {
              return state.map(function (obj) {
                var item = obj;

                if (item.id === action.id) {
                  item.highlighted = action.highlighted;
                }

                return item;
              });
            }

          default:
            {
              return state;
            }
        }
      } // CONCATENATED MODULE: ./src/scripts/reducers/groups.js


      var groups_defaultState = [];

      function groups(state, action) {
        if (state === void 0) {
          state = groups_defaultState;
        }

        switch (action.type) {
          case 'ADD_GROUP':
            {
              return [].concat(state, [{
                id: action.id,
                value: action.value,
                active: action.active,
                disabled: action.disabled
              }]);
            }

          case 'CLEAR_CHOICES':
            {
              return [];
            }

          default:
            {
              return state;
            }
        }
      } // CONCATENATED MODULE: ./src/scripts/reducers/choices.js


      var choices_defaultState = [];

      function choices_choices(state, action) {
        if (state === void 0) {
          state = choices_defaultState;
        }

        switch (action.type) {
          case 'ADD_CHOICE':
            {
              /*
                  A disabled choice appears in the choice dropdown but cannot be selected
                  A selected choice has been added to the passed input's value (added as an item)
                  An active choice appears within the choice dropdown
               */
              return [].concat(state, [{
                id: action.id,
                elementId: action.elementId,
                groupId: action.groupId,
                value: action.value,
                label: action.label || action.value,
                disabled: action.disabled || false,
                selected: false,
                active: true,
                score: 9999,
                customProperties: action.customProperties,
                placeholder: action.placeholder || false,
                keyCode: null
              }]);
            }

          case 'ADD_ITEM':
            {
              // If all choices need to be activated
              if (action.activateOptions) {
                return state.map(function (obj) {
                  var choice = obj;
                  choice.active = action.active;
                  return choice;
                });
              } // When an item is added and it has an associated choice,
              // we want to disable it so it can't be chosen again


              if (action.choiceId > -1) {
                return state.map(function (obj) {
                  var choice = obj;

                  if (choice.id === parseInt(action.choiceId, 10)) {
                    choice.selected = true;
                  }

                  return choice;
                });
              }

              return state;
            }

          case 'REMOVE_ITEM':
            {
              // When an item is removed and it has an associated choice,
              // we want to re-enable it so it can be chosen again
              if (action.choiceId > -1) {
                return state.map(function (obj) {
                  var choice = obj;

                  if (choice.id === parseInt(action.choiceId, 10)) {
                    choice.selected = false;
                  }

                  return choice;
                });
              }

              return state;
            }

          case 'FILTER_CHOICES':
            {
              return state.map(function (obj) {
                var choice = obj; // Set active state based on whether choice is
                // within filtered results

                choice.active = action.results.some(function (_ref) {
                  var item = _ref.item,
                      score = _ref.score;

                  if (item.id === choice.id) {
                    choice.score = score;
                    return true;
                  }

                  return false;
                });
                return choice;
              });
            }

          case 'ACTIVATE_CHOICES':
            {
              return state.map(function (obj) {
                var choice = obj;
                choice.active = action.active;
                return choice;
              });
            }

          case 'CLEAR_CHOICES':
            {
              return choices_defaultState;
            }

          default:
            {
              return state;
            }
        }
      } // CONCATENATED MODULE: ./src/scripts/reducers/general.js


      var general_defaultState = {
        loading: false
      };

      var general = function general(state, action) {
        if (state === void 0) {
          state = general_defaultState;
        }

        switch (action.type) {
          case 'SET_IS_LOADING':
            {
              return {
                loading: action.isLoading
              };
            }

          default:
            {
              return state;
            }
        }
      };
      /* harmony default export */


      var reducers_general = general; // CONCATENATED MODULE: ./src/scripts/lib/utils.js

      /**
       * @param {number} min
       * @param {number} max
       * @returns {number}
       */

      var getRandomNumber = function getRandomNumber(min, max) {
        return Math.floor(Math.random() * (max - min) + min);
      };
      /**
       * @param {number} length
       * @returns {string}
       */


      var generateChars = function generateChars(length) {
        return Array.from({
          length: length
        }, function () {
          return getRandomNumber(0, 36).toString(36);
        }).join('');
      };
      /**
       * @param {HTMLInputElement | HTMLSelectElement} element
       * @param {string} prefix
       * @returns {string}
       */


      var generateId = function generateId(element, prefix) {
        var id = element.id || element.name && element.name + "-" + generateChars(2) || generateChars(4);
        id = id.replace(/(:|\.|\[|\]|,)/g, '');
        id = prefix + "-" + id;
        return id;
      };
      /**
       * @param {any} obj
       * @returns {string}
       */


      var getType = function getType(obj) {
        return Object.prototype.toString.call(obj).slice(8, -1);
      };
      /**
       * @param {string} type
       * @param {any} obj
       * @returns {boolean}
       */


      var isType = function isType(type, obj) {
        return obj !== undefined && obj !== null && getType(obj) === type;
      };
      /**
       * @param {HTMLElement} element
       * @param {HTMLElement} [wrapper={HTMLDivElement}]
       * @returns {HTMLElement}
       */


      var utils_wrap = function wrap(element, wrapper) {
        if (wrapper === void 0) {
          wrapper = document.createElement('div');
        }

        if (element.nextSibling) {
          element.parentNode.insertBefore(wrapper, element.nextSibling);
        } else {
          element.parentNode.appendChild(wrapper);
        }

        return wrapper.appendChild(element);
      };
      /**
       * @param {Element} startEl
       * @param {string} selector
       * @param {1 | -1} direction
       * @returns {Element | undefined}
       */


      var getAdjacentEl = function getAdjacentEl(startEl, selector, direction) {
        if (direction === void 0) {
          direction = 1;
        }

        if (!(startEl instanceof Element) || typeof selector !== 'string') {
          return undefined;
        }

        var prop = (direction > 0 ? 'next' : 'previous') + "ElementSibling";
        var sibling = startEl[prop];

        while (sibling) {
          if (sibling.matches(selector)) {
            return sibling;
          }

          sibling = sibling[prop];
        }

        return sibling;
      };
      /**
       * @param {Element} element
       * @param {Element} parent
       * @param {-1 | 1} direction
       * @returns {boolean}
       */


      var isScrolledIntoView = function isScrolledIntoView(element, parent, direction) {
        if (direction === void 0) {
          direction = 1;
        }

        if (!element) {
          return false;
        }

        var isVisible;

        if (direction > 0) {
          // In view from bottom
          isVisible = parent.scrollTop + parent.offsetHeight >= element.offsetTop + element.offsetHeight;
        } else {
          // In view from top
          isVisible = element.offsetTop >= parent.scrollTop;
        }

        return isVisible;
      };
      /**
       * @param {any} value
       * @returns {any}
       */


      var sanitise = function sanitise(value) {
        if (typeof value !== 'string') {
          return value;
        }

        return value.replace(/&/g, '&amp;').replace(/>/g, '&rt;').replace(/</g, '&lt;').replace(/"/g, '&quot;');
      };
      /**
       * @returns {() => (str: string) => Element}
       */


      var strToEl = function () {
        var tmpEl = document.createElement('div');
        return function (str) {
          var cleanedInput = str.trim();
          tmpEl.innerHTML = cleanedInput;
          var firldChild = tmpEl.children[0];

          while (tmpEl.firstChild) {
            tmpEl.removeChild(tmpEl.firstChild);
          }

          return firldChild;
        };
      }();
      /**
       * @param {{ label?: string, value: string }} a
       * @param {{ label?: string, value: string }} b
       * @returns {number}
       */


      var sortByAlpha = function sortByAlpha(_ref, _ref2) {
        var value = _ref.value,
            _ref$label = _ref.label,
            label = _ref$label === void 0 ? value : _ref$label;
        var value2 = _ref2.value,
            _ref2$label = _ref2.label,
            label2 = _ref2$label === void 0 ? value2 : _ref2$label;
        return label.localeCompare(label2, [], {
          sensitivity: 'base',
          ignorePunctuation: true,
          numeric: true
        });
      };
      /**
       * @param {{ score: number }} a
       * @param {{ score: number }} b
       */


      var sortByScore = function sortByScore(a, b) {
        return a.score - b.score;
      };
      /**
       * @param {HTMLElement} element
       * @param {string} type
       * @param {object} customArgs
       */


      var dispatchEvent = function dispatchEvent(element, type, customArgs) {
        if (customArgs === void 0) {
          customArgs = null;
        }

        var event = new CustomEvent(type, {
          detail: customArgs,
          bubbles: true,
          cancelable: true
        });
        return element.dispatchEvent(event);
      };
      /**
       * @param {array} array
       * @param {any} value
       * @param {string} [key="value"]
       * @returns {boolean}
       */


      var existsInArray = function existsInArray(array, value, key) {
        if (key === void 0) {
          key = 'value';
        }

        return array.some(function (item) {
          if (typeof value === 'string') {
            return item[key] === value.trim();
          }

          return item[key] === value;
        });
      };
      /**
       * @param {any} obj
       * @returns {any}
       */


      var cloneObject = function cloneObject(obj) {
        return JSON.parse(JSON.stringify(obj));
      };
      /**
       * Returns an array of keys present on the first but missing on the second object
       * @param {object} a
       * @param {object} b
       * @returns {string[]}
       */


      var diff = function diff(a, b) {
        var aKeys = Object.keys(a).sort();
        var bKeys = Object.keys(b).sort();
        return aKeys.filter(function (i) {
          return bKeys.indexOf(i) < 0;
        });
      }; // CONCATENATED MODULE: ./src/scripts/reducers/index.js


      var appReducer = combineReducers({
        items: items_items,
        groups: groups,
        choices: choices_choices,
        general: reducers_general
      });

      var reducers_rootReducer = function rootReducer(passedState, action) {
        var state = passedState; // If we are clearing all items, groups and options we reassign
        // state and then pass that state to our proper reducer. This isn't
        // mutating our actual state
        // See: http://stackoverflow.com/a/35641992

        if (action.type === 'CLEAR_ALL') {
          state = undefined;
        } else if (action.type === 'RESET_TO') {
          return cloneObject(action.state);
        }

        return appReducer(state, action);
      };
      /* harmony default export */


      var reducers = reducers_rootReducer; // CONCATENATED MODULE: ./src/scripts/store/store.js

      function _defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function _createClass(Constructor, protoProps, staticProps) {
        if (protoProps) _defineProperties(Constructor.prototype, protoProps);
        if (staticProps) _defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /**
       * @typedef {import('../../../types/index').Choices.Choice} Choice
       * @typedef {import('../../../types/index').Choices.Group} Group
       * @typedef {import('../../../types/index').Choices.Item} Item
       */


      var store_Store = /*#__PURE__*/function () {
        function Store() {
          this._store = createStore(reducers, window.__REDUX_DEVTOOLS_EXTENSION__ && window.__REDUX_DEVTOOLS_EXTENSION__());
        }
        /**
         * Subscribe store to function call (wrapped Redux method)
         * @param  {Function} onChange Function to trigger when state changes
         * @return
         */


        var _proto = Store.prototype;

        _proto.subscribe = function subscribe(onChange) {
          this._store.subscribe(onChange);
        }
        /**
         * Dispatch event to store (wrapped Redux method)
         * @param  {{ type: string, [x: string]: any }} action Action to trigger
         * @return
         */
        ;

        _proto.dispatch = function dispatch(action) {
          this._store.dispatch(action);
        }
        /**
         * Get store object (wrapping Redux method)
         * @returns {object} State
         */
        ;
        /**
         * Get loading state from store
         * @returns {boolean} Loading State
         */


        _proto.isLoading = function isLoading() {
          return this.state.general.loading;
        }
        /**
         * Get single choice by it's ID
         * @param {string} id
         * @returns {Choice | undefined} Found choice
         */
        ;

        _proto.getChoiceById = function getChoiceById(id) {
          return this.activeChoices.find(function (choice) {
            return choice.id === parseInt(id, 10);
          });
        }
        /**
         * Get group by group id
         * @param  {number} id Group ID
         * @returns {Group | undefined} Group data
         */
        ;

        _proto.getGroupById = function getGroupById(id) {
          return this.groups.find(function (group) {
            return group.id === id;
          });
        };

        _createClass(Store, [{
          key: "state",
          get: function get() {
            return this._store.getState();
          }
          /**
           * Get items from store
           * @returns {Item[]} Item objects
           */

        }, {
          key: "items",
          get: function get() {
            return this.state.items;
          }
          /**
           * Get active items from store
           * @returns {Item[]} Item objects
           */

        }, {
          key: "activeItems",
          get: function get() {
            return this.items.filter(function (item) {
              return item.active === true;
            });
          }
          /**
           * Get highlighted items from store
           * @returns {Item[]} Item objects
           */

        }, {
          key: "highlightedActiveItems",
          get: function get() {
            return this.items.filter(function (item) {
              return item.active && item.highlighted;
            });
          }
          /**
           * Get choices from store
           * @returns {Choice[]} Option objects
           */

        }, {
          key: "choices",
          get: function get() {
            return this.state.choices;
          }
          /**
           * Get active choices from store
           * @returns {Choice[]} Option objects
           */

        }, {
          key: "activeChoices",
          get: function get() {
            return this.choices.filter(function (choice) {
              return choice.active === true;
            });
          }
          /**
           * Get selectable choices from store
           * @returns {Choice[]} Option objects
           */

        }, {
          key: "selectableChoices",
          get: function get() {
            return this.choices.filter(function (choice) {
              return choice.disabled !== true;
            });
          }
          /**
           * Get choices that can be searched (excluding placeholders)
           * @returns {Choice[]} Option objects
           */

        }, {
          key: "searchableChoices",
          get: function get() {
            return this.selectableChoices.filter(function (choice) {
              return choice.placeholder !== true;
            });
          }
          /**
           * Get placeholder choice from store
           * @returns {Choice | undefined} Found placeholder
           */

        }, {
          key: "placeholderChoice",
          get: function get() {
            return [].concat(this.choices).reverse().find(function (choice) {
              return choice.placeholder === true;
            });
          }
          /**
           * Get groups from store
           * @returns {Group[]} Group objects
           */

        }, {
          key: "groups",
          get: function get() {
            return this.state.groups;
          }
          /**
           * Get active groups from store
           * @returns {Group[]} Group objects
           */

        }, {
          key: "activeGroups",
          get: function get() {
            var groups = this.groups,
                choices = this.choices;
            return groups.filter(function (group) {
              var isActive = group.active === true && group.disabled === false;
              var hasActiveOptions = choices.some(function (choice) {
                return choice.active === true && choice.disabled === false;
              });
              return isActive && hasActiveOptions;
            }, []);
          }
        }]);

        return Store;
      }(); // CONCATENATED MODULE: ./src/scripts/components/dropdown.js


      function dropdown_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function dropdown_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) dropdown_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) dropdown_defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /**
       * @typedef {import('../../../types/index').Choices.passedElement} passedElement
       * @typedef {import('../../../types/index').Choices.ClassNames} ClassNames
       */


      var Dropdown = /*#__PURE__*/function () {
        /**
         * @param {{
         *  element: HTMLElement,
         *  type: passedElement['type'],
         *  classNames: ClassNames,
         * }} args
         */
        function Dropdown(_ref) {
          var element = _ref.element,
              type = _ref.type,
              classNames = _ref.classNames;
          this.element = element;
          this.classNames = classNames;
          this.type = type;
          this.isActive = false;
        }
        /**
         * Bottom position of dropdown in viewport coordinates
         * @returns {number} Vertical position
         */


        var _proto = Dropdown.prototype;
        /**
         * Find element that matches passed selector
         * @param {string} selector
         * @returns {HTMLElement | null}
         */

        _proto.getChild = function getChild(selector) {
          return this.element.querySelector(selector);
        }
        /**
         * Show dropdown to user by adding active state class
         * @returns {this}
         */
        ;

        _proto.show = function show() {
          this.element.classList.add(this.classNames.activeState);
          this.element.setAttribute('aria-expanded', 'true');
          this.isActive = true;
          return this;
        }
        /**
         * Hide dropdown from user
         * @returns {this}
         */
        ;

        _proto.hide = function hide() {
          this.element.classList.remove(this.classNames.activeState);
          this.element.setAttribute('aria-expanded', 'false');
          this.isActive = false;
          return this;
        };

        dropdown_createClass(Dropdown, [{
          key: "distanceFromTopWindow",
          get: function get() {
            return this.element.getBoundingClientRect().bottom;
          }
        }]);
        return Dropdown;
      }(); // CONCATENATED MODULE: ./src/scripts/constants.js

      /**
       * @typedef {import('../../types/index').Choices.ClassNames} ClassNames
       * @typedef {import('../../types/index').Choices.Options} Options
       */

      /** @type {ClassNames} */


      var DEFAULT_CLASSNAMES = {
        containerOuter: 'choices',
        containerInner: 'choices__inner',
        input: 'choices__input',
        inputCloned: 'choices__input--cloned',
        list: 'choices__list',
        listItems: 'choices__list--multiple',
        listSingle: 'choices__list--single',
        listDropdown: 'choices__list--dropdown',
        item: 'choices__item',
        itemSelectable: 'choices__item--selectable',
        itemDisabled: 'choices__item--disabled',
        itemChoice: 'choices__item--choice',
        placeholder: 'choices__placeholder',
        group: 'choices__group',
        groupHeading: 'choices__heading',
        button: 'choices__button',
        activeState: 'is-active',
        focusState: 'is-focused',
        openState: 'is-open',
        disabledState: 'is-disabled',
        highlightedState: 'is-highlighted',
        selectedState: 'is-selected',
        flippedState: 'is-flipped',
        loadingState: 'is-loading',
        noResults: 'has-no-results',
        noChoices: 'has-no-choices'
      };
      /** @type {Options} */

      var DEFAULT_CONFIG = {
        items: [],
        choices: [],
        silent: false,
        renderChoiceLimit: -1,
        maxItemCount: -1,
        addItems: true,
        addItemFilter: null,
        removeItems: true,
        removeItemButton: false,
        editItems: false,
        duplicateItemsAllowed: true,
        delimiter: ',',
        paste: true,
        searchEnabled: true,
        searchChoices: true,
        searchFloor: 1,
        searchResultLimit: 4,
        searchFields: ['label', 'value'],
        position: 'auto',
        resetScrollPosition: true,
        shouldSort: true,
        shouldSortItems: false,
        sorter: sortByAlpha,
        placeholder: true,
        placeholderValue: null,
        searchPlaceholderValue: null,
        prependValue: null,
        appendValue: null,
        renderSelectedChoices: 'auto',
        loadingText: 'Loading...',
        noResultsText: 'No results found',
        noChoicesText: 'No choices to choose from',
        itemSelectText: 'Press to select',
        uniqueItemText: 'Only unique values can be added',
        customAddItemText: 'Only values matching specific conditions can be added',
        addItemText: function addItemText(value) {
          return "Press Enter to add <b>\"" + sanitise(value) + "\"</b>";
        },
        maxItemText: function maxItemText(maxItemCount) {
          return "Only " + maxItemCount + " values can be added";
        },
        valueComparer: function valueComparer(value1, value2) {
          return value1 === value2;
        },
        fuseOptions: {
          includeScore: true
        },
        callbackOnInit: null,
        callbackOnCreateTemplates: null,
        classNames: DEFAULT_CLASSNAMES
      };
      var EVENTS = {
        showDropdown: 'showDropdown',
        hideDropdown: 'hideDropdown',
        change: 'change',
        choice: 'choice',
        search: 'search',
        addItem: 'addItem',
        removeItem: 'removeItem',
        highlightItem: 'highlightItem',
        highlightChoice: 'highlightChoice'
      };
      var ACTION_TYPES = {
        ADD_CHOICE: 'ADD_CHOICE',
        FILTER_CHOICES: 'FILTER_CHOICES',
        ACTIVATE_CHOICES: 'ACTIVATE_CHOICES',
        CLEAR_CHOICES: 'CLEAR_CHOICES',
        ADD_GROUP: 'ADD_GROUP',
        ADD_ITEM: 'ADD_ITEM',
        REMOVE_ITEM: 'REMOVE_ITEM',
        HIGHLIGHT_ITEM: 'HIGHLIGHT_ITEM',
        CLEAR_ALL: 'CLEAR_ALL'
      };
      var KEY_CODES = {
        BACK_KEY: 46,
        DELETE_KEY: 8,
        ENTER_KEY: 13,
        A_KEY: 65,
        ESC_KEY: 27,
        UP_KEY: 38,
        DOWN_KEY: 40,
        PAGE_UP_KEY: 33,
        PAGE_DOWN_KEY: 34
      };
      var TEXT_TYPE = 'text';
      var SELECT_ONE_TYPE = 'select-one';
      var SELECT_MULTIPLE_TYPE = 'select-multiple';
      var SCROLLING_SPEED = 4; // CONCATENATED MODULE: ./src/scripts/components/container.js

      /**
       * @typedef {import('../../../types/index').Choices.passedElement} passedElement
       * @typedef {import('../../../types/index').Choices.ClassNames} ClassNames
       */

      var container_Container = /*#__PURE__*/function () {
        /**
         * @param {{
         *  element: HTMLElement,
         *  type: passedElement['type'],
         *  classNames: ClassNames,
         *  position
         * }} args
         */
        function Container(_ref) {
          var element = _ref.element,
              type = _ref.type,
              classNames = _ref.classNames,
              position = _ref.position;
          this.element = element;
          this.classNames = classNames;
          this.type = type;
          this.position = position;
          this.isOpen = false;
          this.isFlipped = false;
          this.isFocussed = false;
          this.isDisabled = false;
          this.isLoading = false;
          this._onFocus = this._onFocus.bind(this);
          this._onBlur = this._onBlur.bind(this);
        }

        var _proto = Container.prototype;

        _proto.addEventListeners = function addEventListeners() {
          this.element.addEventListener('focus', this._onFocus);
          this.element.addEventListener('blur', this._onBlur);
        };

        _proto.removeEventListeners = function removeEventListeners() {
          this.element.removeEventListener('focus', this._onFocus);
          this.element.removeEventListener('blur', this._onBlur);
        }
        /**
         * Determine whether container should be flipped based on passed
         * dropdown position
         * @param {number} dropdownPos
         * @returns {boolean}
         */
        ;

        _proto.shouldFlip = function shouldFlip(dropdownPos) {
          if (typeof dropdownPos !== 'number') {
            return false;
          } // If flip is enabled and the dropdown bottom position is
          // greater than the window height flip the dropdown.


          var shouldFlip = false;

          if (this.position === 'auto') {
            shouldFlip = !window.matchMedia("(min-height: " + (dropdownPos + 1) + "px)").matches;
          } else if (this.position === 'top') {
            shouldFlip = true;
          }

          return shouldFlip;
        }
        /**
         * @param {string} activeDescendantID
         */
        ;

        _proto.setActiveDescendant = function setActiveDescendant(activeDescendantID) {
          this.element.setAttribute('aria-activedescendant', activeDescendantID);
        };

        _proto.removeActiveDescendant = function removeActiveDescendant() {
          this.element.removeAttribute('aria-activedescendant');
        }
        /**
         * @param {number} dropdownPos
         */
        ;

        _proto.open = function open(dropdownPos) {
          this.element.classList.add(this.classNames.openState);
          this.element.setAttribute('aria-expanded', 'true');
          this.isOpen = true;

          if (this.shouldFlip(dropdownPos)) {
            this.element.classList.add(this.classNames.flippedState);
            this.isFlipped = true;
          }
        };

        _proto.close = function close() {
          this.element.classList.remove(this.classNames.openState);
          this.element.setAttribute('aria-expanded', 'false');
          this.removeActiveDescendant();
          this.isOpen = false; // A dropdown flips if it does not have space within the page

          if (this.isFlipped) {
            this.element.classList.remove(this.classNames.flippedState);
            this.isFlipped = false;
          }
        };

        _proto.focus = function focus() {
          if (!this.isFocussed) {
            this.element.focus();
          }
        };

        _proto.addFocusState = function addFocusState() {
          this.element.classList.add(this.classNames.focusState);
        };

        _proto.removeFocusState = function removeFocusState() {
          this.element.classList.remove(this.classNames.focusState);
        };

        _proto.enable = function enable() {
          this.element.classList.remove(this.classNames.disabledState);
          this.element.removeAttribute('aria-disabled');

          if (this.type === SELECT_ONE_TYPE) {
            this.element.setAttribute('tabindex', '0');
          }

          this.isDisabled = false;
        };

        _proto.disable = function disable() {
          this.element.classList.add(this.classNames.disabledState);
          this.element.setAttribute('aria-disabled', 'true');

          if (this.type === SELECT_ONE_TYPE) {
            this.element.setAttribute('tabindex', '-1');
          }

          this.isDisabled = true;
        }
        /**
         * @param {HTMLElement} element
         */
        ;

        _proto.wrap = function wrap(element) {
          utils_wrap(element, this.element);
        }
        /**
         * @param {Element} element
         */
        ;

        _proto.unwrap = function unwrap(element) {
          // Move passed element outside this element
          this.element.parentNode.insertBefore(element, this.element); // Remove this element

          this.element.parentNode.removeChild(this.element);
        };

        _proto.addLoadingState = function addLoadingState() {
          this.element.classList.add(this.classNames.loadingState);
          this.element.setAttribute('aria-busy', 'true');
          this.isLoading = true;
        };

        _proto.removeLoadingState = function removeLoadingState() {
          this.element.classList.remove(this.classNames.loadingState);
          this.element.removeAttribute('aria-busy');
          this.isLoading = false;
        };

        _proto._onFocus = function _onFocus() {
          this.isFocussed = true;
        };

        _proto._onBlur = function _onBlur() {
          this.isFocussed = false;
        };

        return Container;
      }(); // CONCATENATED MODULE: ./src/scripts/components/input.js


      function input_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function input_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) input_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) input_defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /**
       * @typedef {import('../../../types/index').Choices.passedElement} passedElement
       * @typedef {import('../../../types/index').Choices.ClassNames} ClassNames
       */


      var input_Input = /*#__PURE__*/function () {
        /**
         * @param {{
         *  element: HTMLInputElement,
         *  type: passedElement['type'],
         *  classNames: ClassNames,
         *  preventPaste: boolean
         * }} args
         */
        function Input(_ref) {
          var element = _ref.element,
              type = _ref.type,
              classNames = _ref.classNames,
              preventPaste = _ref.preventPaste;
          this.element = element;
          this.type = type;
          this.classNames = classNames;
          this.preventPaste = preventPaste;
          this.isFocussed = this.element === document.activeElement;
          this.isDisabled = element.disabled;
          this._onPaste = this._onPaste.bind(this);
          this._onInput = this._onInput.bind(this);
          this._onFocus = this._onFocus.bind(this);
          this._onBlur = this._onBlur.bind(this);
        }
        /**
         * @param {string} placeholder
         */


        var _proto = Input.prototype;

        _proto.addEventListeners = function addEventListeners() {
          this.element.addEventListener('paste', this._onPaste);
          this.element.addEventListener('input', this._onInput, {
            passive: true
          });
          this.element.addEventListener('focus', this._onFocus, {
            passive: true
          });
          this.element.addEventListener('blur', this._onBlur, {
            passive: true
          });
        };

        _proto.removeEventListeners = function removeEventListeners() {
          this.element.removeEventListener('input', this._onInput, {
            passive: true
          });
          this.element.removeEventListener('paste', this._onPaste);
          this.element.removeEventListener('focus', this._onFocus, {
            passive: true
          });
          this.element.removeEventListener('blur', this._onBlur, {
            passive: true
          });
        };

        _proto.enable = function enable() {
          this.element.removeAttribute('disabled');
          this.isDisabled = false;
        };

        _proto.disable = function disable() {
          this.element.setAttribute('disabled', '');
          this.isDisabled = true;
        };

        _proto.focus = function focus() {
          if (!this.isFocussed) {
            this.element.focus();
          }
        };

        _proto.blur = function blur() {
          if (this.isFocussed) {
            this.element.blur();
          }
        }
        /**
         * Set value of input to blank
         * @param {boolean} setWidth
         * @returns {this}
         */
        ;

        _proto.clear = function clear(setWidth) {
          if (setWidth === void 0) {
            setWidth = true;
          }

          if (this.element.value) {
            this.element.value = '';
          }

          if (setWidth) {
            this.setWidth();
          }

          return this;
        }
        /**
         * Set the correct input width based on placeholder
         * value or input value
         */
        ;

        _proto.setWidth = function setWidth() {
          // Resize input to contents or placeholder
          var _this$element = this.element,
              style = _this$element.style,
              value = _this$element.value,
              placeholder = _this$element.placeholder;
          style.minWidth = placeholder.length + 1 + "ch";
          style.width = value.length + 1 + "ch";
        }
        /**
         * @param {string} activeDescendantID
         */
        ;

        _proto.setActiveDescendant = function setActiveDescendant(activeDescendantID) {
          this.element.setAttribute('aria-activedescendant', activeDescendantID);
        };

        _proto.removeActiveDescendant = function removeActiveDescendant() {
          this.element.removeAttribute('aria-activedescendant');
        };

        _proto._onInput = function _onInput() {
          if (this.type !== SELECT_ONE_TYPE) {
            this.setWidth();
          }
        }
        /**
         * @param {Event} event
         */
        ;

        _proto._onPaste = function _onPaste(event) {
          if (this.preventPaste) {
            event.preventDefault();
          }
        };

        _proto._onFocus = function _onFocus() {
          this.isFocussed = true;
        };

        _proto._onBlur = function _onBlur() {
          this.isFocussed = false;
        };

        input_createClass(Input, [{
          key: "placeholder",
          set: function set(placeholder) {
            this.element.placeholder = placeholder;
          }
          /**
           * @returns {string}
           */

        }, {
          key: "value",
          get: function get() {
            return sanitise(this.element.value);
          }
          /**
           * @param {string} value
           */
          ,
          set: function set(value) {
            this.element.value = value;
          }
        }]);
        return Input;
      }(); // CONCATENATED MODULE: ./src/scripts/components/list.js

      /**
       * @typedef {import('../../../types/index').Choices.Choice} Choice
       */


      var list_List = /*#__PURE__*/function () {
        /**
         * @param {{ element: HTMLElement }} args
         */
        function List(_ref) {
          var element = _ref.element;
          this.element = element;
          this.scrollPos = this.element.scrollTop;
          this.height = this.element.offsetHeight;
        }

        var _proto = List.prototype;

        _proto.clear = function clear() {
          this.element.innerHTML = '';
        }
        /**
         * @param {Element | DocumentFragment} node
         */
        ;

        _proto.append = function append(node) {
          this.element.appendChild(node);
        }
        /**
         * @param {string} selector
         * @returns {Element | null}
         */
        ;

        _proto.getChild = function getChild(selector) {
          return this.element.querySelector(selector);
        }
        /**
         * @returns {boolean}
         */
        ;

        _proto.hasChildren = function hasChildren() {
          return this.element.hasChildNodes();
        };

        _proto.scrollToTop = function scrollToTop() {
          this.element.scrollTop = 0;
        }
        /**
         * @param {Element} element
         * @param {1 | -1} direction
         */
        ;

        _proto.scrollToChildElement = function scrollToChildElement(element, direction) {
          var _this = this;

          if (!element) {
            return;
          }

          var listHeight = this.element.offsetHeight; // Scroll position of dropdown

          var listScrollPosition = this.element.scrollTop + listHeight;
          var elementHeight = element.offsetHeight; // Distance from bottom of element to top of parent

          var elementPos = element.offsetTop + elementHeight; // Difference between the element and scroll position

          var destination = direction > 0 ? this.element.scrollTop + elementPos - listScrollPosition : element.offsetTop;
          requestAnimationFrame(function () {
            _this._animateScroll(destination, direction);
          });
        }
        /**
         * @param {number} scrollPos
         * @param {number} strength
         * @param {number} destination
         */
        ;

        _proto._scrollDown = function _scrollDown(scrollPos, strength, destination) {
          var easing = (destination - scrollPos) / strength;
          var distance = easing > 1 ? easing : 1;
          this.element.scrollTop = scrollPos + distance;
        }
        /**
         * @param {number} scrollPos
         * @param {number} strength
         * @param {number} destination
         */
        ;

        _proto._scrollUp = function _scrollUp(scrollPos, strength, destination) {
          var easing = (scrollPos - destination) / strength;
          var distance = easing > 1 ? easing : 1;
          this.element.scrollTop = scrollPos - distance;
        }
        /**
         * @param {*} destination
         * @param {*} direction
         */
        ;

        _proto._animateScroll = function _animateScroll(destination, direction) {
          var _this2 = this;

          var strength = SCROLLING_SPEED;
          var choiceListScrollTop = this.element.scrollTop;
          var continueAnimation = false;

          if (direction > 0) {
            this._scrollDown(choiceListScrollTop, strength, destination);

            if (choiceListScrollTop < destination) {
              continueAnimation = true;
            }
          } else {
            this._scrollUp(choiceListScrollTop, strength, destination);

            if (choiceListScrollTop > destination) {
              continueAnimation = true;
            }
          }

          if (continueAnimation) {
            requestAnimationFrame(function () {
              _this2._animateScroll(destination, direction);
            });
          }
        };

        return List;
      }(); // CONCATENATED MODULE: ./src/scripts/components/wrapped-element.js


      function wrapped_element_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function wrapped_element_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) wrapped_element_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) wrapped_element_defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /**
       * @typedef {import('../../../types/index').Choices.passedElement} passedElement
       * @typedef {import('../../../types/index').Choices.ClassNames} ClassNames
       */


      var wrapped_element_WrappedElement = /*#__PURE__*/function () {
        /**
         * @param {{
         *  element: HTMLInputElement | HTMLSelectElement,
         *  classNames: ClassNames,
         * }} args
         */
        function WrappedElement(_ref) {
          var element = _ref.element,
              classNames = _ref.classNames;
          this.element = element;
          this.classNames = classNames;

          if (!(element instanceof HTMLInputElement) && !(element instanceof HTMLSelectElement)) {
            throw new TypeError('Invalid element passed');
          }

          this.isDisabled = false;
        }

        var _proto = WrappedElement.prototype;

        _proto.conceal = function conceal() {
          // Hide passed input
          this.element.classList.add(this.classNames.input);
          this.element.hidden = true; // Remove element from tab index

          this.element.tabIndex = -1; // Backup original styles if any

          var origStyle = this.element.getAttribute('style');

          if (origStyle) {
            this.element.setAttribute('data-choice-orig-style', origStyle);
          }

          this.element.setAttribute('data-choice', 'active');
        };

        _proto.reveal = function reveal() {
          // Reinstate passed element
          this.element.classList.remove(this.classNames.input);
          this.element.hidden = false;
          this.element.removeAttribute('tabindex'); // Recover original styles if any

          var origStyle = this.element.getAttribute('data-choice-orig-style');

          if (origStyle) {
            this.element.removeAttribute('data-choice-orig-style');
            this.element.setAttribute('style', origStyle);
          } else {
            this.element.removeAttribute('style');
          }

          this.element.removeAttribute('data-choice'); // Re-assign values - this is weird, I know
          // @todo Figure out why we need to do this

          this.element.value = this.element.value; // eslint-disable-line no-self-assign
        };

        _proto.enable = function enable() {
          this.element.removeAttribute('disabled');
          this.element.disabled = false;
          this.isDisabled = false;
        };

        _proto.disable = function disable() {
          this.element.setAttribute('disabled', '');
          this.element.disabled = true;
          this.isDisabled = true;
        };

        _proto.triggerEvent = function triggerEvent(eventType, data) {
          dispatchEvent(this.element, eventType, data);
        };

        wrapped_element_createClass(WrappedElement, [{
          key: "isActive",
          get: function get() {
            return this.element.dataset.choice === 'active';
          }
        }, {
          key: "dir",
          get: function get() {
            return this.element.dir;
          }
        }, {
          key: "value",
          get: function get() {
            return this.element.value;
          },
          set: function set(value) {
            // you must define setter here otherwise it will be readonly property
            this.element.value = value;
          }
        }]);
        return WrappedElement;
      }(); // CONCATENATED MODULE: ./src/scripts/components/wrapped-input.js


      function wrapped_input_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function wrapped_input_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) wrapped_input_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) wrapped_input_defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function _inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @typedef {import('../../../types/index').Choices.ClassNames} ClassNames
       * @typedef {import('../../../types/index').Choices.Item} Item
       */


      var WrappedInput = /*#__PURE__*/function (_WrappedElement) {
        _inheritsLoose(WrappedInput, _WrappedElement);
        /**
         * @param {{
         *  element: HTMLInputElement,
         *  classNames: ClassNames,
         *  delimiter: string
         * }} args
         */


        function WrappedInput(_ref) {
          var _this;

          var element = _ref.element,
              classNames = _ref.classNames,
              delimiter = _ref.delimiter;
          _this = _WrappedElement.call(this, {
            element: element,
            classNames: classNames
          }) || this;
          _this.delimiter = delimiter;
          return _this;
        }
        /**
         * @returns {string}
         */


        wrapped_input_createClass(WrappedInput, [{
          key: "value",
          get: function get() {
            return this.element.value;
          }
          /**
           * @param {Item[]} items
           */
          ,
          set: function set(items) {
            var itemValues = items.map(function (_ref2) {
              var value = _ref2.value;
              return value;
            });
            var joinedValues = itemValues.join(this.delimiter);
            this.element.setAttribute('value', joinedValues);
            this.element.value = joinedValues;
          }
        }]);
        return WrappedInput;
      }(wrapped_element_WrappedElement); // CONCATENATED MODULE: ./src/scripts/components/wrapped-select.js


      function wrapped_select_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function wrapped_select_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) wrapped_select_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) wrapped_select_defineProperties(Constructor, staticProps);
        return Constructor;
      }

      function wrapped_select_inheritsLoose(subClass, superClass) {
        subClass.prototype = Object.create(superClass.prototype);
        subClass.prototype.constructor = subClass;
        subClass.__proto__ = superClass;
      }
      /**
       * @typedef {import('../../../types/index').Choices.ClassNames} ClassNames
       * @typedef {import('../../../types/index').Choices.Item} Item
       * @typedef {import('../../../types/index').Choices.Choice} Choice
       */


      var WrappedSelect = /*#__PURE__*/function (_WrappedElement) {
        wrapped_select_inheritsLoose(WrappedSelect, _WrappedElement);
        /**
         * @param {{
         *  element: HTMLSelectElement,
         *  classNames: ClassNames,
         *  delimiter: string
         *  template: function
         * }} args
         */

        function WrappedSelect(_ref) {
          var _this;

          var element = _ref.element,
              classNames = _ref.classNames,
              template = _ref.template;
          _this = _WrappedElement.call(this, {
            element: element,
            classNames: classNames
          }) || this;
          _this.template = template;
          return _this;
        }

        var _proto = WrappedSelect.prototype;
        /**
         * @param {DocumentFragment} fragment
         */

        _proto.appendDocFragment = function appendDocFragment(fragment) {
          this.element.innerHTML = '';
          this.element.appendChild(fragment);
        };

        wrapped_select_createClass(WrappedSelect, [{
          key: "placeholderOption",
          get: function get() {
            return this.element.querySelector('option[value=""]') || // Backward compatibility layer for the non-standard placeholder attribute supported in older versions.
            this.element.querySelector('option[placeholder]');
          }
          /**
           * @returns {Element[]}
           */

        }, {
          key: "optionGroups",
          get: function get() {
            return Array.from(this.element.getElementsByTagName('OPTGROUP'));
          }
          /**
           * @returns {Item[] | Choice[]}
           */

        }, {
          key: "options",
          get: function get() {
            return Array.from(this.element.options);
          }
          /**
           * @param {Item[] | Choice[]} options
           */
          ,
          set: function set(options) {
            var _this2 = this;

            var fragment = document.createDocumentFragment();

            var addOptionToFragment = function addOptionToFragment(data) {
              // Create a standard select option
              var option = _this2.template(data); // Append it to fragment


              fragment.appendChild(option);
            }; // Add each list item to list


            options.forEach(function (optionData) {
              return addOptionToFragment(optionData);
            });
            this.appendDocFragment(fragment);
          }
        }]);
        return WrappedSelect;
      }(wrapped_element_WrappedElement); // CONCATENATED MODULE: ./src/scripts/components/index.js
      // CONCATENATED MODULE: ./src/scripts/templates.js

      /**
       * Helpers to create HTML elements used by Choices
       * Can be overridden by providing `callbackOnCreateTemplates` option
       * @typedef {import('../../types/index').Choices.Templates} Templates
       * @typedef {import('../../types/index').Choices.ClassNames} ClassNames
       * @typedef {import('../../types/index').Choices.Options} Options
       * @typedef {import('../../types/index').Choices.Item} Item
       * @typedef {import('../../types/index').Choices.Choice} Choice
       * @typedef {import('../../types/index').Choices.Group} Group
       */


      var TEMPLATES =
      /** @type {Templates} */
      {
        /**
         * @param {Partial<ClassNames>} classNames
         * @param {"ltr" | "rtl" | "auto"} dir
         * @param {boolean} isSelectElement
         * @param {boolean} isSelectOneElement
         * @param {boolean} searchEnabled
         * @param {"select-one" | "select-multiple" | "text"} passedElementType
         */
        containerOuter: function containerOuter(_ref, dir, isSelectElement, isSelectOneElement, searchEnabled, passedElementType) {
          var _containerOuter = _ref.containerOuter;
          var div = Object.assign(document.createElement('div'), {
            className: _containerOuter
          });
          div.dataset.type = passedElementType;

          if (dir) {
            div.dir = dir;
          }

          if (isSelectOneElement) {
            div.tabIndex = 0;
          }

          if (isSelectElement) {
            div.setAttribute('role', searchEnabled ? 'combobox' : 'listbox');

            if (searchEnabled) {
              div.setAttribute('aria-autocomplete', 'list');
            }
          }

          div.setAttribute('aria-haspopup', 'true');
          div.setAttribute('aria-expanded', 'false');
          return div;
        },

        /**
         * @param {Partial<ClassNames>} classNames
         */
        containerInner: function containerInner(_ref2) {
          var _containerInner = _ref2.containerInner;
          return Object.assign(document.createElement('div'), {
            className: _containerInner
          });
        },

        /**
         * @param {Partial<ClassNames>} classNames
         * @param {boolean} isSelectOneElement
         */
        itemList: function itemList(_ref3, isSelectOneElement) {
          var list = _ref3.list,
              listSingle = _ref3.listSingle,
              listItems = _ref3.listItems;
          return Object.assign(document.createElement('div'), {
            className: list + " " + (isSelectOneElement ? listSingle : listItems)
          });
        },

        /**
         * @param {Partial<ClassNames>} classNames
         * @param {string} value
         */
        placeholder: function placeholder(_ref4, value) {
          var _placeholder = _ref4.placeholder;
          return Object.assign(document.createElement('div'), {
            className: _placeholder,
            innerHTML: value
          });
        },

        /**
         * @param {Partial<ClassNames>} classNames
         * @param {Item} item
         * @param {boolean} removeItemButton
         */
        item: function item(_ref5, _ref6, removeItemButton) {
          var _item = _ref5.item,
              button = _ref5.button,
              highlightedState = _ref5.highlightedState,
              itemSelectable = _ref5.itemSelectable,
              placeholder = _ref5.placeholder;
          var id = _ref6.id,
              value = _ref6.value,
              label = _ref6.label,
              customProperties = _ref6.customProperties,
              active = _ref6.active,
              disabled = _ref6.disabled,
              highlighted = _ref6.highlighted,
              isPlaceholder = _ref6.placeholder;
          var div = Object.assign(document.createElement('div'), {
            className: _item,
            innerHTML: label
          });
          Object.assign(div.dataset, {
            item: '',
            id: id,
            value: value,
            customProperties: customProperties
          });

          if (active) {
            div.setAttribute('aria-selected', 'true');
          }

          if (disabled) {
            div.setAttribute('aria-disabled', 'true');
          }

          if (isPlaceholder) {
            div.classList.add(placeholder);
          }

          div.classList.add(highlighted ? highlightedState : itemSelectable);

          if (removeItemButton) {
            if (disabled) {
              div.classList.remove(itemSelectable);
            }

            div.dataset.deletable = '';
            /** @todo This MUST be localizable, not hardcoded! */

            var REMOVE_ITEM_TEXT = 'Remove item';
            var removeButton = Object.assign(document.createElement('button'), {
              type: 'button',
              className: button,
              innerHTML: REMOVE_ITEM_TEXT
            });
            removeButton.setAttribute('aria-label', REMOVE_ITEM_TEXT + ": '" + value + "'");
            removeButton.dataset.button = '';
            div.appendChild(removeButton);
          }

          return div;
        },

        /**
         * @param {Partial<ClassNames>} classNames
         * @param {boolean} isSelectOneElement
         */
        choiceList: function choiceList(_ref7, isSelectOneElement) {
          var list = _ref7.list;
          var div = Object.assign(document.createElement('div'), {
            className: list
          });

          if (!isSelectOneElement) {
            div.setAttribute('aria-multiselectable', 'true');
          }

          div.setAttribute('role', 'listbox');
          return div;
        },

        /**
         * @param {Partial<ClassNames>} classNames
         * @param {Group} group
         */
        choiceGroup: function choiceGroup(_ref8, _ref9) {
          var group = _ref8.group,
              groupHeading = _ref8.groupHeading,
              itemDisabled = _ref8.itemDisabled;
          var id = _ref9.id,
              value = _ref9.value,
              disabled = _ref9.disabled;
          var div = Object.assign(document.createElement('div'), {
            className: group + " " + (disabled ? itemDisabled : '')
          });
          div.setAttribute('role', 'group');
          Object.assign(div.dataset, {
            group: '',
            id: id,
            value: value
          });

          if (disabled) {
            div.setAttribute('aria-disabled', 'true');
          }

          div.appendChild(Object.assign(document.createElement('div'), {
            className: groupHeading,
            innerHTML: value
          }));
          return div;
        },

        /**
         * @param {Partial<ClassNames>} classNames
         * @param {Choice} choice
         * @param {Options['itemSelectText']} selectText
         */
        choice: function choice(_ref10, _ref11, selectText) {
          var item = _ref10.item,
              itemChoice = _ref10.itemChoice,
              itemSelectable = _ref10.itemSelectable,
              selectedState = _ref10.selectedState,
              itemDisabled = _ref10.itemDisabled,
              placeholder = _ref10.placeholder;
          var id = _ref11.id,
              value = _ref11.value,
              label = _ref11.label,
              groupId = _ref11.groupId,
              elementId = _ref11.elementId,
              isDisabled = _ref11.disabled,
              isSelected = _ref11.selected,
              isPlaceholder = _ref11.placeholder;
          var div = Object.assign(document.createElement('div'), {
            id: elementId,
            innerHTML: label,
            className: item + " " + itemChoice
          });

          if (isSelected) {
            div.classList.add(selectedState);
          }

          if (isPlaceholder) {
            div.classList.add(placeholder);
          }

          div.setAttribute('role', groupId > 0 ? 'treeitem' : 'option');
          Object.assign(div.dataset, {
            choice: '',
            id: id,
            value: value,
            selectText: selectText
          });

          if (isDisabled) {
            div.classList.add(itemDisabled);
            div.dataset.choiceDisabled = '';
            div.setAttribute('aria-disabled', 'true');
          } else {
            div.classList.add(itemSelectable);
            div.dataset.choiceSelectable = '';
          }

          return div;
        },

        /**
         * @param {Partial<ClassNames>} classNames
         * @param {string} placeholderValue
         */
        input: function input(_ref12, placeholderValue) {
          var _input = _ref12.input,
              inputCloned = _ref12.inputCloned;
          var inp = Object.assign(document.createElement('input'), {
            type: 'text',
            className: _input + " " + inputCloned,
            autocomplete: 'off',
            autocapitalize: 'off',
            spellcheck: false
          });
          inp.setAttribute('role', 'textbox');
          inp.setAttribute('aria-autocomplete', 'list');
          inp.setAttribute('aria-label', placeholderValue);
          return inp;
        },

        /**
         * @param {Partial<ClassNames>} classNames
         */
        dropdown: function dropdown(_ref13) {
          var list = _ref13.list,
              listDropdown = _ref13.listDropdown;
          var div = document.createElement('div');
          div.classList.add(list, listDropdown);
          div.setAttribute('aria-expanded', 'false');
          return div;
        },

        /**
         *
         * @param {Partial<ClassNames>} classNames
         * @param {string} innerHTML
         * @param {"no-choices" | "no-results" | ""} type
         */
        notice: function notice(_ref14, innerHTML, type) {
          var item = _ref14.item,
              itemChoice = _ref14.itemChoice,
              noResults = _ref14.noResults,
              noChoices = _ref14.noChoices;

          if (type === void 0) {
            type = '';
          }

          var classes = [item, itemChoice];

          if (type === 'no-choices') {
            classes.push(noChoices);
          } else if (type === 'no-results') {
            classes.push(noResults);
          }

          return Object.assign(document.createElement('div'), {
            innerHTML: innerHTML,
            className: classes.join(' ')
          });
        },

        /**
         * @param {Item} option
         */
        option: function option(_ref15) {
          var label = _ref15.label,
              value = _ref15.value,
              customProperties = _ref15.customProperties,
              active = _ref15.active,
              disabled = _ref15.disabled;
          var opt = new Option(label, value, false, active);

          if (customProperties) {
            opt.dataset.customProperties = customProperties;
          }

          opt.disabled = disabled;
          return opt;
        }
      };
      /* harmony default export */

      var templates = TEMPLATES; // CONCATENATED MODULE: ./src/scripts/actions/choices.js

      /**
       * @typedef {import('redux').Action} Action
       * @typedef {import('../../../types/index').Choices.Choice} Choice
       */

      /**
       * @argument {Choice} choice
       * @returns {Action & Choice}
       */

      var choices_addChoice = function addChoice(_ref) {
        var value = _ref.value,
            label = _ref.label,
            id = _ref.id,
            groupId = _ref.groupId,
            disabled = _ref.disabled,
            elementId = _ref.elementId,
            customProperties = _ref.customProperties,
            placeholder = _ref.placeholder,
            keyCode = _ref.keyCode;
        return {
          type: ACTION_TYPES.ADD_CHOICE,
          value: value,
          label: label,
          id: id,
          groupId: groupId,
          disabled: disabled,
          elementId: elementId,
          customProperties: customProperties,
          placeholder: placeholder,
          keyCode: keyCode
        };
      };
      /**
       * @argument {Choice[]} results
       * @returns {Action & { results: Choice[] }}
       */


      var choices_filterChoices = function filterChoices(results) {
        return {
          type: ACTION_TYPES.FILTER_CHOICES,
          results: results
        };
      };
      /**
       * @argument {boolean} active
       * @returns {Action & { active: boolean }}
       */


      var choices_activateChoices = function activateChoices(active) {
        if (active === void 0) {
          active = true;
        }

        return {
          type: ACTION_TYPES.ACTIVATE_CHOICES,
          active: active
        };
      };
      /**
       * @returns {Action}
       */


      var choices_clearChoices = function clearChoices() {
        return {
          type: ACTION_TYPES.CLEAR_CHOICES
        };
      }; // CONCATENATED MODULE: ./src/scripts/actions/items.js

      /**
       * @typedef {import('redux').Action} Action
       * @typedef {import('../../../types/index').Choices.Item} Item
       */

      /**
       * @param {Item} item
       * @returns {Action & Item}
       */


      var items_addItem = function addItem(_ref) {
        var value = _ref.value,
            label = _ref.label,
            id = _ref.id,
            choiceId = _ref.choiceId,
            groupId = _ref.groupId,
            customProperties = _ref.customProperties,
            placeholder = _ref.placeholder,
            keyCode = _ref.keyCode;
        return {
          type: ACTION_TYPES.ADD_ITEM,
          value: value,
          label: label,
          id: id,
          choiceId: choiceId,
          groupId: groupId,
          customProperties: customProperties,
          placeholder: placeholder,
          keyCode: keyCode
        };
      };
      /**
       * @param {string} id
       * @param {string} choiceId
       * @returns {Action & { id: string, choiceId: string }}
       */


      var items_removeItem = function removeItem(id, choiceId) {
        return {
          type: ACTION_TYPES.REMOVE_ITEM,
          id: id,
          choiceId: choiceId
        };
      };
      /**
       * @param {string} id
       * @param {boolean} highlighted
       * @returns {Action & { id: string, highlighted: boolean }}
       */


      var items_highlightItem = function highlightItem(id, highlighted) {
        return {
          type: ACTION_TYPES.HIGHLIGHT_ITEM,
          id: id,
          highlighted: highlighted
        };
      }; // CONCATENATED MODULE: ./src/scripts/actions/groups.js

      /**
       * @typedef {import('redux').Action} Action
       * @typedef {import('../../../types/index').Choices.Group} Group
       */

      /**
       * @param {Group} group
       * @returns {Action & Group}
       */


      var groups_addGroup = function addGroup(_ref) {
        var value = _ref.value,
            id = _ref.id,
            active = _ref.active,
            disabled = _ref.disabled;
        return {
          type: ACTION_TYPES.ADD_GROUP,
          value: value,
          id: id,
          active: active,
          disabled: disabled
        };
      }; // CONCATENATED MODULE: ./src/scripts/actions/misc.js

      /**
       * @typedef {import('redux').Action} Action
       */

      /**
       * @returns {Action}
       */


      var clearAll = function clearAll() {
        return {
          type: 'CLEAR_ALL'
        };
      };
      /**
       * @param {any} state
       * @returns {Action & { state: object }}
       */


      var resetTo = function resetTo(state) {
        return {
          type: 'RESET_TO',
          state: state
        };
      };
      /**
       * @param {boolean} isLoading
       * @returns {Action & { isLoading: boolean }}
       */


      var setIsLoading = function setIsLoading(isLoading) {
        return {
          type: 'SET_IS_LOADING',
          isLoading: isLoading
        };
      }; // CONCATENATED MODULE: ./src/scripts/choices.js


      function choices_defineProperties(target, props) {
        for (var i = 0; i < props.length; i++) {
          var descriptor = props[i];
          descriptor.enumerable = descriptor.enumerable || false;
          descriptor.configurable = true;
          if ("value" in descriptor) descriptor.writable = true;
          Object.defineProperty(target, descriptor.key, descriptor);
        }
      }

      function choices_createClass(Constructor, protoProps, staticProps) {
        if (protoProps) choices_defineProperties(Constructor.prototype, protoProps);
        if (staticProps) choices_defineProperties(Constructor, staticProps);
        return Constructor;
      }
      /** @see {@link http://browserhacks.com/#hack-acea075d0ac6954f275a70023906050c} */


      var IS_IE11 = '-ms-scroll-limit' in document.documentElement.style && '-ms-ime-align' in document.documentElement.style;
      /**
       * @typedef {import('../../types/index').Choices.Choice} Choice
       * @typedef {import('../../types/index').Choices.Item} Item
       * @typedef {import('../../types/index').Choices.Group} Group
       * @typedef {import('../../types/index').Choices.Options} Options
       */

      /** @type {Partial<Options>} */

      var USER_DEFAULTS = {};
      /**
       * Choices
       * @author Josh Johnson<josh@joshuajohnson.co.uk>
       */

      var choices_Choices = /*#__PURE__*/function () {
        choices_createClass(Choices, null, [{
          key: "defaults",
          get: function get() {
            return Object.preventExtensions({
              get options() {
                return USER_DEFAULTS;
              },

              get templates() {
                return TEMPLATES;
              }

            });
          }
          /**
           * @param {string | HTMLInputElement | HTMLSelectElement} element
           * @param {Partial<Options>} userConfig
           */

        }]);

        function Choices(element, userConfig) {
          var _this = this;

          if (element === void 0) {
            element = '[data-choice]';
          }

          if (userConfig === void 0) {
            userConfig = {};
          }
          /** @type {Partial<Options>} */


          this.config = cjs_default.a.all([DEFAULT_CONFIG, Choices.defaults.options, userConfig], // When merging array configs, replace with a copy of the userConfig array,
          // instead of concatenating with the default array
          {
            arrayMerge: function arrayMerge(_, sourceArray) {
              return [].concat(sourceArray);
            }
          });
          var invalidConfigOptions = diff(this.config, DEFAULT_CONFIG);

          if (invalidConfigOptions.length) {
            console.warn('Unknown config option(s) passed', invalidConfigOptions.join(', '));
          }

          var passedElement = typeof element === 'string' ? document.querySelector(element) : element;

          if (!(passedElement instanceof HTMLInputElement || passedElement instanceof HTMLSelectElement)) {
            throw TypeError('Expected one of the following types text|select-one|select-multiple');
          }

          this._isTextElement = passedElement.type === TEXT_TYPE;
          this._isSelectOneElement = passedElement.type === SELECT_ONE_TYPE;
          this._isSelectMultipleElement = passedElement.type === SELECT_MULTIPLE_TYPE;
          this._isSelectElement = this._isSelectOneElement || this._isSelectMultipleElement;
          this.config.searchEnabled = this._isSelectMultipleElement || this.config.searchEnabled;

          if (!['auto', 'always'].includes(this.config.renderSelectedChoices)) {
            this.config.renderSelectedChoices = 'auto';
          }

          if (userConfig.addItemFilter && typeof userConfig.addItemFilter !== 'function') {
            var re = userConfig.addItemFilter instanceof RegExp ? userConfig.addItemFilter : new RegExp(userConfig.addItemFilter);
            this.config.addItemFilter = re.test.bind(re);
          }

          if (this._isTextElement) {
            this.passedElement = new WrappedInput({
              element: passedElement,
              classNames: this.config.classNames,
              delimiter: this.config.delimiter
            });
          } else {
            this.passedElement = new WrappedSelect({
              element: passedElement,
              classNames: this.config.classNames,
              template: function template(data) {
                return _this._templates.option(data);
              }
            });
          }

          this.initialised = false;
          this._store = new store_Store();
          this._initialState = {};
          this._currentState = {};
          this._prevState = {};
          this._currentValue = '';
          this._canSearch = this.config.searchEnabled;
          this._isScrollingOnIe = false;
          this._highlightPosition = 0;
          this._wasTap = true;
          this._placeholderValue = this._generatePlaceholderValue();
          this._baseId = generateId(this.passedElement.element, 'choices-');
          /**
           * setting direction in cases where it's explicitly set on passedElement
           * or when calculated direction is different from the document
           * @type {HTMLElement['dir']}
           */

          this._direction = this.passedElement.dir;

          if (!this._direction) {
            var _window$getComputedSt = window.getComputedStyle(this.passedElement.element),
                elementDirection = _window$getComputedSt.direction;

            var _window$getComputedSt2 = window.getComputedStyle(document.documentElement),
                documentDirection = _window$getComputedSt2.direction;

            if (elementDirection !== documentDirection) {
              this._direction = elementDirection;
            }
          }

          this._idNames = {
            itemChoice: 'item-choice'
          }; // Assign preset groups from passed element

          this._presetGroups = this.passedElement.optionGroups; // Assign preset options from passed element

          this._presetOptions = this.passedElement.options; // Assign preset choices from passed object

          this._presetChoices = this.config.choices; // Assign preset items from passed object first

          this._presetItems = this.config.items; // Add any values passed from attribute

          if (this.passedElement.value) {
            this._presetItems = this._presetItems.concat(this.passedElement.value.split(this.config.delimiter));
          } // Create array of choices from option elements


          if (this.passedElement.options) {
            this.passedElement.options.forEach(function (o) {
              _this._presetChoices.push({
                value: o.value,
                label: o.innerHTML,
                selected: o.selected,
                disabled: o.disabled || o.parentNode.disabled,
                placeholder: o.value === '' || o.hasAttribute('placeholder'),
                customProperties: o.getAttribute('data-custom-properties')
              });
            });
          }

          this._render = this._render.bind(this);
          this._onFocus = this._onFocus.bind(this);
          this._onBlur = this._onBlur.bind(this);
          this._onKeyUp = this._onKeyUp.bind(this);
          this._onKeyDown = this._onKeyDown.bind(this);
          this._onClick = this._onClick.bind(this);
          this._onTouchMove = this._onTouchMove.bind(this);
          this._onTouchEnd = this._onTouchEnd.bind(this);
          this._onMouseDown = this._onMouseDown.bind(this);
          this._onMouseOver = this._onMouseOver.bind(this);
          this._onFormReset = this._onFormReset.bind(this);
          this._onAKey = this._onAKey.bind(this);
          this._onEnterKey = this._onEnterKey.bind(this);
          this._onEscapeKey = this._onEscapeKey.bind(this);
          this._onDirectionKey = this._onDirectionKey.bind(this);
          this._onDeleteKey = this._onDeleteKey.bind(this); // If element has already been initialised with Choices, fail silently

          if (this.passedElement.isActive) {
            if (!this.config.silent) {
              console.warn('Trying to initialise Choices on element already initialised');
            }

            this.initialised = true;
            return;
          } // Let's go


          this.init();
        }

        var _proto = Choices.prototype;

        _proto.init = function init() {
          if (this.initialised) {
            return;
          }

          this._createTemplates();

          this._createElements();

          this._createStructure(); // Set initial state (We need to clone the state because some reducers
          // modify the inner objects properties in the state) 🤢


          this._initialState = cloneObject(this._store.state);

          this._store.subscribe(this._render);

          this._render();

          this._addEventListeners();

          var shouldDisable = !this.config.addItems || this.passedElement.element.hasAttribute('disabled');

          if (shouldDisable) {
            this.disable();
          }

          this.initialised = true;
          var callbackOnInit = this.config.callbackOnInit; // Run callback if it is a function

          if (callbackOnInit && typeof callbackOnInit === 'function') {
            callbackOnInit.call(this);
          }
        };

        _proto.destroy = function destroy() {
          if (!this.initialised) {
            return;
          }

          this._removeEventListeners();

          this.passedElement.reveal();
          this.containerOuter.unwrap(this.passedElement.element);
          this.clearStore();

          if (this._isSelectElement) {
            this.passedElement.options = this._presetOptions;
          }

          this._templates = null;
          this.initialised = false;
        };

        _proto.enable = function enable() {
          if (this.passedElement.isDisabled) {
            this.passedElement.enable();
          }

          if (this.containerOuter.isDisabled) {
            this._addEventListeners();

            this.input.enable();
            this.containerOuter.enable();
          }

          return this;
        };

        _proto.disable = function disable() {
          if (!this.passedElement.isDisabled) {
            this.passedElement.disable();
          }

          if (!this.containerOuter.isDisabled) {
            this._removeEventListeners();

            this.input.disable();
            this.containerOuter.disable();
          }

          return this;
        };

        _proto.highlightItem = function highlightItem(item, runEvent) {
          if (runEvent === void 0) {
            runEvent = true;
          }

          if (!item) {
            return this;
          }

          var id = item.id,
              _item$groupId = item.groupId,
              groupId = _item$groupId === void 0 ? -1 : _item$groupId,
              _item$value = item.value,
              value = _item$value === void 0 ? '' : _item$value,
              _item$label = item.label,
              label = _item$label === void 0 ? '' : _item$label;
          var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;

          this._store.dispatch(items_highlightItem(id, true));

          if (runEvent) {
            this.passedElement.triggerEvent(EVENTS.highlightItem, {
              id: id,
              value: value,
              label: label,
              groupValue: group && group.value ? group.value : null
            });
          }

          return this;
        };

        _proto.unhighlightItem = function unhighlightItem(item) {
          if (!item) {
            return this;
          }

          var id = item.id,
              _item$groupId2 = item.groupId,
              groupId = _item$groupId2 === void 0 ? -1 : _item$groupId2,
              _item$value2 = item.value,
              value = _item$value2 === void 0 ? '' : _item$value2,
              _item$label2 = item.label,
              label = _item$label2 === void 0 ? '' : _item$label2;
          var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;

          this._store.dispatch(items_highlightItem(id, false));

          this.passedElement.triggerEvent(EVENTS.highlightItem, {
            id: id,
            value: value,
            label: label,
            groupValue: group && group.value ? group.value : null
          });
          return this;
        };

        _proto.highlightAll = function highlightAll() {
          var _this2 = this;

          this._store.items.forEach(function (item) {
            return _this2.highlightItem(item);
          });

          return this;
        };

        _proto.unhighlightAll = function unhighlightAll() {
          var _this3 = this;

          this._store.items.forEach(function (item) {
            return _this3.unhighlightItem(item);
          });

          return this;
        };

        _proto.removeActiveItemsByValue = function removeActiveItemsByValue(value) {
          var _this4 = this;

          this._store.activeItems.filter(function (item) {
            return item.value === value;
          }).forEach(function (item) {
            return _this4._removeItem(item);
          });

          return this;
        };

        _proto.removeActiveItems = function removeActiveItems(excludedId) {
          var _this5 = this;

          this._store.activeItems.filter(function (_ref) {
            var id = _ref.id;
            return id !== excludedId;
          }).forEach(function (item) {
            return _this5._removeItem(item);
          });

          return this;
        };

        _proto.removeHighlightedItems = function removeHighlightedItems(runEvent) {
          var _this6 = this;

          if (runEvent === void 0) {
            runEvent = false;
          }

          this._store.highlightedActiveItems.forEach(function (item) {
            _this6._removeItem(item); // If this action was performed by the user
            // trigger the event


            if (runEvent) {
              _this6._triggerChange(item.value);
            }
          });

          return this;
        };

        _proto.showDropdown = function showDropdown(preventInputFocus) {
          var _this7 = this;

          if (this.dropdown.isActive) {
            return this;
          }

          requestAnimationFrame(function () {
            _this7.dropdown.show();

            _this7.containerOuter.open(_this7.dropdown.distanceFromTopWindow);

            if (!preventInputFocus && _this7._canSearch) {
              _this7.input.focus();
            }

            _this7.passedElement.triggerEvent(EVENTS.showDropdown, {});
          });
          return this;
        };

        _proto.hideDropdown = function hideDropdown(preventInputBlur) {
          var _this8 = this;

          if (!this.dropdown.isActive) {
            return this;
          }

          requestAnimationFrame(function () {
            _this8.dropdown.hide();

            _this8.containerOuter.close();

            if (!preventInputBlur && _this8._canSearch) {
              _this8.input.removeActiveDescendant();

              _this8.input.blur();
            }

            _this8.passedElement.triggerEvent(EVENTS.hideDropdown, {});
          });
          return this;
        };

        _proto.getValue = function getValue(valueOnly) {
          if (valueOnly === void 0) {
            valueOnly = false;
          }

          var values = this._store.activeItems.reduce(function (selectedItems, item) {
            var itemValue = valueOnly ? item.value : item;
            selectedItems.push(itemValue);
            return selectedItems;
          }, []);

          return this._isSelectOneElement ? values[0] : values;
        }
        /**
         * @param {string[] | import('../../types/index').Choices.Item[]} items
         */
        ;

        _proto.setValue = function setValue(items) {
          var _this9 = this;

          if (!this.initialised) {
            return this;
          }

          items.forEach(function (value) {
            return _this9._setChoiceOrItem(value);
          });
          return this;
        };

        _proto.setChoiceByValue = function setChoiceByValue(value) {
          var _this10 = this;

          if (!this.initialised || this._isTextElement) {
            return this;
          } // If only one value has been passed, convert to array


          var choiceValue = Array.isArray(value) ? value : [value]; // Loop through each value and

          choiceValue.forEach(function (val) {
            return _this10._findAndSelectChoiceByValue(val);
          });
          return this;
        }
        /**
         * Set choices of select input via an array of objects (or function that returns array of object or promise of it),
         * a value field name and a label field name.
         * This behaves the same as passing items via the choices option but can be called after initialising Choices.
         * This can also be used to add groups of choices (see example 2); Optionally pass a true `replaceChoices` value to remove any existing choices.
         * Optionally pass a `customProperties` object to add additional data to your choices (useful when searching/filtering etc).
         *
         * **Input types affected:** select-one, select-multiple
         *
         * @template {Choice[] | ((instance: Choices) => object[] | Promise<object[]>)} T
         * @param {T} [choicesArrayOrFetcher]
         * @param {string} [value = 'value'] - name of `value` field
         * @param {string} [label = 'label'] - name of 'label' field
         * @param {boolean} [replaceChoices = false] - whether to replace of add choices
         * @returns {this | Promise<this>}
         *
         * @example
         * ```js
         * const example = new Choices(element);
         *
         * example.setChoices([
         *   {value: 'One', label: 'Label One', disabled: true},
         *   {value: 'Two', label: 'Label Two', selected: true},
         *   {value: 'Three', label: 'Label Three'},
         * ], 'value', 'label', false);
         * ```
         *
         * @example
         * ```js
         * const example = new Choices(element);
         *
         * example.setChoices(async () => {
         *   try {
         *      const items = await fetch('/items');
         *      return items.json()
         *   } catch(err) {
         *      console.error(err)
         *   }
         * });
         * ```
         *
         * @example
         * ```js
         * const example = new Choices(element);
         *
         * example.setChoices([{
         *   label: 'Group one',
         *   id: 1,
         *   disabled: false,
         *   choices: [
         *     {value: 'Child One', label: 'Child One', selected: true},
         *     {value: 'Child Two', label: 'Child Two',  disabled: true},
         *     {value: 'Child Three', label: 'Child Three'},
         *   ]
         * },
         * {
         *   label: 'Group two',
         *   id: 2,
         *   disabled: false,
         *   choices: [
         *     {value: 'Child Four', label: 'Child Four', disabled: true},
         *     {value: 'Child Five', label: 'Child Five'},
         *     {value: 'Child Six', label: 'Child Six', customProperties: {
         *       description: 'Custom description about child six',
         *       random: 'Another random custom property'
         *     }},
         *   ]
         * }], 'value', 'label', false);
         * ```
         */
        ;

        _proto.setChoices = function setChoices(choicesArrayOrFetcher, value, label, replaceChoices) {
          var _this11 = this;

          if (choicesArrayOrFetcher === void 0) {
            choicesArrayOrFetcher = [];
          }

          if (value === void 0) {
            value = 'value';
          }

          if (label === void 0) {
            label = 'label';
          }

          if (replaceChoices === void 0) {
            replaceChoices = false;
          }

          if (!this.initialised) {
            throw new ReferenceError("setChoices was called on a non-initialized instance of Choices");
          }

          if (!this._isSelectElement) {
            throw new TypeError("setChoices can't be used with INPUT based Choices");
          }

          if (typeof value !== 'string' || !value) {
            throw new TypeError("value parameter must be a name of 'value' field in passed objects");
          } // Clear choices if needed


          if (replaceChoices) {
            this.clearChoices();
          }

          if (typeof choicesArrayOrFetcher === 'function') {
            // it's a choices fetcher function
            var fetcher = choicesArrayOrFetcher(this);

            if (typeof Promise === 'function' && fetcher instanceof Promise) {
              // that's a promise
              // eslint-disable-next-line compat/compat
              return new Promise(function (resolve) {
                return requestAnimationFrame(resolve);
              }).then(function () {
                return _this11._handleLoadingState(true);
              }).then(function () {
                return fetcher;
              }).then(function (data) {
                return _this11.setChoices(data, value, label, replaceChoices);
              }).catch(function (err) {
                if (!_this11.config.silent) {
                  console.error(err);
                }
              }).then(function () {
                return _this11._handleLoadingState(false);
              }).then(function () {
                return _this11;
              });
            } // function returned something else than promise, let's check if it's an array of choices


            if (!Array.isArray(fetcher)) {
              throw new TypeError(".setChoices first argument function must return either array of choices or Promise, got: " + typeof fetcher);
            } // recursion with results, it's sync and choices were cleared already


            return this.setChoices(fetcher, value, label, false);
          }

          if (!Array.isArray(choicesArrayOrFetcher)) {
            throw new TypeError(".setChoices must be called either with array of choices with a function resulting into Promise of array of choices");
          }

          this.containerOuter.removeLoadingState();

          this._startLoading();

          choicesArrayOrFetcher.forEach(function (groupOrChoice) {
            if (groupOrChoice.choices) {
              _this11._addGroup({
                id: parseInt(groupOrChoice.id, 10) || null,
                group: groupOrChoice,
                valueKey: value,
                labelKey: label
              });
            } else {
              _this11._addChoice({
                value: groupOrChoice[value],
                label: groupOrChoice[label],
                isSelected: groupOrChoice.selected,
                isDisabled: groupOrChoice.disabled,
                customProperties: groupOrChoice.customProperties,
                placeholder: groupOrChoice.placeholder
              });
            }
          });

          this._stopLoading();

          return this;
        };

        _proto.clearChoices = function clearChoices() {
          this._store.dispatch(choices_clearChoices());

          return this;
        };

        _proto.clearStore = function clearStore() {
          this._store.dispatch(clearAll());

          return this;
        };

        _proto.clearInput = function clearInput() {
          var shouldSetInputWidth = !this._isSelectOneElement;
          this.input.clear(shouldSetInputWidth);

          if (!this._isTextElement && this._canSearch) {
            this._isSearching = false;

            this._store.dispatch(choices_activateChoices(true));
          }

          return this;
        };

        _proto._render = function _render() {
          if (this._store.isLoading()) {
            return;
          }

          this._currentState = this._store.state;
          var stateChanged = this._currentState.choices !== this._prevState.choices || this._currentState.groups !== this._prevState.groups || this._currentState.items !== this._prevState.items;
          var shouldRenderChoices = this._isSelectElement;
          var shouldRenderItems = this._currentState.items !== this._prevState.items;

          if (!stateChanged) {
            return;
          }

          if (shouldRenderChoices) {
            this._renderChoices();
          }

          if (shouldRenderItems) {
            this._renderItems();
          }

          this._prevState = this._currentState;
        };

        _proto._renderChoices = function _renderChoices() {
          var _this12 = this;

          var _this$_store = this._store,
              activeGroups = _this$_store.activeGroups,
              activeChoices = _this$_store.activeChoices;
          var choiceListFragment = document.createDocumentFragment();
          this.choiceList.clear();

          if (this.config.resetScrollPosition) {
            requestAnimationFrame(function () {
              return _this12.choiceList.scrollToTop();
            });
          } // If we have grouped options


          if (activeGroups.length >= 1 && !this._isSearching) {
            // If we have a placeholder choice along with groups
            var activePlaceholders = activeChoices.filter(function (activeChoice) {
              return activeChoice.placeholder === true && activeChoice.groupId === -1;
            });

            if (activePlaceholders.length >= 1) {
              choiceListFragment = this._createChoicesFragment(activePlaceholders, choiceListFragment);
            }

            choiceListFragment = this._createGroupsFragment(activeGroups, activeChoices, choiceListFragment);
          } else if (activeChoices.length >= 1) {
            choiceListFragment = this._createChoicesFragment(activeChoices, choiceListFragment);
          } // If we have choices to show


          if (choiceListFragment.childNodes && choiceListFragment.childNodes.length > 0) {
            var activeItems = this._store.activeItems;

            var canAddItem = this._canAddItem(activeItems, this.input.value); // ...and we can select them


            if (canAddItem.response) {
              // ...append them and highlight the first choice
              this.choiceList.append(choiceListFragment);

              this._highlightChoice();
            } else {
              // ...otherwise show a notice
              this.choiceList.append(this._getTemplate('notice', canAddItem.notice));
            }
          } else {
            // Otherwise show a notice
            var dropdownItem;
            var notice;

            if (this._isSearching) {
              notice = typeof this.config.noResultsText === 'function' ? this.config.noResultsText() : this.config.noResultsText;
              dropdownItem = this._getTemplate('notice', notice, 'no-results');
            } else {
              notice = typeof this.config.noChoicesText === 'function' ? this.config.noChoicesText() : this.config.noChoicesText;
              dropdownItem = this._getTemplate('notice', notice, 'no-choices');
            }

            this.choiceList.append(dropdownItem);
          }
        };

        _proto._renderItems = function _renderItems() {
          var activeItems = this._store.activeItems || [];
          this.itemList.clear(); // Create a fragment to store our list items
          // (so we don't have to update the DOM for each item)

          var itemListFragment = this._createItemsFragment(activeItems); // If we have items to add, append them


          if (itemListFragment.childNodes) {
            this.itemList.append(itemListFragment);
          }
        };

        _proto._createGroupsFragment = function _createGroupsFragment(groups, choices, fragment) {
          var _this13 = this;

          if (fragment === void 0) {
            fragment = document.createDocumentFragment();
          }

          var getGroupChoices = function getGroupChoices(group) {
            return choices.filter(function (choice) {
              if (_this13._isSelectOneElement) {
                return choice.groupId === group.id;
              }

              return choice.groupId === group.id && (_this13.config.renderSelectedChoices === 'always' || !choice.selected);
            });
          }; // If sorting is enabled, filter groups


          if (this.config.shouldSort) {
            groups.sort(this.config.sorter);
          }

          groups.forEach(function (group) {
            var groupChoices = getGroupChoices(group);

            if (groupChoices.length >= 1) {
              var dropdownGroup = _this13._getTemplate('choiceGroup', group);

              fragment.appendChild(dropdownGroup);

              _this13._createChoicesFragment(groupChoices, fragment, true);
            }
          });
          return fragment;
        };

        _proto._createChoicesFragment = function _createChoicesFragment(choices, fragment, withinGroup) {
          var _this14 = this;

          if (fragment === void 0) {
            fragment = document.createDocumentFragment();
          }

          if (withinGroup === void 0) {
            withinGroup = false;
          } // Create a fragment to store our list items (so we don't have to update the DOM for each item)


          var _this$config = this.config,
              renderSelectedChoices = _this$config.renderSelectedChoices,
              searchResultLimit = _this$config.searchResultLimit,
              renderChoiceLimit = _this$config.renderChoiceLimit;
          var filter = this._isSearching ? sortByScore : this.config.sorter;

          var appendChoice = function appendChoice(choice) {
            var shouldRender = renderSelectedChoices === 'auto' ? _this14._isSelectOneElement || !choice.selected : true;

            if (shouldRender) {
              var dropdownItem = _this14._getTemplate('choice', choice, _this14.config.itemSelectText);

              fragment.appendChild(dropdownItem);
            }
          };

          var rendererableChoices = choices;

          if (renderSelectedChoices === 'auto' && !this._isSelectOneElement) {
            rendererableChoices = choices.filter(function (choice) {
              return !choice.selected;
            });
          } // Split array into placeholders and "normal" choices


          var _rendererableChoices$ = rendererableChoices.reduce(function (acc, choice) {
            if (choice.placeholder) {
              acc.placeholderChoices.push(choice);
            } else {
              acc.normalChoices.push(choice);
            }

            return acc;
          }, {
            placeholderChoices: [],
            normalChoices: []
          }),
              placeholderChoices = _rendererableChoices$.placeholderChoices,
              normalChoices = _rendererableChoices$.normalChoices; // If sorting is enabled or the user is searching, filter choices


          if (this.config.shouldSort || this._isSearching) {
            normalChoices.sort(filter);
          }

          var choiceLimit = rendererableChoices.length; // Prepend placeholeder

          var sortedChoices = this._isSelectOneElement ? [].concat(placeholderChoices, normalChoices) : normalChoices;

          if (this._isSearching) {
            choiceLimit = searchResultLimit;
          } else if (renderChoiceLimit && renderChoiceLimit > 0 && !withinGroup) {
            choiceLimit = renderChoiceLimit;
          } // Add each choice to dropdown within range


          for (var i = 0; i < choiceLimit; i += 1) {
            if (sortedChoices[i]) {
              appendChoice(sortedChoices[i]);
            }
          }

          return fragment;
        };

        _proto._createItemsFragment = function _createItemsFragment(items, fragment) {
          var _this15 = this;

          if (fragment === void 0) {
            fragment = document.createDocumentFragment();
          } // Create fragment to add elements to


          var _this$config2 = this.config,
              shouldSortItems = _this$config2.shouldSortItems,
              sorter = _this$config2.sorter,
              removeItemButton = _this$config2.removeItemButton; // If sorting is enabled, filter items

          if (shouldSortItems && !this._isSelectOneElement) {
            items.sort(sorter);
          }

          if (this._isTextElement) {
            // Update the value of the hidden input
            this.passedElement.value = items;
          } else {
            // Update the options of the hidden input
            this.passedElement.options = items;
          }

          var addItemToFragment = function addItemToFragment(item) {
            // Create new list element
            var listItem = _this15._getTemplate('item', item, removeItemButton); // Append it to list


            fragment.appendChild(listItem);
          }; // Add each list item to list


          items.forEach(addItemToFragment);
          return fragment;
        };

        _proto._triggerChange = function _triggerChange(value) {
          if (value === undefined || value === null) {
            return;
          }

          this.passedElement.triggerEvent(EVENTS.change, {
            value: value
          });
        };

        _proto._selectPlaceholderChoice = function _selectPlaceholderChoice() {
          var placeholderChoice = this._store.placeholderChoice;

          if (placeholderChoice) {
            this._addItem({
              value: placeholderChoice.value,
              label: placeholderChoice.label,
              choiceId: placeholderChoice.id,
              groupId: placeholderChoice.groupId,
              placeholder: placeholderChoice.placeholder
            });

            this._triggerChange(placeholderChoice.value);
          }
        };

        _proto._handleButtonAction = function _handleButtonAction(activeItems, element) {
          if (!activeItems || !element || !this.config.removeItems || !this.config.removeItemButton) {
            return;
          }

          var itemId = element.parentNode.getAttribute('data-id');
          var itemToRemove = activeItems.find(function (item) {
            return item.id === parseInt(itemId, 10);
          }); // Remove item associated with button

          this._removeItem(itemToRemove);

          this._triggerChange(itemToRemove.value);

          if (this._isSelectOneElement) {
            this._selectPlaceholderChoice();
          }
        };

        _proto._handleItemAction = function _handleItemAction(activeItems, element, hasShiftKey) {
          var _this16 = this;

          if (hasShiftKey === void 0) {
            hasShiftKey = false;
          }

          if (!activeItems || !element || !this.config.removeItems || this._isSelectOneElement) {
            return;
          }

          var passedId = element.getAttribute('data-id'); // We only want to select one item with a click
          // so we deselect any items that aren't the target
          // unless shift is being pressed

          activeItems.forEach(function (item) {
            if (item.id === parseInt(passedId, 10) && !item.highlighted) {
              _this16.highlightItem(item);
            } else if (!hasShiftKey && item.highlighted) {
              _this16.unhighlightItem(item);
            }
          }); // Focus input as without focus, a user cannot do anything with a
          // highlighted item

          this.input.focus();
        };

        _proto._handleChoiceAction = function _handleChoiceAction(activeItems, element) {
          if (!activeItems || !element) {
            return;
          } // If we are clicking on an option


          var id = element.dataset.id;

          var choice = this._store.getChoiceById(id);

          if (!choice) {
            return;
          }

          var passedKeyCode = activeItems[0] && activeItems[0].keyCode ? activeItems[0].keyCode : null;
          var hasActiveDropdown = this.dropdown.isActive; // Update choice keyCode

          choice.keyCode = passedKeyCode;
          this.passedElement.triggerEvent(EVENTS.choice, {
            choice: choice
          });

          if (!choice.selected && !choice.disabled) {
            var canAddItem = this._canAddItem(activeItems, choice.value);

            if (canAddItem.response) {
              this._addItem({
                value: choice.value,
                label: choice.label,
                choiceId: choice.id,
                groupId: choice.groupId,
                customProperties: choice.customProperties,
                placeholder: choice.placeholder,
                keyCode: choice.keyCode
              });

              this._triggerChange(choice.value);
            }
          }

          this.clearInput(); // We want to close the dropdown if we are dealing with a single select box

          if (hasActiveDropdown && this._isSelectOneElement) {
            this.hideDropdown(true);
            this.containerOuter.focus();
          }
        };

        _proto._handleBackspace = function _handleBackspace(activeItems) {
          if (!this.config.removeItems || !activeItems) {
            return;
          }

          var lastItem = activeItems[activeItems.length - 1];
          var hasHighlightedItems = activeItems.some(function (item) {
            return item.highlighted;
          }); // If editing the last item is allowed and there are not other selected items,
          // we can edit the item value. Otherwise if we can remove items, remove all selected items

          if (this.config.editItems && !hasHighlightedItems && lastItem) {
            this.input.value = lastItem.value;
            this.input.setWidth();

            this._removeItem(lastItem);

            this._triggerChange(lastItem.value);
          } else {
            if (!hasHighlightedItems) {
              // Highlight last item if none already highlighted
              this.highlightItem(lastItem, false);
            }

            this.removeHighlightedItems(true);
          }
        };

        _proto._startLoading = function _startLoading() {
          this._store.dispatch(setIsLoading(true));
        };

        _proto._stopLoading = function _stopLoading() {
          this._store.dispatch(setIsLoading(false));
        };

        _proto._handleLoadingState = function _handleLoadingState(setLoading) {
          if (setLoading === void 0) {
            setLoading = true;
          }

          var placeholderItem = this.itemList.getChild("." + this.config.classNames.placeholder);

          if (setLoading) {
            this.disable();
            this.containerOuter.addLoadingState();

            if (this._isSelectOneElement) {
              if (!placeholderItem) {
                placeholderItem = this._getTemplate('placeholder', this.config.loadingText);
                this.itemList.append(placeholderItem);
              } else {
                placeholderItem.innerHTML = this.config.loadingText;
              }
            } else {
              this.input.placeholder = this.config.loadingText;
            }
          } else {
            this.enable();
            this.containerOuter.removeLoadingState();

            if (this._isSelectOneElement) {
              placeholderItem.innerHTML = this._placeholderValue || '';
            } else {
              this.input.placeholder = this._placeholderValue || '';
            }
          }
        };

        _proto._handleSearch = function _handleSearch(value) {
          if (!value || !this.input.isFocussed) {
            return;
          }

          var choices = this._store.choices;
          var _this$config3 = this.config,
              searchFloor = _this$config3.searchFloor,
              searchChoices = _this$config3.searchChoices;
          var hasUnactiveChoices = choices.some(function (option) {
            return !option.active;
          }); // Check that we have a value to search and the input was an alphanumeric character

          if (value && value.length >= searchFloor) {
            var resultCount = searchChoices ? this._searchChoices(value) : 0; // Trigger search event

            this.passedElement.triggerEvent(EVENTS.search, {
              value: value,
              resultCount: resultCount
            });
          } else if (hasUnactiveChoices) {
            // Otherwise reset choices to active
            this._isSearching = false;

            this._store.dispatch(choices_activateChoices(true));
          }
        };

        _proto._canAddItem = function _canAddItem(activeItems, value) {
          var canAddItem = true;
          var notice = typeof this.config.addItemText === 'function' ? this.config.addItemText(value) : this.config.addItemText;

          if (!this._isSelectOneElement) {
            var isDuplicateValue = existsInArray(activeItems, value);

            if (this.config.maxItemCount > 0 && this.config.maxItemCount <= activeItems.length) {
              // If there is a max entry limit and we have reached that limit
              // don't update
              canAddItem = false;
              notice = typeof this.config.maxItemText === 'function' ? this.config.maxItemText(this.config.maxItemCount) : this.config.maxItemText;
            }

            if (!this.config.duplicateItemsAllowed && isDuplicateValue && canAddItem) {
              canAddItem = false;
              notice = typeof this.config.uniqueItemText === 'function' ? this.config.uniqueItemText(value) : this.config.uniqueItemText;
            }

            if (this._isTextElement && this.config.addItems && canAddItem && typeof this.config.addItemFilter === 'function' && !this.config.addItemFilter(value)) {
              canAddItem = false;
              notice = typeof this.config.customAddItemText === 'function' ? this.config.customAddItemText(value) : this.config.customAddItemText;
            }
          }

          return {
            response: canAddItem,
            notice: notice
          };
        };

        _proto._searchChoices = function _searchChoices(value) {
          var newValue = typeof value === 'string' ? value.trim() : value;
          var currentValue = typeof this._currentValue === 'string' ? this._currentValue.trim() : this._currentValue;

          if (newValue.length < 1 && newValue === currentValue + " ") {
            return 0;
          } // If new value matches the desired length and is not the same as the current value with a space


          var haystack = this._store.searchableChoices;
          var needle = newValue;
          var keys = [].concat(this.config.searchFields);
          var options = Object.assign(this.config.fuseOptions, {
            keys: keys
          });
          var fuse = new fuse_default.a(haystack, options);
          var results = fuse.search(needle);
          this._currentValue = newValue;
          this._highlightPosition = 0;
          this._isSearching = true;

          this._store.dispatch(choices_filterChoices(results));

          return results.length;
        };

        _proto._addEventListeners = function _addEventListeners() {
          var _document = document,
              documentElement = _document.documentElement; // capture events - can cancel event processing or propagation

          documentElement.addEventListener('touchend', this._onTouchEnd, true);
          this.containerOuter.element.addEventListener('keydown', this._onKeyDown, true);
          this.containerOuter.element.addEventListener('mousedown', this._onMouseDown, true); // passive events - doesn't call `preventDefault` or `stopPropagation`

          documentElement.addEventListener('click', this._onClick, {
            passive: true
          });
          documentElement.addEventListener('touchmove', this._onTouchMove, {
            passive: true
          });
          this.dropdown.element.addEventListener('mouseover', this._onMouseOver, {
            passive: true
          });

          if (this._isSelectOneElement) {
            this.containerOuter.element.addEventListener('focus', this._onFocus, {
              passive: true
            });
            this.containerOuter.element.addEventListener('blur', this._onBlur, {
              passive: true
            });
          }

          this.input.element.addEventListener('keyup', this._onKeyUp, {
            passive: true
          });
          this.input.element.addEventListener('focus', this._onFocus, {
            passive: true
          });
          this.input.element.addEventListener('blur', this._onBlur, {
            passive: true
          });

          if (this.input.element.form) {
            this.input.element.form.addEventListener('reset', this._onFormReset, {
              passive: true
            });
          }

          this.input.addEventListeners();
        };

        _proto._removeEventListeners = function _removeEventListeners() {
          var _document2 = document,
              documentElement = _document2.documentElement;
          documentElement.removeEventListener('touchend', this._onTouchEnd, true);
          this.containerOuter.element.removeEventListener('keydown', this._onKeyDown, true);
          this.containerOuter.element.removeEventListener('mousedown', this._onMouseDown, true);
          documentElement.removeEventListener('click', this._onClick);
          documentElement.removeEventListener('touchmove', this._onTouchMove);
          this.dropdown.element.removeEventListener('mouseover', this._onMouseOver);

          if (this._isSelectOneElement) {
            this.containerOuter.element.removeEventListener('focus', this._onFocus);
            this.containerOuter.element.removeEventListener('blur', this._onBlur);
          }

          this.input.element.removeEventListener('keyup', this._onKeyUp);
          this.input.element.removeEventListener('focus', this._onFocus);
          this.input.element.removeEventListener('blur', this._onBlur);

          if (this.input.element.form) {
            this.input.element.form.removeEventListener('reset', this._onFormReset);
          }

          this.input.removeEventListeners();
        }
        /**
         * @param {KeyboardEvent} event
         */
        ;

        _proto._onKeyDown = function _onKeyDown(event) {
          var _keyDownActions;

          var target = event.target,
              keyCode = event.keyCode,
              ctrlKey = event.ctrlKey,
              metaKey = event.metaKey;
          var activeItems = this._store.activeItems;
          var hasFocusedInput = this.input.isFocussed;
          var hasActiveDropdown = this.dropdown.isActive;
          var hasItems = this.itemList.hasChildren();
          var keyString = String.fromCharCode(keyCode);
          var BACK_KEY = KEY_CODES.BACK_KEY,
              DELETE_KEY = KEY_CODES.DELETE_KEY,
              ENTER_KEY = KEY_CODES.ENTER_KEY,
              A_KEY = KEY_CODES.A_KEY,
              ESC_KEY = KEY_CODES.ESC_KEY,
              UP_KEY = KEY_CODES.UP_KEY,
              DOWN_KEY = KEY_CODES.DOWN_KEY,
              PAGE_UP_KEY = KEY_CODES.PAGE_UP_KEY,
              PAGE_DOWN_KEY = KEY_CODES.PAGE_DOWN_KEY;
          var hasCtrlDownKeyPressed = ctrlKey || metaKey; // If a user is typing and the dropdown is not active

          if (!this._isTextElement && /[a-zA-Z0-9-_ ]/.test(keyString)) {
            this.showDropdown();
          } // Map keys to key actions


          var keyDownActions = (_keyDownActions = {}, _keyDownActions[A_KEY] = this._onAKey, _keyDownActions[ENTER_KEY] = this._onEnterKey, _keyDownActions[ESC_KEY] = this._onEscapeKey, _keyDownActions[UP_KEY] = this._onDirectionKey, _keyDownActions[PAGE_UP_KEY] = this._onDirectionKey, _keyDownActions[DOWN_KEY] = this._onDirectionKey, _keyDownActions[PAGE_DOWN_KEY] = this._onDirectionKey, _keyDownActions[DELETE_KEY] = this._onDeleteKey, _keyDownActions[BACK_KEY] = this._onDeleteKey, _keyDownActions); // If keycode has a function, run it

          if (keyDownActions[keyCode]) {
            keyDownActions[keyCode]({
              event: event,
              target: target,
              keyCode: keyCode,
              metaKey: metaKey,
              activeItems: activeItems,
              hasFocusedInput: hasFocusedInput,
              hasActiveDropdown: hasActiveDropdown,
              hasItems: hasItems,
              hasCtrlDownKeyPressed: hasCtrlDownKeyPressed
            });
          }
        };

        _proto._onKeyUp = function _onKeyUp(_ref2) {
          var target = _ref2.target,
              keyCode = _ref2.keyCode;
          var value = this.input.value;
          var activeItems = this._store.activeItems;

          var canAddItem = this._canAddItem(activeItems, value);

          var backKey = KEY_CODES.BACK_KEY,
              deleteKey = KEY_CODES.DELETE_KEY; // We are typing into a text input and have a value, we want to show a dropdown
          // notice. Otherwise hide the dropdown

          if (this._isTextElement) {
            var canShowDropdownNotice = canAddItem.notice && value;

            if (canShowDropdownNotice) {
              var dropdownItem = this._getTemplate('notice', canAddItem.notice);

              this.dropdown.element.innerHTML = dropdownItem.outerHTML;
              this.showDropdown(true);
            } else {
              this.hideDropdown(true);
            }
          } else {
            var userHasRemovedValue = (keyCode === backKey || keyCode === deleteKey) && !target.value;
            var canReactivateChoices = !this._isTextElement && this._isSearching;
            var canSearch = this._canSearch && canAddItem.response;

            if (userHasRemovedValue && canReactivateChoices) {
              this._isSearching = false;

              this._store.dispatch(choices_activateChoices(true));
            } else if (canSearch) {
              this._handleSearch(this.input.value);
            }
          }

          this._canSearch = this.config.searchEnabled;
        };

        _proto._onAKey = function _onAKey(_ref3) {
          var hasItems = _ref3.hasItems,
              hasCtrlDownKeyPressed = _ref3.hasCtrlDownKeyPressed; // If CTRL + A or CMD + A have been pressed and there are items to select

          if (hasCtrlDownKeyPressed && hasItems) {
            this._canSearch = false;
            var shouldHightlightAll = this.config.removeItems && !this.input.value && this.input.element === document.activeElement;

            if (shouldHightlightAll) {
              this.highlightAll();
            }
          }
        };

        _proto._onEnterKey = function _onEnterKey(_ref4) {
          var event = _ref4.event,
              target = _ref4.target,
              activeItems = _ref4.activeItems,
              hasActiveDropdown = _ref4.hasActiveDropdown;
          var enterKey = KEY_CODES.ENTER_KEY;
          var targetWasButton = target.hasAttribute('data-button');

          if (this._isTextElement && target.value) {
            var value = this.input.value;

            var canAddItem = this._canAddItem(activeItems, value);

            if (canAddItem.response) {
              this.hideDropdown(true);

              this._addItem({
                value: value
              });

              this._triggerChange(value);

              this.clearInput();
            }
          }

          if (targetWasButton) {
            this._handleButtonAction(activeItems, target);

            event.preventDefault();
          }

          if (hasActiveDropdown) {
            var highlightedChoice = this.dropdown.getChild("." + this.config.classNames.highlightedState);

            if (highlightedChoice) {
              // add enter keyCode value
              if (activeItems[0]) {
                activeItems[0].keyCode = enterKey; // eslint-disable-line no-param-reassign
              }

              this._handleChoiceAction(activeItems, highlightedChoice);
            }

            event.preventDefault();
          } else if (this._isSelectOneElement) {
            this.showDropdown();
            event.preventDefault();
          }
        };

        _proto._onEscapeKey = function _onEscapeKey(_ref5) {
          var hasActiveDropdown = _ref5.hasActiveDropdown;

          if (hasActiveDropdown) {
            this.hideDropdown(true);
            this.containerOuter.focus();
          }
        };

        _proto._onDirectionKey = function _onDirectionKey(_ref6) {
          var event = _ref6.event,
              hasActiveDropdown = _ref6.hasActiveDropdown,
              keyCode = _ref6.keyCode,
              metaKey = _ref6.metaKey;
          var downKey = KEY_CODES.DOWN_KEY,
              pageUpKey = KEY_CODES.PAGE_UP_KEY,
              pageDownKey = KEY_CODES.PAGE_DOWN_KEY; // If up or down key is pressed, traverse through options

          if (hasActiveDropdown || this._isSelectOneElement) {
            this.showDropdown();
            this._canSearch = false;
            var directionInt = keyCode === downKey || keyCode === pageDownKey ? 1 : -1;
            var skipKey = metaKey || keyCode === pageDownKey || keyCode === pageUpKey;
            var selectableChoiceIdentifier = '[data-choice-selectable]';
            var nextEl;

            if (skipKey) {
              if (directionInt > 0) {
                nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier + ":last-of-type");
              } else {
                nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
              }
            } else {
              var currentEl = this.dropdown.element.querySelector("." + this.config.classNames.highlightedState);

              if (currentEl) {
                nextEl = getAdjacentEl(currentEl, selectableChoiceIdentifier, directionInt);
              } else {
                nextEl = this.dropdown.element.querySelector(selectableChoiceIdentifier);
              }
            }

            if (nextEl) {
              // We prevent default to stop the cursor moving
              // when pressing the arrow
              if (!isScrolledIntoView(nextEl, this.choiceList.element, directionInt)) {
                this.choiceList.scrollToChildElement(nextEl, directionInt);
              }

              this._highlightChoice(nextEl);
            } // Prevent default to maintain cursor position whilst
            // traversing dropdown options


            event.preventDefault();
          }
        };

        _proto._onDeleteKey = function _onDeleteKey(_ref7) {
          var event = _ref7.event,
              target = _ref7.target,
              hasFocusedInput = _ref7.hasFocusedInput,
              activeItems = _ref7.activeItems; // If backspace or delete key is pressed and the input has no value

          if (hasFocusedInput && !target.value && !this._isSelectOneElement) {
            this._handleBackspace(activeItems);

            event.preventDefault();
          }
        };

        _proto._onTouchMove = function _onTouchMove() {
          if (this._wasTap) {
            this._wasTap = false;
          }
        };

        _proto._onTouchEnd = function _onTouchEnd(event) {
          var _ref8 = event || event.touches[0],
              target = _ref8.target;

          var touchWasWithinContainer = this._wasTap && this.containerOuter.element.contains(target);

          if (touchWasWithinContainer) {
            var containerWasExactTarget = target === this.containerOuter.element || target === this.containerInner.element;

            if (containerWasExactTarget) {
              if (this._isTextElement) {
                this.input.focus();
              } else if (this._isSelectMultipleElement) {
                this.showDropdown();
              }
            } // Prevents focus event firing


            event.stopPropagation();
          }

          this._wasTap = true;
        }
        /**
         * Handles mousedown event in capture mode for containetOuter.element
         * @param {MouseEvent} event
         */
        ;

        _proto._onMouseDown = function _onMouseDown(event) {
          var target = event.target;

          if (!(target instanceof HTMLElement)) {
            return;
          } // If we have our mouse down on the scrollbar and are on IE11...


          if (IS_IE11 && this.choiceList.element.contains(target)) {
            // check if click was on a scrollbar area
            var firstChoice =
            /** @type {HTMLElement} */
            this.choiceList.element.firstElementChild;
            var isOnScrollbar = this._direction === 'ltr' ? event.offsetX >= firstChoice.offsetWidth : event.offsetX < firstChoice.offsetLeft;
            this._isScrollingOnIe = isOnScrollbar;
          }

          if (target === this.input.element) {
            return;
          }

          var item = target.closest('[data-button],[data-item],[data-choice]');

          if (item instanceof HTMLElement) {
            var hasShiftKey = event.shiftKey;
            var activeItems = this._store.activeItems;
            var dataset = item.dataset;

            if ('button' in dataset) {
              this._handleButtonAction(activeItems, item);
            } else if ('item' in dataset) {
              this._handleItemAction(activeItems, item, hasShiftKey);
            } else if ('choice' in dataset) {
              this._handleChoiceAction(activeItems, item);
            }
          }

          event.preventDefault();
        }
        /**
         * Handles mouseover event over this.dropdown
         * @param {MouseEvent} event
         */
        ;

        _proto._onMouseOver = function _onMouseOver(_ref9) {
          var target = _ref9.target;

          if (target instanceof HTMLElement && 'choice' in target.dataset) {
            this._highlightChoice(target);
          }
        };

        _proto._onClick = function _onClick(_ref10) {
          var target = _ref10.target;
          var clickWasWithinContainer = this.containerOuter.element.contains(target);

          if (clickWasWithinContainer) {
            if (!this.dropdown.isActive && !this.containerOuter.isDisabled) {
              if (this._isTextElement) {
                if (document.activeElement !== this.input.element) {
                  this.input.focus();
                }
              } else {
                this.showDropdown();
                this.containerOuter.focus();
              }
            } else if (this._isSelectOneElement && target !== this.input.element && !this.dropdown.element.contains(target)) {
              this.hideDropdown();
            }
          } else {
            var hasHighlightedItems = this._store.highlightedActiveItems.length > 0;

            if (hasHighlightedItems) {
              this.unhighlightAll();
            }

            this.containerOuter.removeFocusState();
            this.hideDropdown(true);
          }
        };

        _proto._onFocus = function _onFocus(_ref11) {
          var _this17 = this,
              _focusActions;

          var target = _ref11.target;
          var focusWasWithinContainer = this.containerOuter.element.contains(target);

          if (!focusWasWithinContainer) {
            return;
          }

          var focusActions = (_focusActions = {}, _focusActions[TEXT_TYPE] = function () {
            if (target === _this17.input.element) {
              _this17.containerOuter.addFocusState();
            }
          }, _focusActions[SELECT_ONE_TYPE] = function () {
            _this17.containerOuter.addFocusState();

            if (target === _this17.input.element) {
              _this17.showDropdown(true);
            }
          }, _focusActions[SELECT_MULTIPLE_TYPE] = function () {
            if (target === _this17.input.element) {
              _this17.showDropdown(true); // If element is a select box, the focused element is the container and the dropdown
              // isn't already open, focus and show dropdown


              _this17.containerOuter.addFocusState();
            }
          }, _focusActions);
          focusActions[this.passedElement.element.type]();
        };

        _proto._onBlur = function _onBlur(_ref12) {
          var _this18 = this;

          var target = _ref12.target;
          var blurWasWithinContainer = this.containerOuter.element.contains(target);

          if (blurWasWithinContainer && !this._isScrollingOnIe) {
            var _blurActions;

            var activeItems = this._store.activeItems;
            var hasHighlightedItems = activeItems.some(function (item) {
              return item.highlighted;
            });
            var blurActions = (_blurActions = {}, _blurActions[TEXT_TYPE] = function () {
              if (target === _this18.input.element) {
                _this18.containerOuter.removeFocusState();

                if (hasHighlightedItems) {
                  _this18.unhighlightAll();
                }

                _this18.hideDropdown(true);
              }
            }, _blurActions[SELECT_ONE_TYPE] = function () {
              _this18.containerOuter.removeFocusState();

              if (target === _this18.input.element || target === _this18.containerOuter.element && !_this18._canSearch) {
                _this18.hideDropdown(true);
              }
            }, _blurActions[SELECT_MULTIPLE_TYPE] = function () {
              if (target === _this18.input.element) {
                _this18.containerOuter.removeFocusState();

                _this18.hideDropdown(true);

                if (hasHighlightedItems) {
                  _this18.unhighlightAll();
                }
              }
            }, _blurActions);
            blurActions[this.passedElement.element.type]();
          } else {
            // On IE11, clicking the scollbar blurs our input and thus
            // closes the dropdown. To stop this, we refocus our input
            // if we know we are on IE *and* are scrolling.
            this._isScrollingOnIe = false;
            this.input.element.focus();
          }
        };

        _proto._onFormReset = function _onFormReset() {
          this._store.dispatch(resetTo(this._initialState));
        };

        _proto._highlightChoice = function _highlightChoice(el) {
          var _this19 = this;

          if (el === void 0) {
            el = null;
          }

          var choices = Array.from(this.dropdown.element.querySelectorAll('[data-choice-selectable]'));

          if (!choices.length) {
            return;
          }

          var passedEl = el;
          var highlightedChoices = Array.from(this.dropdown.element.querySelectorAll("." + this.config.classNames.highlightedState)); // Remove any highlighted choices

          highlightedChoices.forEach(function (choice) {
            choice.classList.remove(_this19.config.classNames.highlightedState);
            choice.setAttribute('aria-selected', 'false');
          });

          if (passedEl) {
            this._highlightPosition = choices.indexOf(passedEl);
          } else {
            // Highlight choice based on last known highlight location
            if (choices.length > this._highlightPosition) {
              // If we have an option to highlight
              passedEl = choices[this._highlightPosition];
            } else {
              // Otherwise highlight the option before
              passedEl = choices[choices.length - 1];
            }

            if (!passedEl) {
              passedEl = choices[0];
            }
          }

          passedEl.classList.add(this.config.classNames.highlightedState);
          passedEl.setAttribute('aria-selected', 'true');
          this.passedElement.triggerEvent(EVENTS.highlightChoice, {
            el: passedEl
          });

          if (this.dropdown.isActive) {
            // IE11 ignores aria-label and blocks virtual keyboard
            // if aria-activedescendant is set without a dropdown
            this.input.setActiveDescendant(passedEl.id);
            this.containerOuter.setActiveDescendant(passedEl.id);
          }
        };

        _proto._addItem = function _addItem(_ref13) {
          var value = _ref13.value,
              _ref13$label = _ref13.label,
              label = _ref13$label === void 0 ? null : _ref13$label,
              _ref13$choiceId = _ref13.choiceId,
              choiceId = _ref13$choiceId === void 0 ? -1 : _ref13$choiceId,
              _ref13$groupId = _ref13.groupId,
              groupId = _ref13$groupId === void 0 ? -1 : _ref13$groupId,
              _ref13$customProperti = _ref13.customProperties,
              customProperties = _ref13$customProperti === void 0 ? null : _ref13$customProperti,
              _ref13$placeholder = _ref13.placeholder,
              placeholder = _ref13$placeholder === void 0 ? false : _ref13$placeholder,
              _ref13$keyCode = _ref13.keyCode,
              keyCode = _ref13$keyCode === void 0 ? null : _ref13$keyCode;
          var passedValue = typeof value === 'string' ? value.trim() : value;
          var passedKeyCode = keyCode;
          var passedCustomProperties = customProperties;
          var items = this._store.items;
          var passedLabel = label || passedValue;
          var passedOptionId = choiceId || -1;
          var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;
          var id = items ? items.length + 1 : 1; // If a prepended value has been passed, prepend it

          if (this.config.prependValue) {
            passedValue = this.config.prependValue + passedValue.toString();
          } // If an appended value has been passed, append it


          if (this.config.appendValue) {
            passedValue += this.config.appendValue.toString();
          }

          this._store.dispatch(items_addItem({
            value: passedValue,
            label: passedLabel,
            id: id,
            choiceId: passedOptionId,
            groupId: groupId,
            customProperties: customProperties,
            placeholder: placeholder,
            keyCode: passedKeyCode
          }));

          if (this._isSelectOneElement) {
            this.removeActiveItems(id);
          } // Trigger change event


          this.passedElement.triggerEvent(EVENTS.addItem, {
            id: id,
            value: passedValue,
            label: passedLabel,
            customProperties: passedCustomProperties,
            groupValue: group && group.value ? group.value : undefined,
            keyCode: passedKeyCode
          });
          return this;
        };

        _proto._removeItem = function _removeItem(item) {
          if (!item || !isType('Object', item)) {
            return this;
          }

          var id = item.id,
              value = item.value,
              label = item.label,
              choiceId = item.choiceId,
              groupId = item.groupId;
          var group = groupId >= 0 ? this._store.getGroupById(groupId) : null;

          this._store.dispatch(items_removeItem(id, choiceId));

          if (group && group.value) {
            this.passedElement.triggerEvent(EVENTS.removeItem, {
              id: id,
              value: value,
              label: label,
              groupValue: group.value
            });
          } else {
            this.passedElement.triggerEvent(EVENTS.removeItem, {
              id: id,
              value: value,
              label: label
            });
          }

          return this;
        };

        _proto._addChoice = function _addChoice(_ref14) {
          var value = _ref14.value,
              _ref14$label = _ref14.label,
              label = _ref14$label === void 0 ? null : _ref14$label,
              _ref14$isSelected = _ref14.isSelected,
              isSelected = _ref14$isSelected === void 0 ? false : _ref14$isSelected,
              _ref14$isDisabled = _ref14.isDisabled,
              isDisabled = _ref14$isDisabled === void 0 ? false : _ref14$isDisabled,
              _ref14$groupId = _ref14.groupId,
              groupId = _ref14$groupId === void 0 ? -1 : _ref14$groupId,
              _ref14$customProperti = _ref14.customProperties,
              customProperties = _ref14$customProperti === void 0 ? null : _ref14$customProperti,
              _ref14$placeholder = _ref14.placeholder,
              placeholder = _ref14$placeholder === void 0 ? false : _ref14$placeholder,
              _ref14$keyCode = _ref14.keyCode,
              keyCode = _ref14$keyCode === void 0 ? null : _ref14$keyCode;

          if (typeof value === 'undefined' || value === null) {
            return;
          } // Generate unique id


          var choices = this._store.choices;
          var choiceLabel = label || value;
          var choiceId = choices ? choices.length + 1 : 1;
          var choiceElementId = this._baseId + "-" + this._idNames.itemChoice + "-" + choiceId;

          this._store.dispatch(choices_addChoice({
            id: choiceId,
            groupId: groupId,
            elementId: choiceElementId,
            value: value,
            label: choiceLabel,
            disabled: isDisabled,
            customProperties: customProperties,
            placeholder: placeholder,
            keyCode: keyCode
          }));

          if (isSelected) {
            this._addItem({
              value: value,
              label: choiceLabel,
              choiceId: choiceId,
              customProperties: customProperties,
              placeholder: placeholder,
              keyCode: keyCode
            });
          }
        };

        _proto._addGroup = function _addGroup(_ref15) {
          var _this20 = this;

          var group = _ref15.group,
              id = _ref15.id,
              _ref15$valueKey = _ref15.valueKey,
              valueKey = _ref15$valueKey === void 0 ? 'value' : _ref15$valueKey,
              _ref15$labelKey = _ref15.labelKey,
              labelKey = _ref15$labelKey === void 0 ? 'label' : _ref15$labelKey;
          var groupChoices = isType('Object', group) ? group.choices : Array.from(group.getElementsByTagName('OPTION'));
          var groupId = id || Math.floor(new Date().valueOf() * Math.random());
          var isDisabled = group.disabled ? group.disabled : false;

          if (groupChoices) {
            this._store.dispatch(groups_addGroup({
              value: group.label,
              id: groupId,
              active: true,
              disabled: isDisabled
            }));

            var addGroupChoices = function addGroupChoices(choice) {
              var isOptDisabled = choice.disabled || choice.parentNode && choice.parentNode.disabled;

              _this20._addChoice({
                value: choice[valueKey],
                label: isType('Object', choice) ? choice[labelKey] : choice.innerHTML,
                isSelected: choice.selected,
                isDisabled: isOptDisabled,
                groupId: groupId,
                customProperties: choice.customProperties,
                placeholder: choice.placeholder
              });
            };

            groupChoices.forEach(addGroupChoices);
          } else {
            this._store.dispatch(groups_addGroup({
              value: group.label,
              id: group.id,
              active: false,
              disabled: group.disabled
            }));
          }
        };

        _proto._getTemplate = function _getTemplate(template) {
          var _this$_templates$temp;

          if (!template) {
            return null;
          }

          var classNames = this.config.classNames;

          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return (_this$_templates$temp = this._templates[template]).call.apply(_this$_templates$temp, [this, classNames].concat(args));
        };

        _proto._createTemplates = function _createTemplates() {
          var callbackOnCreateTemplates = this.config.callbackOnCreateTemplates;
          var userTemplates = {};

          if (callbackOnCreateTemplates && typeof callbackOnCreateTemplates === 'function') {
            userTemplates = callbackOnCreateTemplates.call(this, strToEl);
          }

          this._templates = cjs_default()(TEMPLATES, userTemplates);
        };

        _proto._createElements = function _createElements() {
          this.containerOuter = new container_Container({
            element: this._getTemplate('containerOuter', this._direction, this._isSelectElement, this._isSelectOneElement, this.config.searchEnabled, this.passedElement.element.type),
            classNames: this.config.classNames,
            type: this.passedElement.element.type,
            position: this.config.position
          });
          this.containerInner = new container_Container({
            element: this._getTemplate('containerInner'),
            classNames: this.config.classNames,
            type: this.passedElement.element.type,
            position: this.config.position
          });
          this.input = new input_Input({
            element: this._getTemplate('input', this._placeholderValue),
            classNames: this.config.classNames,
            type: this.passedElement.element.type,
            preventPaste: !this.config.paste
          });
          this.choiceList = new list_List({
            element: this._getTemplate('choiceList', this._isSelectOneElement)
          });
          this.itemList = new list_List({
            element: this._getTemplate('itemList', this._isSelectOneElement)
          });
          this.dropdown = new Dropdown({
            element: this._getTemplate('dropdown'),
            classNames: this.config.classNames,
            type: this.passedElement.element.type
          });
        };

        _proto._createStructure = function _createStructure() {
          // Hide original element
          this.passedElement.conceal(); // Wrap input in container preserving DOM ordering

          this.containerInner.wrap(this.passedElement.element); // Wrapper inner container with outer container

          this.containerOuter.wrap(this.containerInner.element);

          if (this._isSelectOneElement) {
            this.input.placeholder = this.config.searchPlaceholderValue || '';
          } else if (this._placeholderValue) {
            this.input.placeholder = this._placeholderValue;
            this.input.setWidth();
          }

          this.containerOuter.element.appendChild(this.containerInner.element);
          this.containerOuter.element.appendChild(this.dropdown.element);
          this.containerInner.element.appendChild(this.itemList.element);

          if (!this._isTextElement) {
            this.dropdown.element.appendChild(this.choiceList.element);
          }

          if (!this._isSelectOneElement) {
            this.containerInner.element.appendChild(this.input.element);
          } else if (this.config.searchEnabled) {
            this.dropdown.element.insertBefore(this.input.element, this.dropdown.element.firstChild);
          }

          if (this._isSelectElement) {
            this._highlightPosition = 0;
            this._isSearching = false;

            this._startLoading();

            if (this._presetGroups.length) {
              this._addPredefinedGroups(this._presetGroups);
            } else {
              this._addPredefinedChoices(this._presetChoices);
            }

            this._stopLoading();
          }

          if (this._isTextElement) {
            this._addPredefinedItems(this._presetItems);
          }
        };

        _proto._addPredefinedGroups = function _addPredefinedGroups(groups) {
          var _this21 = this; // If we have a placeholder option


          var placeholderChoice = this.passedElement.placeholderOption;

          if (placeholderChoice && placeholderChoice.parentNode.tagName === 'SELECT') {
            this._addChoice({
              value: placeholderChoice.value,
              label: placeholderChoice.innerHTML,
              isSelected: placeholderChoice.selected,
              isDisabled: placeholderChoice.disabled,
              placeholder: true
            });
          }

          groups.forEach(function (group) {
            return _this21._addGroup({
              group: group,
              id: group.id || null
            });
          });
        };

        _proto._addPredefinedChoices = function _addPredefinedChoices(choices) {
          var _this22 = this; // If sorting is enabled or the user is searching, filter choices


          if (this.config.shouldSort) {
            choices.sort(this.config.sorter);
          }

          var hasSelectedChoice = choices.some(function (choice) {
            return choice.selected;
          });
          var firstEnabledChoiceIndex = choices.findIndex(function (choice) {
            return choice.disabled === undefined || !choice.disabled;
          });
          choices.forEach(function (choice, index) {
            var value = choice.value,
                label = choice.label,
                customProperties = choice.customProperties,
                placeholder = choice.placeholder;

            if (_this22._isSelectElement) {
              // If the choice is actually a group
              if (choice.choices) {
                _this22._addGroup({
                  group: choice,
                  id: choice.id || null
                });
              } else {
                /**
                 * If there is a selected choice already or the choice is not the first in
                 * the array, add each choice normally.
                 *
                 * Otherwise we pre-select the first enabled choice in the array ("select-one" only)
                 */
                var shouldPreselect = _this22._isSelectOneElement && !hasSelectedChoice && index === firstEnabledChoiceIndex;
                var isSelected = shouldPreselect ? true : choice.selected;
                var isDisabled = choice.disabled;

                _this22._addChoice({
                  value: value,
                  label: label,
                  isSelected: isSelected,
                  isDisabled: isDisabled,
                  customProperties: customProperties,
                  placeholder: placeholder
                });
              }
            } else {
              _this22._addChoice({
                value: value,
                label: label,
                isSelected: choice.selected,
                isDisabled: choice.disabled,
                customProperties: customProperties,
                placeholder: placeholder
              });
            }
          });
        }
        /**
         * @param {Item[]} items
         */
        ;

        _proto._addPredefinedItems = function _addPredefinedItems(items) {
          var _this23 = this;

          items.forEach(function (item) {
            if (typeof item === 'object' && item.value) {
              _this23._addItem({
                value: item.value,
                label: item.label,
                choiceId: item.id,
                customProperties: item.customProperties,
                placeholder: item.placeholder
              });
            }

            if (typeof item === 'string') {
              _this23._addItem({
                value: item
              });
            }
          });
        };

        _proto._setChoiceOrItem = function _setChoiceOrItem(item) {
          var _this24 = this;

          var itemType = getType(item).toLowerCase();
          var handleType = {
            object: function object() {
              if (!item.value) {
                return;
              } // If we are dealing with a select input, we need to create an option first
              // that is then selected. For text inputs we can just add items normally.


              if (!_this24._isTextElement) {
                _this24._addChoice({
                  value: item.value,
                  label: item.label,
                  isSelected: true,
                  isDisabled: false,
                  customProperties: item.customProperties,
                  placeholder: item.placeholder
                });
              } else {
                _this24._addItem({
                  value: item.value,
                  label: item.label,
                  choiceId: item.id,
                  customProperties: item.customProperties,
                  placeholder: item.placeholder
                });
              }
            },
            string: function string() {
              if (!_this24._isTextElement) {
                _this24._addChoice({
                  value: item,
                  label: item,
                  isSelected: true,
                  isDisabled: false
                });
              } else {
                _this24._addItem({
                  value: item
                });
              }
            }
          };
          handleType[itemType]();
        };

        _proto._findAndSelectChoiceByValue = function _findAndSelectChoiceByValue(val) {
          var _this25 = this;

          var choices = this._store.choices; // Check 'value' property exists and the choice isn't already selected

          var foundChoice = choices.find(function (choice) {
            return _this25.config.valueComparer(choice.value, val);
          });

          if (foundChoice && !foundChoice.selected) {
            this._addItem({
              value: foundChoice.value,
              label: foundChoice.label,
              choiceId: foundChoice.id,
              groupId: foundChoice.groupId,
              customProperties: foundChoice.customProperties,
              placeholder: foundChoice.placeholder,
              keyCode: foundChoice.keyCode
            });
          }
        };

        _proto._generatePlaceholderValue = function _generatePlaceholderValue() {
          if (this._isSelectElement) {
            var placeholderOption = this.passedElement.placeholderOption;
            return placeholderOption ? placeholderOption.text : false;
          }

          var _this$config4 = this.config,
              placeholder = _this$config4.placeholder,
              placeholderValue = _this$config4.placeholderValue;
          var dataset = this.passedElement.element.dataset;

          if (placeholder) {
            if (placeholderValue) {
              return placeholderValue;
            }

            if (dataset.placeholder) {
              return dataset.placeholder;
            }
          }

          return false;
        };

        return Choices;
      }();
      /* harmony default export */


      var scripts_choices = __webpack_exports__["default"] = choices_Choices;
      /***/
    }
    /******/
    ])["default"]
  );
});
/*!
 * OverlayScrollbars
 * https://github.com/KingSora/OverlayScrollbars
 *
 * Version: 1.12.0
 *
 * Copyright KingSora | Rene Haas.
 * https://github.com/KingSora
 *
 * Released under the MIT license.
 * Date: 05.04.2020
 */
(function (global, factory) {
  if (typeof define === 'function' && define.amd) define(function () {
    return factory(global, global.document, undefined);
  });else if (typeof module === 'object' && typeof module.exports === 'object') module.exports = factory(global, global.document, undefined);else factory(global, global.document, undefined);
})(typeof window !== 'undefined' ? window : this, function (window, document, undefined) {
  'use strict';

  var PLUGINNAME = 'OverlayScrollbars';
  var TYPES = {
    o: 'object',
    f: 'function',
    a: 'array',
    s: 'string',
    b: 'boolean',
    n: 'number',
    u: 'undefined',
    z: 'null' //d : 'date',
    //e : 'error',
    //r : 'regexp',
    //y : 'symbol'

  };
  var LEXICON = {
    c: 'class',
    s: 'style',
    i: 'id',
    l: 'length',
    p: 'prototype',
    ti: 'tabindex',
    oH: 'offsetHeight',
    cH: 'clientHeight',
    sH: 'scrollHeight',
    oW: 'offsetWidth',
    cW: 'clientWidth',
    sW: 'scrollWidth',
    hOP: 'hasOwnProperty',
    bCR: 'getBoundingClientRect'
  };

  var VENDORS = function () {
    //https://developer.mozilla.org/en-US/docs/Glossary/Vendor_Prefix
    var jsCache = {};
    var cssCache = {};
    var cssPrefixes = ['-webkit-', '-moz-', '-o-', '-ms-'];
    var jsPrefixes = ['WebKit', 'Moz', 'O', 'MS'];

    function firstLetterToUpper(str) {
      return str.charAt(0).toUpperCase() + str.slice(1);
    }

    return {
      _cssPrefixes: cssPrefixes,
      _jsPrefixes: jsPrefixes,
      _cssProperty: function (name) {
        var result = cssCache[name];
        if (cssCache[LEXICON.hOP](name)) return result;
        var uppercasedName = firstLetterToUpper(name);
        var elmStyle = document.createElement('div')[LEXICON.s];
        var resultPossibilities;
        var i = 0;
        var v;
        var currVendorWithoutDashes;

        for (; i < cssPrefixes.length; i++) {
          currVendorWithoutDashes = cssPrefixes[i].replace(/-/g, '');
          resultPossibilities = [name, //transition
          cssPrefixes[i] + name, //-webkit-transition
          currVendorWithoutDashes + uppercasedName, //webkitTransition
          firstLetterToUpper(currVendorWithoutDashes) + uppercasedName //WebkitTransition
          ];

          for (v = 0; v < resultPossibilities[LEXICON.l]; v++) {
            if (elmStyle[resultPossibilities[v]] !== undefined) {
              result = resultPossibilities[v];
              break;
            }
          }
        }

        cssCache[name] = result;
        return result;
      },
      _cssPropertyValue: function (property, values, suffix) {
        var name = property + ' ' + values;
        var result = cssCache[name];
        if (cssCache[LEXICON.hOP](name)) return result;
        var dummyStyle = document.createElement('div')[LEXICON.s];
        var possbleValues = values.split(' ');
        var preparedSuffix = suffix || '';
        var i = 0;
        var v = -1;
        var prop;

        for (; i < possbleValues[LEXICON.l]; i++) {
          for (; v < VENDORS._cssPrefixes[LEXICON.l]; v++) {
            prop = v < 0 ? possbleValues[i] : VENDORS._cssPrefixes[v] + possbleValues[i];
            dummyStyle.cssText = property + ':' + prop + preparedSuffix;

            if (dummyStyle[LEXICON.l]) {
              result = prop;
              break;
            }
          }
        }

        cssCache[name] = result;
        return result;
      },
      _jsAPI: function (name, isInterface, fallback) {
        var i = 0;
        var result = jsCache[name];

        if (!jsCache[LEXICON.hOP](name)) {
          result = window[name];

          for (; i < jsPrefixes[LEXICON.l]; i++) result = result || window[(isInterface ? jsPrefixes[i] : jsPrefixes[i].toLowerCase()) + firstLetterToUpper(name)];

          jsCache[name] = result;
        }

        return result || fallback;
      }
    };
  }();

  var COMPATIBILITY = function () {
    function windowSize(x) {
      return x ? window.innerWidth || document.documentElement[LEXICON.cW] || document.body[LEXICON.cW] : window.innerHeight || document.documentElement[LEXICON.cH] || document.body[LEXICON.cH];
    }

    function bind(func, thisObj) {
      if (typeof func != TYPES.f) {
        throw "Can't bind function!"; // closest thing possible to the ECMAScript 5
        // internal IsCallable function
        //throw new TypeError('Function.prototype.bind - what is trying to be bound is not callable');
      }

      var proto = LEXICON.p;
      var aArgs = Array[proto].slice.call(arguments, 2);

      var fNOP = function () {};

      var fBound = function () {
        return func.apply(this instanceof fNOP ? this : thisObj, aArgs.concat(Array[proto].slice.call(arguments)));
      };

      if (func[proto]) fNOP[proto] = func[proto]; // Function.prototype doesn't have a prototype property

      fBound[proto] = new fNOP();
      return fBound;
    }

    return {
      /**
       * Gets the current window width.
       * @returns {Number|number} The current window width in pixel.
       */
      wW: bind(windowSize, 0, true),

      /**
       * Gets the current window height.
       * @returns {Number|number} The current window height in pixel.
       */
      wH: bind(windowSize, 0),

      /**
       * Gets the MutationObserver Object or undefined if not supported.
       * @returns {MutationObserver|*|undefined} The MutationsObserver Object or undefined.
       */
      mO: bind(VENDORS._jsAPI, 0, 'MutationObserver', true),

      /**
       * Gets the ResizeObserver Object or undefined if not supported.
       * @returns {MutationObserver|*|undefined} The ResizeObserver Object or undefined.
       */
      rO: bind(VENDORS._jsAPI, 0, 'ResizeObserver', true),

      /**
       * Gets the RequestAnimationFrame method or it's corresponding polyfill.
       * @returns {*|Function} The RequestAnimationFrame method or it's corresponding polyfill.
       */
      rAF: bind(VENDORS._jsAPI, 0, 'requestAnimationFrame', false, function (func) {
        return window.setTimeout(func, 1000 / 60);
      }),

      /**
       * Gets the CancelAnimationFrame method or it's corresponding polyfill.
       * @returns {*|Function} The CancelAnimationFrame method or it's corresponding polyfill.
       */
      cAF: bind(VENDORS._jsAPI, 0, 'cancelAnimationFrame', false, function (id) {
        return window.clearTimeout(id);
      }),

      /**
       * Gets the current time.
       * @returns {number} The current time.
       */
      now: function () {
        return Date.now && Date.now() || new Date().getTime();
      },

      /**
       * Stops the propagation of the given event.
       * @param event The event of which the propagation shall be stoped.
       */
      stpP: function (event) {
        if (event.stopPropagation) event.stopPropagation();else event.cancelBubble = true;
      },

      /**
       * Prevents the default action of the given event.
       * @param event The event of which the default action shall be prevented.
       */
      prvD: function (event) {
        if (event.preventDefault && event.cancelable) event.preventDefault();else event.returnValue = false;
      },

      /**
       * Gets the pageX and pageY values of the given mouse event.
       * @param event The mouse event of which the pageX and pageX shall be got.
       * @returns {{x: number, y: number}} x = pageX value, y = pageY value.
       */
      page: function (event) {
        event = event.originalEvent || event;
        var strPage = 'page';
        var strClient = 'client';
        var strX = 'X';
        var strY = 'Y';
        var target = event.target || event.srcElement || document;
        var eventDoc = target.ownerDocument || document;
        var doc = eventDoc.documentElement;
        var body = eventDoc.body; //if touch event return return pageX/Y of it

        if (event.touches !== undefined) {
          var touch = event.touches[0];
          return {
            x: touch[strPage + strX],
            y: touch[strPage + strY]
          };
        } // Calculate pageX/Y if not native supported


        if (!event[strPage + strX] && event[strClient + strX] && event[strClient + strX] != null) {
          return {
            x: event[strClient + strX] + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0),
            y: event[strClient + strY] + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0)
          };
        }

        return {
          x: event[strPage + strX],
          y: event[strPage + strY]
        };
      },

      /**
       * Gets the clicked mouse button of the given mouse event.
       * @param event The mouse event of which the clicked button shal be got.
       * @returns {number} The number of the clicked mouse button. (0 : none | 1 : leftButton | 2 : middleButton | 3 : rightButton)
       */
      mBtn: function (event) {
        var button = event.button;
        if (!event.which && button !== undefined) return button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;else return event.which;
      },

      /**
       * Checks whether a item is in the given array and returns its index.
       * @param item The item of which the position in the array shall be determined.
       * @param arr The array.
       * @returns {number} The zero based index of the item or -1 if the item isn't in the array.
       */
      inA: function (item, arr) {
        for (var i = 0; i < arr[LEXICON.l]; i++) //Sometiems in IE a "SCRIPT70" Permission denied error occurs if HTML elements in a iFrame are compared
        try {
          if (arr[i] === item) return i;
        } catch (e) {}

        return -1;
      },

      /**
       * Returns true if the given value is a array.
       * @param arr The potential array.
       * @returns {boolean} True if the given value is a array, false otherwise.
       */
      isA: function (arr) {
        var def = Array.isArray;
        return def ? def(arr) : this.type(arr) == TYPES.a;
      },

      /**
       * Determine the internal JavaScript [[Class]] of the given object.
       * @param obj The object of which the type shall be determined.
       * @returns {string} The type of the given object.
       */
      type: function (obj) {
        if (obj === undefined) return obj + '';
        if (obj === null) return obj + '';
        return Object[LEXICON.p].toString.call(obj).replace(/^\[object (.+)\]$/, '$1').toLowerCase();
      },
      bind: bind
      /**
       * Gets the vendor-prefixed CSS property by the given name.
       * For example the given name is "transform" and you're using a old Firefox browser then the returned value would be "-moz-transform".
       * If the browser doesn't need a vendor-prefix, then the returned string is the given name.
       * If the browser doesn't support the given property name at all (not even with a vendor-prefix) the returned value is null.
       * @param propName The unprefixed CSS property name.
       * @returns {string|null} The vendor-prefixed CSS property or null if the browser doesn't support the given CSS property.
        cssProp: function(propName) {
          return VENDORS._cssProperty(propName);
      }
      */

    };
  }();

  var MATH = Math;
  var JQUERY = window.jQuery;

  var EASING = function () {
    var _easingsMath = {
      p: MATH.PI,
      c: MATH.cos,
      s: MATH.sin,
      w: MATH.pow,
      t: MATH.sqrt,
      n: MATH.asin,
      a: MATH.abs,
      o: 1.70158
    };
    /*
     x : current percent (0 - 1),
     t : current time (duration * percent),
     b : start value (from),
     c : end value (to),
     d : duration
       easingName : function(x, t, b, c, d) { return easedValue; }
     */

    return {
      swing: function (x, t, b, c, d) {
        return 0.5 - _easingsMath.c(x * _easingsMath.p) / 2;
      },
      linear: function (x, t, b, c, d) {
        return x;
      },
      easeInQuad: function (x, t, b, c, d) {
        return c * (t /= d) * t + b;
      },
      easeOutQuad: function (x, t, b, c, d) {
        return -c * (t /= d) * (t - 2) + b;
      },
      easeInOutQuad: function (x, t, b, c, d) {
        return (t /= d / 2) < 1 ? c / 2 * t * t + b : -c / 2 * (--t * (t - 2) - 1) + b;
      },
      easeInCubic: function (x, t, b, c, d) {
        return c * (t /= d) * t * t + b;
      },
      easeOutCubic: function (x, t, b, c, d) {
        return c * ((t = t / d - 1) * t * t + 1) + b;
      },
      easeInOutCubic: function (x, t, b, c, d) {
        return (t /= d / 2) < 1 ? c / 2 * t * t * t + b : c / 2 * ((t -= 2) * t * t + 2) + b;
      },
      easeInQuart: function (x, t, b, c, d) {
        return c * (t /= d) * t * t * t + b;
      },
      easeOutQuart: function (x, t, b, c, d) {
        return -c * ((t = t / d - 1) * t * t * t - 1) + b;
      },
      easeInOutQuart: function (x, t, b, c, d) {
        return (t /= d / 2) < 1 ? c / 2 * t * t * t * t + b : -c / 2 * ((t -= 2) * t * t * t - 2) + b;
      },
      easeInQuint: function (x, t, b, c, d) {
        return c * (t /= d) * t * t * t * t + b;
      },
      easeOutQuint: function (x, t, b, c, d) {
        return c * ((t = t / d - 1) * t * t * t * t + 1) + b;
      },
      easeInOutQuint: function (x, t, b, c, d) {
        return (t /= d / 2) < 1 ? c / 2 * t * t * t * t * t + b : c / 2 * ((t -= 2) * t * t * t * t + 2) + b;
      },
      easeInSine: function (x, t, b, c, d) {
        return -c * _easingsMath.c(t / d * (_easingsMath.p / 2)) + c + b;
      },
      easeOutSine: function (x, t, b, c, d) {
        return c * _easingsMath.s(t / d * (_easingsMath.p / 2)) + b;
      },
      easeInOutSine: function (x, t, b, c, d) {
        return -c / 2 * (_easingsMath.c(_easingsMath.p * t / d) - 1) + b;
      },
      easeInExpo: function (x, t, b, c, d) {
        return t == 0 ? b : c * _easingsMath.w(2, 10 * (t / d - 1)) + b;
      },
      easeOutExpo: function (x, t, b, c, d) {
        return t == d ? b + c : c * (-_easingsMath.w(2, -10 * t / d) + 1) + b;
      },
      easeInOutExpo: function (x, t, b, c, d) {
        if (t == 0) return b;
        if (t == d) return b + c;
        if ((t /= d / 2) < 1) return c / 2 * _easingsMath.w(2, 10 * (t - 1)) + b;
        return c / 2 * (-_easingsMath.w(2, -10 * --t) + 2) + b;
      },
      easeInCirc: function (x, t, b, c, d) {
        return -c * (_easingsMath.t(1 - (t /= d) * t) - 1) + b;
      },
      easeOutCirc: function (x, t, b, c, d) {
        return c * _easingsMath.t(1 - (t = t / d - 1) * t) + b;
      },
      easeInOutCirc: function (x, t, b, c, d) {
        return (t /= d / 2) < 1 ? -c / 2 * (_easingsMath.t(1 - t * t) - 1) + b : c / 2 * (_easingsMath.t(1 - (t -= 2) * t) + 1) + b;
      },
      easeInElastic: function (x, t, b, c, d) {
        var s = _easingsMath.o;
        var p = 0;
        var a = c;
        if (t == 0) return b;
        if ((t /= d) == 1) return b + c;
        if (!p) p = d * .3;

        if (a < _easingsMath.a(c)) {
          a = c;
          s = p / 4;
        } else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);

        return -(a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
      },
      easeOutElastic: function (x, t, b, c, d) {
        var s = _easingsMath.o;
        var p = 0;
        var a = c;
        if (t == 0) return b;
        if ((t /= d) == 1) return b + c;
        if (!p) p = d * .3;

        if (a < _easingsMath.a(c)) {
          a = c;
          s = p / 4;
        } else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);

        return a * _easingsMath.w(2, -10 * t) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) + c + b;
      },
      easeInOutElastic: function (x, t, b, c, d) {
        var s = _easingsMath.o;
        var p = 0;
        var a = c;
        if (t == 0) return b;
        if ((t /= d / 2) == 2) return b + c;
        if (!p) p = d * (.3 * 1.5);

        if (a < _easingsMath.a(c)) {
          a = c;
          s = p / 4;
        } else s = p / (2 * _easingsMath.p) * _easingsMath.n(c / a);

        if (t < 1) return -.5 * (a * _easingsMath.w(2, 10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p)) + b;
        return a * _easingsMath.w(2, -10 * (t -= 1)) * _easingsMath.s((t * d - s) * (2 * _easingsMath.p) / p) * .5 + c + b;
      },
      easeInBack: function (x, t, b, c, d, s) {
        s = s || _easingsMath.o;
        return c * (t /= d) * t * ((s + 1) * t - s) + b;
      },
      easeOutBack: function (x, t, b, c, d, s) {
        s = s || _easingsMath.o;
        return c * ((t = t / d - 1) * t * ((s + 1) * t + s) + 1) + b;
      },
      easeInOutBack: function (x, t, b, c, d, s) {
        s = s || _easingsMath.o;
        return (t /= d / 2) < 1 ? c / 2 * (t * t * (((s *= 1.525) + 1) * t - s)) + b : c / 2 * ((t -= 2) * t * (((s *= 1.525) + 1) * t + s) + 2) + b;
      },
      easeInBounce: function (x, t, b, c, d) {
        return c - this.easeOutBounce(x, d - t, 0, c, d) + b;
      },
      easeOutBounce: function (x, t, b, c, d) {
        var o = 7.5625;

        if ((t /= d) < 1 / 2.75) {
          return c * (o * t * t) + b;
        } else if (t < 2 / 2.75) {
          return c * (o * (t -= 1.5 / 2.75) * t + .75) + b;
        } else if (t < 2.5 / 2.75) {
          return c * (o * (t -= 2.25 / 2.75) * t + .9375) + b;
        } else {
          return c * (o * (t -= 2.625 / 2.75) * t + .984375) + b;
        }
      },
      easeInOutBounce: function (x, t, b, c, d) {
        return t < d / 2 ? this.easeInBounce(x, t * 2, 0, c, d) * .5 + b : this.easeOutBounce(x, t * 2 - d, 0, c, d) * .5 + c * .5 + b;
      }
    };
    /*
     *
     * TERMS OF USE - EASING EQUATIONS
     * 
     * Open source under the BSD License. 
     * 
     * Copyright Â© 2001 Robert Penner
     * All rights reserved.
     * 
     * Redistribution and use in source and binary forms, with or without modification, 
     * are permitted provided that the following conditions are met:
     * 
     * Redistributions of source code must retain the above copyright notice, this list of 
     * conditions and the following disclaimer.
     * Redistributions in binary form must reproduce the above copyright notice, this list 
     * of conditions and the following disclaimer in the documentation and/or other materials 
     * provided with the distribution.
     * 
     * Neither the name of the author nor the names of contributors may be used to endorse 
     * or promote products derived from this software without specific prior written permission.
     * 
     * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY 
     * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
     * MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
     *  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
     *  EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE
     *  GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED 
     * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
     *  NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED 
     * OF THE POSSIBILITY OF SUCH DAMAGE. 
     *
     */
  }();

  var FRAMEWORK = function () {
    var _rnothtmlwhite = /[^\x20\t\r\n\f]+/g;
    var _strSpace = ' ';
    var _strEmpty = '';
    var _strScrollLeft = 'scrollLeft';
    var _strScrollTop = 'scrollTop';
    var _animations = [];
    var _type = COMPATIBILITY.type;
    var _cssNumber = {
      animationIterationCount: true,
      columnCount: true,
      fillOpacity: true,
      flexGrow: true,
      flexShrink: true,
      fontWeight: true,
      lineHeight: true,
      opacity: true,
      order: true,
      orphans: true,
      widows: true,
      zIndex: true,
      zoom: true
    };

    function extend() {
      var src,
          copyIsArray,
          copy,
          name,
          options,
          clone,
          target = arguments[0] || {},
          i = 1,
          length = arguments[LEXICON.l],
          deep = false; // Handle a deep copy situation

      if (_type(target) == TYPES.b) {
        deep = target;
        target = arguments[1] || {}; // skip the boolean and the target

        i = 2;
      } // Handle case when target is a string or something (possible in deep copy)


      if (_type(target) != TYPES.o && !_type(target) == TYPES.f) {
        target = {};
      } // extend jQuery itself if only one argument is passed


      if (length === i) {
        target = FakejQuery;
        --i;
      }

      for (; i < length; i++) {
        // Only deal with non-null/undefined values
        if ((options = arguments[i]) != null) {
          // Extend the base object
          for (name in options) {
            src = target[name];
            copy = options[name]; // Prevent never-ending loop

            if (target === copy) {
              continue;
            } // Recurse if we're merging plain objects or arrays


            if (deep && copy && (isPlainObject(copy) || (copyIsArray = COMPATIBILITY.isA(copy)))) {
              if (copyIsArray) {
                copyIsArray = false;
                clone = src && COMPATIBILITY.isA(src) ? src : [];
              } else {
                clone = src && isPlainObject(src) ? src : {};
              } // Never move original objects, clone them


              target[name] = extend(deep, clone, copy); // Don't bring in undefined values
            } else if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      } // Return the modified object


      return target;
    }

    ;

    function inArray(item, arr, fromIndex) {
      for (var i = fromIndex || 0; i < arr[LEXICON.l]; i++) if (arr[i] === item) return i;

      return -1;
    }

    function isFunction(obj) {
      return _type(obj) == TYPES.f;
    }

    ;

    function isEmptyObject(obj) {
      for (var name in obj) return false;

      return true;
    }

    ;

    function isPlainObject(obj) {
      if (!obj || _type(obj) != TYPES.o) return false;
      var key;
      var proto = LEXICON.p;
      var hasOwnProperty = Object[proto].hasOwnProperty;
      var hasOwnConstructor = hasOwnProperty.call(obj, 'constructor');
      var hasIsPrototypeOf = obj.constructor && obj.constructor[proto] && hasOwnProperty.call(obj.constructor[proto], 'isPrototypeOf');

      if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
        return false;
      }

      for (key in obj) {
        /**/
      }

      return _type(key) == TYPES.u || hasOwnProperty.call(obj, key);
    }

    ;

    function each(obj, callback) {
      var i = 0;

      if (isArrayLike(obj)) {
        for (; i < obj[LEXICON.l]; i++) {
          if (callback.call(obj[i], i, obj[i]) === false) break;
        }
      } else {
        for (i in obj) {
          if (callback.call(obj[i], i, obj[i]) === false) break;
        }
      }

      return obj;
    }

    ;

    function isArrayLike(obj) {
      var length = !!obj && [LEXICON.l] in obj && obj[LEXICON.l];

      var t = _type(obj);

      return isFunction(t) ? false : t == TYPES.a || length === 0 || _type(length) == TYPES.n && length > 0 && length - 1 in obj;
    }

    function stripAndCollapse(value) {
      var tokens = value.match(_rnothtmlwhite) || [];
      return tokens.join(_strSpace);
    }

    function matches(elem, selector) {
      var nodeList = (elem.parentNode || document).querySelectorAll(selector) || [];
      var i = nodeList[LEXICON.l];

      while (i--) if (nodeList[i] == elem) return true;

      return false;
    }

    function insertAdjacentElement(el, strategy, child) {
      if (COMPATIBILITY.isA(child)) {
        for (var i = 0; i < child[LEXICON.l]; i++) insertAdjacentElement(el, strategy, child[i]);
      } else if (_type(child) == TYPES.s) el.insertAdjacentHTML(strategy, child);else el.insertAdjacentElement(strategy, child.nodeType ? child : child[0]);
    }

    function setCSSVal(el, prop, val) {
      try {
        if (el[LEXICON.s][prop] !== undefined) el[LEXICON.s][prop] = parseCSSVal(prop, val);
      } catch (e) {}
    }

    function parseCSSVal(prop, val) {
      if (!_cssNumber[prop.toLowerCase()] && _type(val) == TYPES.n) val += 'px';
      return val;
    }

    function startNextAnimationInQ(animObj, removeFromQ) {
      var index;
      var nextAnim;
      if (removeFromQ !== false) animObj.q.splice(0, 1);

      if (animObj.q[LEXICON.l] > 0) {
        nextAnim = animObj.q[0];
        animate(animObj.el, nextAnim.props, nextAnim.duration, nextAnim.easing, nextAnim.complete, true);
      } else {
        index = inArray(animObj, _animations);
        if (index > -1) _animations.splice(index, 1);
      }
    }

    function setAnimationValue(el, prop, value) {
      if (prop === _strScrollLeft || prop === _strScrollTop) el[prop] = value;else setCSSVal(el, prop, value);
    }

    function animate(el, props, options, easing, complete, guaranteedNext) {
      var hasOptions = isPlainObject(options);
      var from = {};
      var to = {};
      var i = 0;
      var key;
      var animObj;
      var start;
      var progress;
      var step;
      var specialEasing;
      var duration;

      if (hasOptions) {
        easing = options.easing;
        start = options.start;
        progress = options.progress;
        step = options.step;
        specialEasing = options.specialEasing;
        complete = options.complete;
        duration = options.duration;
      } else duration = options;

      specialEasing = specialEasing || {};
      duration = duration || 400;
      easing = easing || 'swing';
      guaranteedNext = guaranteedNext || false;

      for (; i < _animations[LEXICON.l]; i++) {
        if (_animations[i].el === el) {
          animObj = _animations[i];
          break;
        }
      }

      if (!animObj) {
        animObj = {
          el: el,
          q: []
        };

        _animations.push(animObj);
      }

      for (key in props) {
        if (key === _strScrollLeft || key === _strScrollTop) from[key] = el[key];else from[key] = FakejQuery(el).css(key);
      }

      for (key in from) {
        if (from[key] !== props[key] && props[key] !== undefined) to[key] = props[key];
      }

      if (!isEmptyObject(to)) {
        var timeNow;
        var end;
        var percent;
        var fromVal;
        var toVal;
        var easedVal;
        var timeStart;
        var frame;
        var elapsed;
        var qPos = guaranteedNext ? 0 : inArray(qObj, animObj.q);
        var qObj = {
          props: to,
          duration: hasOptions ? options : duration,
          easing: easing,
          complete: complete
        };

        if (qPos === -1) {
          qPos = animObj.q[LEXICON.l];
          animObj.q.push(qObj);
        }

        if (qPos === 0) {
          if (duration > 0) {
            timeStart = COMPATIBILITY.now();

            frame = function () {
              timeNow = COMPATIBILITY.now();
              elapsed = timeNow - timeStart;
              end = qObj.stop || elapsed >= duration;
              percent = 1 - (MATH.max(0, timeStart + duration - timeNow) / duration || 0);

              for (key in to) {
                fromVal = parseFloat(from[key]);
                toVal = parseFloat(to[key]);
                easedVal = (toVal - fromVal) * EASING[specialEasing[key] || easing](percent, percent * duration, 0, 1, duration) + fromVal;
                setAnimationValue(el, key, easedVal);

                if (isFunction(step)) {
                  step(easedVal, {
                    elem: el,
                    prop: key,
                    start: fromVal,
                    now: easedVal,
                    end: toVal,
                    pos: percent,
                    options: {
                      easing: easing,
                      speacialEasing: specialEasing,
                      duration: duration,
                      complete: complete,
                      step: step
                    },
                    startTime: timeStart
                  });
                }
              }

              if (isFunction(progress)) progress({}, percent, MATH.max(0, duration - elapsed));

              if (end) {
                startNextAnimationInQ(animObj);
                if (isFunction(complete)) complete();
              } else qObj.frame = COMPATIBILITY.rAF()(frame);
            };

            qObj.frame = COMPATIBILITY.rAF()(frame);
          } else {
            for (key in to) setAnimationValue(el, key, to[key]);

            startNextAnimationInQ(animObj);
          }
        }
      } else if (guaranteedNext) startNextAnimationInQ(animObj);
    }

    function stop(el, clearQ, jumpToEnd) {
      var animObj;
      var qObj;
      var key;
      var i = 0;

      for (; i < _animations[LEXICON.l]; i++) {
        animObj = _animations[i];

        if (animObj.el === el) {
          if (animObj.q[LEXICON.l] > 0) {
            qObj = animObj.q[0];
            qObj.stop = true;
            COMPATIBILITY.cAF()(qObj.frame);
            animObj.q.splice(0, 1);
            if (jumpToEnd) for (key in qObj.props) setAnimationValue(el, key, qObj.props[key]);
            if (clearQ) animObj.q = [];else startNextAnimationInQ(animObj, false);
          }

          break;
        }
      }
    }

    function elementIsVisible(el) {
      return !!(el[LEXICON.oW] || el[LEXICON.oH] || el.getClientRects()[LEXICON.l]);
    }

    function FakejQuery(selector) {
      if (arguments[LEXICON.l] === 0) return this;
      var base = new FakejQuery();
      var elements = selector;
      var i = 0;
      var elms;
      var el;

      if (_type(selector) == TYPES.s) {
        elements = [];

        if (selector.charAt(0) === '<') {
          el = document.createElement('div');
          el.innerHTML = selector;
          elms = el.children;
        } else {
          elms = document.querySelectorAll(selector);
        }

        for (; i < elms[LEXICON.l]; i++) elements.push(elms[i]);
      }

      if (elements) {
        if (_type(elements) != TYPES.s && (!isArrayLike(elements) || elements === window || elements === elements.self)) elements = [elements];

        for (i = 0; i < elements[LEXICON.l]; i++) base[i] = elements[i];

        base[LEXICON.l] = elements[LEXICON.l];
      }

      return base;
    }

    ;
    FakejQuery[LEXICON.p] = {
      //EVENTS:
      on: function (eventName, handler) {
        eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
        var eventNameLength = eventName[LEXICON.l];
        var i = 0;
        var el;
        return this.each(function () {
          el = this;

          try {
            if (el.addEventListener) {
              for (; i < eventNameLength; i++) el.addEventListener(eventName[i], handler);
            } else if (el.detachEvent) {
              for (; i < eventNameLength; i++) el.attachEvent('on' + eventName[i], handler);
            }
          } catch (e) {}
        });
      },
      off: function (eventName, handler) {
        eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
        var eventNameLength = eventName[LEXICON.l];
        var i = 0;
        var el;
        return this.each(function () {
          el = this;

          try {
            if (el.removeEventListener) {
              for (; i < eventNameLength; i++) el.removeEventListener(eventName[i], handler);
            } else if (el.detachEvent) {
              for (; i < eventNameLength; i++) el.detachEvent('on' + eventName[i], handler);
            }
          } catch (e) {}
        });
      },
      one: function (eventName, handler) {
        eventName = (eventName || _strEmpty).match(_rnothtmlwhite) || [_strEmpty];
        return this.each(function () {
          var el = FakejQuery(this);
          FakejQuery.each(eventName, function (i, oneEventName) {
            var oneHandler = function (e) {
              handler.call(this, e);
              el.off(oneEventName, oneHandler);
            };

            el.on(oneEventName, oneHandler);
          });
        });
      },
      trigger: function (eventName) {
        var el;
        var event;
        return this.each(function () {
          el = this;

          if (document.createEvent) {
            event = document.createEvent('HTMLEvents');
            event.initEvent(eventName, true, false);
            el.dispatchEvent(event);
          } else {
            el.fireEvent('on' + eventName);
          }
        });
      },
      //DOM NODE INSERTING / REMOVING:
      append: function (child) {
        return this.each(function () {
          insertAdjacentElement(this, 'beforeend', child);
        });
      },
      prepend: function (child) {
        return this.each(function () {
          insertAdjacentElement(this, 'afterbegin', child);
        });
      },
      before: function (child) {
        return this.each(function () {
          insertAdjacentElement(this, 'beforebegin', child);
        });
      },
      after: function (child) {
        return this.each(function () {
          insertAdjacentElement(this, 'afterend', child);
        });
      },
      remove: function () {
        return this.each(function () {
          var el = this;
          var parentNode = el.parentNode;
          if (parentNode != null) parentNode.removeChild(el);
        });
      },
      unwrap: function () {
        var parents = [];
        var i;
        var el;
        var parent;
        this.each(function () {
          parent = this.parentNode;
          if (inArray(parent, parents) === -1) parents.push(parent);
        });

        for (i = 0; i < parents[LEXICON.l]; i++) {
          el = parents[i];
          parent = el.parentNode;

          while (el.firstChild) parent.insertBefore(el.firstChild, el);

          parent.removeChild(el);
        }

        return this;
      },
      wrapAll: function (wrapperHTML) {
        var i;
        var nodes = this;
        var wrapper = FakejQuery(wrapperHTML)[0];
        var deepest = wrapper;
        var parent = nodes[0].parentNode;
        var previousSibling = nodes[0].previousSibling;

        while (deepest.childNodes[LEXICON.l] > 0) deepest = deepest.childNodes[0];

        for (i = 0; nodes[LEXICON.l] - i; deepest.firstChild === nodes[0] && i++) deepest.appendChild(nodes[i]);

        var nextSibling = previousSibling ? previousSibling.nextSibling : parent.firstChild;
        parent.insertBefore(wrapper, nextSibling);
        return this;
      },
      wrapInner: function (wrapperHTML) {
        return this.each(function () {
          var el = FakejQuery(this);
          var contents = el.contents();
          if (contents[LEXICON.l]) contents.wrapAll(wrapperHTML);else el.append(wrapperHTML);
        });
      },
      wrap: function (wrapperHTML) {
        return this.each(function () {
          FakejQuery(this).wrapAll(wrapperHTML);
        });
      },
      //DOM NODE MANIPULATION / INFORMATION:
      css: function (styles, val) {
        var el;
        var key;
        var cptStyle;
        var getCptStyle = window.getComputedStyle;

        if (_type(styles) == TYPES.s) {
          if (val === undefined) {
            el = this[0];
            cptStyle = getCptStyle ? getCptStyle(el, null) : el.currentStyle[styles]; //https://bugzilla.mozilla.org/show_bug.cgi?id=548397 can be null sometimes if iframe with display: none (firefox only!)

            return getCptStyle ? cptStyle != null ? cptStyle.getPropertyValue(styles) : el[LEXICON.s][styles] : cptStyle;
          } else {
            return this.each(function () {
              setCSSVal(this, styles, val);
            });
          }
        } else {
          return this.each(function () {
            for (key in styles) setCSSVal(this, key, styles[key]);
          });
        }
      },
      hasClass: function (className) {
        var elem,
            i = 0;
        var classNamePrepared = _strSpace + className + _strSpace;
        var classList;

        while (elem = this[i++]) {
          classList = elem.classList;
          if (classList && classList.contains(className)) return true;else if (elem.nodeType === 1 && (_strSpace + stripAndCollapse(elem.className + _strEmpty) + _strSpace).indexOf(classNamePrepared) > -1) return true;
        }

        return false;
      },
      addClass: function (className) {
        var classes;
        var elem;
        var cur;
        var curValue;
        var clazz;
        var finalValue;
        var supportClassList;
        var elmClassList;
        var i = 0;
        var v = 0;

        if (className) {
          classes = className.match(_rnothtmlwhite) || [];

          while (elem = this[i++]) {
            elmClassList = elem.classList;
            if (supportClassList === undefined) supportClassList = elmClassList !== undefined;

            if (supportClassList) {
              while (clazz = classes[v++]) elmClassList.add(clazz);
            } else {
              curValue = elem.className + _strEmpty;
              cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;

              if (cur) {
                while (clazz = classes[v++]) if (cur.indexOf(_strSpace + clazz + _strSpace) < 0) cur += clazz + _strSpace;

                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) elem.className = finalValue;
              }
            }
          }
        }

        return this;
      },
      removeClass: function (className) {
        var classes;
        var elem;
        var cur;
        var curValue;
        var clazz;
        var finalValue;
        var supportClassList;
        var elmClassList;
        var i = 0;
        var v = 0;

        if (className) {
          classes = className.match(_rnothtmlwhite) || [];

          while (elem = this[i++]) {
            elmClassList = elem.classList;
            if (supportClassList === undefined) supportClassList = elmClassList !== undefined;

            if (supportClassList) {
              while (clazz = classes[v++]) elmClassList.remove(clazz);
            } else {
              curValue = elem.className + _strEmpty;
              cur = elem.nodeType === 1 && _strSpace + stripAndCollapse(curValue) + _strSpace;

              if (cur) {
                while (clazz = classes[v++]) while (cur.indexOf(_strSpace + clazz + _strSpace) > -1) cur = cur.replace(_strSpace + clazz + _strSpace, _strSpace);

                finalValue = stripAndCollapse(cur);
                if (curValue !== finalValue) elem.className = finalValue;
              }
            }
          }
        }

        return this;
      },
      hide: function () {
        return this.each(function () {
          this[LEXICON.s].display = 'none';
        });
      },
      show: function () {
        return this.each(function () {
          this[LEXICON.s].display = 'block';
        });
      },
      attr: function (attrName, value) {
        var i = 0;
        var el;

        while (el = this[i++]) {
          if (value === undefined) return el.getAttribute(attrName);
          el.setAttribute(attrName, value);
        }

        return this;
      },
      removeAttr: function (attrName) {
        return this.each(function () {
          this.removeAttribute(attrName);
        });
      },
      offset: function () {
        var el = this[0];
        var rect = el[LEXICON.bCR]();
        var scrollLeft = window.pageXOffset || document.documentElement[_strScrollLeft];
        var scrollTop = window.pageYOffset || document.documentElement[_strScrollTop];
        return {
          top: rect.top + scrollTop,
          left: rect.left + scrollLeft
        };
      },
      position: function () {
        var el = this[0];
        return {
          top: el.offsetTop,
          left: el.offsetLeft
        };
      },
      scrollLeft: function (value) {
        var i = 0;
        var el;

        while (el = this[i++]) {
          if (value === undefined) return el[_strScrollLeft];
          el[_strScrollLeft] = value;
        }

        return this;
      },
      scrollTop: function (value) {
        var i = 0;
        var el;

        while (el = this[i++]) {
          if (value === undefined) return el[_strScrollTop];
          el[_strScrollTop] = value;
        }

        return this;
      },
      val: function (value) {
        var el = this[0];
        if (!value) return el.value;
        el.value = value;
        return this;
      },
      //DOM TRAVERSAL / FILTERING:
      first: function () {
        return this.eq(0);
      },
      last: function () {
        return this.eq(-1);
      },
      eq: function (index) {
        return FakejQuery(this[index >= 0 ? index : this[LEXICON.l] + index]);
      },
      find: function (selector) {
        var children = [];
        var i;
        this.each(function () {
          var el = this;
          var ch = el.querySelectorAll(selector);

          for (i = 0; i < ch[LEXICON.l]; i++) children.push(ch[i]);
        });
        return FakejQuery(children);
      },
      children: function (selector) {
        var children = [];
        var el;
        var ch;
        var i;
        this.each(function () {
          ch = this.children;

          for (i = 0; i < ch[LEXICON.l]; i++) {
            el = ch[i];

            if (selector) {
              if (el.matches && el.matches(selector) || matches(el, selector)) children.push(el);
            } else children.push(el);
          }
        });
        return FakejQuery(children);
      },
      parent: function (selector) {
        var parents = [];
        var parent;
        this.each(function () {
          parent = this.parentNode;
          if (selector ? FakejQuery(parent).is(selector) : true) parents.push(parent);
        });
        return FakejQuery(parents);
      },
      is: function (selector) {
        var el;
        var i;

        for (i = 0; i < this[LEXICON.l]; i++) {
          el = this[i];
          if (selector === ':visible') return elementIsVisible(el);
          if (selector === ':hidden') return !elementIsVisible(el);
          if (el.matches && el.matches(selector) || matches(el, selector)) return true;
        }

        return false;
      },
      contents: function () {
        var contents = [];
        var childs;
        var i;
        this.each(function () {
          childs = this.childNodes;

          for (i = 0; i < childs[LEXICON.l]; i++) contents.push(childs[i]);
        });
        return FakejQuery(contents);
      },
      each: function (callback) {
        return each(this, callback);
      },
      //ANIMATION:
      animate: function (props, duration, easing, complete) {
        return this.each(function () {
          animate(this, props, duration, easing, complete);
        });
      },
      stop: function (clearQ, jump) {
        return this.each(function () {
          stop(this, clearQ, jump);
        });
      }
    };
    extend(FakejQuery, {
      extend: extend,
      inArray: inArray,
      isEmptyObject: isEmptyObject,
      isPlainObject: isPlainObject,
      each: each
    });
    return FakejQuery;
  }();

  var INSTANCES = function () {
    var _targets = [];
    var _instancePropertyString = '__overlayScrollbars__';
    /**
     * Register, unregister or get a certain (or all) instances.
     * Register: Pass the target and the instance.
     * Unregister: Pass the target and null.
     * Get Instance: Pass the target from which the instance shall be got.
     * Get Targets: Pass no arguments.
     * @param target The target to which the instance shall be registered / from which the instance shall be unregistered / the instance shall be got
     * @param instance The instance.
     * @returns {*|void} Returns the instance from the given target.
     */

    return function (target, instance) {
      var argLen = arguments[LEXICON.l];

      if (argLen < 1) {
        //return all targets
        return _targets;
      } else {
        if (instance) {
          //register instance
          target[_instancePropertyString] = instance;

          _targets.push(target);
        } else {
          var index = COMPATIBILITY.inA(target, _targets);

          if (index > -1) {
            if (argLen > 1) {
              //unregister instance
              delete target[_instancePropertyString];

              _targets.splice(index, 1);
            } else {
              //get instance from target
              return _targets[index][_instancePropertyString];
            }
          }
        }
      }
    };
  }();

  var PLUGIN = function () {
    var _plugin;

    var _pluginsGlobals;

    var _pluginsAutoUpdateLoop;

    var _pluginsExtensions = [];

    var _pluginsOptions = function () {
      var type = COMPATIBILITY.type;
      var possibleTemplateTypes = [TYPES.b, //boolean
      TYPES.n, //number
      TYPES.s, //string
      TYPES.a, //array
      TYPES.o, //object
      TYPES.f, //function
      TYPES.z //null
      ];
      var restrictedStringsSplit = ' ';
      var restrictedStringsPossibilitiesSplit = ':';
      var classNameAllowedValues = [TYPES.z, TYPES.s];
      var numberAllowedValues = TYPES.n;
      var booleanNullAllowedValues = [TYPES.z, TYPES.b];
      var booleanTrueTemplate = [true, TYPES.b];
      var booleanFalseTemplate = [false, TYPES.b];
      var callbackTemplate = [null, [TYPES.z, TYPES.f]];
      var updateOnLoadTemplate = [['img'], [TYPES.s, TYPES.a, TYPES.z]];
      var inheritedAttrsTemplate = [['style', 'class'], [TYPES.s, TYPES.a, TYPES.z]];
      var resizeAllowedValues = 'n:none b:both h:horizontal v:vertical';
      var overflowBehaviorAllowedValues = 'v-h:visible-hidden v-s:visible-scroll s:scroll h:hidden';
      var scrollbarsVisibilityAllowedValues = 'v:visible h:hidden a:auto';
      var scrollbarsAutoHideAllowedValues = 'n:never s:scroll l:leave m:move';
      var optionsDefaultsAndTemplate = {
        className: ['os-theme-dark', classNameAllowedValues],
        //null || string
        resize: ['none', resizeAllowedValues],
        //none || both  || horizontal || vertical || n || b || h || v
        sizeAutoCapable: booleanTrueTemplate,
        //true || false
        clipAlways: booleanTrueTemplate,
        //true || false
        normalizeRTL: booleanTrueTemplate,
        //true || false
        paddingAbsolute: booleanFalseTemplate,
        //true || false
        autoUpdate: [null, booleanNullAllowedValues],
        //true || false || null
        autoUpdateInterval: [33, numberAllowedValues],
        //number
        updateOnLoad: updateOnLoadTemplate,
        //string || array || null
        nativeScrollbarsOverlaid: {
          showNativeScrollbars: booleanFalseTemplate,
          //true || false
          initialize: booleanTrueTemplate //true || false

        },
        overflowBehavior: {
          x: ['scroll', overflowBehaviorAllowedValues],
          //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s
          y: ['scroll', overflowBehaviorAllowedValues] //visible-hidden  || visible-scroll || hidden || scroll || v-h || v-s || h || s

        },
        scrollbars: {
          visibility: ['auto', scrollbarsVisibilityAllowedValues],
          //visible || hidden || auto || v || h || a
          autoHide: ['never', scrollbarsAutoHideAllowedValues],
          //never || scroll || leave || move || n || s || l || m
          autoHideDelay: [800, numberAllowedValues],
          //number
          dragScrolling: booleanTrueTemplate,
          //true || false
          clickScrolling: booleanFalseTemplate,
          //true || false
          touchSupport: booleanTrueTemplate,
          //true || false
          snapHandle: booleanFalseTemplate //true || false

        },
        textarea: {
          dynWidth: booleanFalseTemplate,
          //true || false
          dynHeight: booleanFalseTemplate,
          //true || false
          inheritedAttrs: inheritedAttrsTemplate //string || array || null

        },
        callbacks: {
          onInitialized: callbackTemplate,
          //null || function
          onInitializationWithdrawn: callbackTemplate,
          //null || function
          onDestroyed: callbackTemplate,
          //null || function
          onScrollStart: callbackTemplate,
          //null || function
          onScroll: callbackTemplate,
          //null || function
          onScrollStop: callbackTemplate,
          //null || function
          onOverflowChanged: callbackTemplate,
          //null || function
          onOverflowAmountChanged: callbackTemplate,
          //null || function
          onDirectionChanged: callbackTemplate,
          //null || function
          onContentSizeChanged: callbackTemplate,
          //null || function
          onHostSizeChanged: callbackTemplate,
          //null || function
          onUpdated: callbackTemplate //null || function

        }
      };

      var convert = function (template) {
        var recursive = function (obj) {
          var key;
          var val;
          var valType;

          for (key in obj) {
            if (!obj[LEXICON.hOP](key)) continue;
            val = obj[key];
            valType = type(val);
            if (valType == TYPES.a) obj[key] = val[template ? 1 : 0];else if (valType == TYPES.o) obj[key] = recursive(val);
          }

          return obj;
        };

        return recursive(FRAMEWORK.extend(true, {}, optionsDefaultsAndTemplate));
      };

      return {
        _defaults: convert(),
        _template: convert(true),

        /**
         * Validates the passed object by the passed template.
         * @param obj The object which shall be validated.
         * @param template The template which defines the allowed values and types.
         * @param writeErrors True if errors shall be logged to the console.
         * @param diffObj If a object is passed then only valid differences to this object will be returned.
         * @returns {{}} A object which contains two objects called "default" and "prepared" which contains only the valid properties of the passed original object and discards not different values compared to the passed diffObj.
         */
        _validate: function (obj, template, writeErrors, diffObj) {
          var validatedOptions = {};
          var validatedOptionsPrepared = {};
          var objectCopy = FRAMEWORK.extend(true, {}, obj);
          var inArray = FRAMEWORK.inArray;
          var isEmptyObj = FRAMEWORK.isEmptyObject;

          var checkObjectProps = function (data, template, diffData, validatedOptions, validatedOptionsPrepared, prevPropName) {
            for (var prop in template) {
              if (template[LEXICON.hOP](prop) && data[LEXICON.hOP](prop)) {
                var isValid = false;
                var isDiff = false;
                var templateValue = template[prop];
                var templateValueType = type(templateValue);
                var templateIsComplex = templateValueType == TYPES.o;
                var templateTypes = !COMPATIBILITY.isA(templateValue) ? [templateValue] : templateValue;
                var dataDiffValue = diffData[prop];
                var dataValue = data[prop];
                var dataValueType = type(dataValue);
                var propPrefix = prevPropName ? prevPropName + '.' : '';
                var error = "The option \"" + propPrefix + prop + "\" wasn't set, because";
                var errorPossibleTypes = [];
                var errorRestrictedStrings = [];
                var restrictedStringValuesSplit;
                var restrictedStringValuesPossibilitiesSplit;
                var isRestrictedValue;
                var mainPossibility;
                var currType;
                var i;
                var v;
                var j;
                dataDiffValue = dataDiffValue === undefined ? {} : dataDiffValue; //if the template has a object as value, it means that the options are complex (verschachtelt)

                if (templateIsComplex && dataValueType == TYPES.o) {
                  validatedOptions[prop] = {};
                  validatedOptionsPrepared[prop] = {};
                  checkObjectProps(dataValue, templateValue, dataDiffValue, validatedOptions[prop], validatedOptionsPrepared[prop], propPrefix + prop);
                  FRAMEWORK.each([data, validatedOptions, validatedOptionsPrepared], function (index, value) {
                    if (isEmptyObj(value[prop])) {
                      delete value[prop];
                    }
                  });
                } else if (!templateIsComplex) {
                  for (i = 0; i < templateTypes[LEXICON.l]; i++) {
                    currType = templateTypes[i];
                    templateValueType = type(currType); //if currtype is string and starts with restrictedStringPrefix and end with restrictedStringSuffix

                    isRestrictedValue = templateValueType == TYPES.s && inArray(currType, possibleTemplateTypes) === -1;

                    if (isRestrictedValue) {
                      errorPossibleTypes.push(TYPES.s); //split it into a array which contains all possible values for example: ["y:yes", "n:no", "m:maybe"]

                      restrictedStringValuesSplit = currType.split(restrictedStringsSplit);
                      errorRestrictedStrings = errorRestrictedStrings.concat(restrictedStringValuesSplit);

                      for (v = 0; v < restrictedStringValuesSplit[LEXICON.l]; v++) {
                        //split the possible values into their possibiliteis for example: ["y", "yes"] -> the first is always the mainPossibility
                        restrictedStringValuesPossibilitiesSplit = restrictedStringValuesSplit[v].split(restrictedStringsPossibilitiesSplit);
                        mainPossibility = restrictedStringValuesPossibilitiesSplit[0];

                        for (j = 0; j < restrictedStringValuesPossibilitiesSplit[LEXICON.l]; j++) {
                          //if any possibility matches with the dataValue, its valid
                          if (dataValue === restrictedStringValuesPossibilitiesSplit[j]) {
                            isValid = true;
                            break;
                          }
                        }

                        if (isValid) break;
                      }
                    } else {
                      errorPossibleTypes.push(currType);

                      if (dataValueType === currType) {
                        isValid = true;
                        break;
                      }
                    }
                  }

                  if (isValid) {
                    isDiff = dataValue !== dataDiffValue;
                    if (isDiff) validatedOptions[prop] = dataValue;
                    if (isRestrictedValue ? inArray(dataDiffValue, restrictedStringValuesPossibilitiesSplit) < 0 : isDiff) validatedOptionsPrepared[prop] = isRestrictedValue ? mainPossibility : dataValue;
                  } else if (writeErrors) {
                    console.warn(error + " it doesn't accept the type [ " + dataValueType.toUpperCase() + " ] with the value of \"" + dataValue + "\".\r\n" + "Accepted types are: [ " + errorPossibleTypes.join(', ').toUpperCase() + " ]." + (errorRestrictedStrings[length] > 0 ? "\r\nValid strings are: [ " + errorRestrictedStrings.join(', ').split(restrictedStringsPossibilitiesSplit).join(', ') + " ]." : ''));
                  }

                  delete data[prop];
                }
              }
            }
          };

          checkObjectProps(objectCopy, template, diffObj || {}, validatedOptions, validatedOptionsPrepared); //add values which aren't specified in the template to the finished validated object to prevent them from being discarded

          /*
          if(keepForeignProps) {
              FRAMEWORK.extend(true, validatedOptions, objectCopy);
              FRAMEWORK.extend(true, validatedOptionsPrepared, objectCopy);
          }
          */

          if (!isEmptyObj(objectCopy) && writeErrors) console.warn('The following options are discarded due to invalidity:\r\n' + window.JSON.stringify(objectCopy, null, 2));
          return {
            _default: validatedOptions,
            _prepared: validatedOptionsPrepared
          };
        }
      };
    }();
    /**
     * Initializes the object which contains global information about the plugin and each instance of it.
     */


    function initOverlayScrollbarsStatics() {
      if (!_pluginsGlobals) _pluginsGlobals = new OverlayScrollbarsGlobals(_pluginsOptions._defaults);
      if (!_pluginsAutoUpdateLoop) _pluginsAutoUpdateLoop = new OverlayScrollbarsAutoUpdateLoop(_pluginsGlobals);
    }
    /**
     * The global object for the OverlayScrollbars objects. It contains resources which every OverlayScrollbars object needs. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
     * @param defaultOptions
     * @constructor
     */


    function OverlayScrollbarsGlobals(defaultOptions) {
      var _base = this;

      var strOverflow = 'overflow';
      var strHidden = 'hidden';
      var strScroll = 'scroll';
      var bodyElement = FRAMEWORK('body');
      var scrollbarDummyElement = FRAMEWORK('<div id="os-dummy-scrollbar-size"><div></div></div>');
      var scrollbarDummyElement0 = scrollbarDummyElement[0];
      var dummyContainerChild = FRAMEWORK(scrollbarDummyElement.children('div').eq(0));
      bodyElement.append(scrollbarDummyElement);
      scrollbarDummyElement.hide().show(); //fix IE8 bug (incorrect measuring)

      var nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement0);
      var nativeScrollbarIsOverlaid = {
        x: nativeScrollbarSize.x === 0,
        y: nativeScrollbarSize.y === 0
      };

      var msie = function () {
        var ua = window.navigator.userAgent;
        var strIndexOf = 'indexOf';
        var strSubString = 'substring';
        var msie = ua[strIndexOf]('MSIE ');
        var trident = ua[strIndexOf]('Trident/');
        var edge = ua[strIndexOf]('Edge/');
        var rv = ua[strIndexOf]('rv:');
        var result;
        var parseIntFunc = parseInt; // IE 10 or older => return version number

        if (msie > 0) result = parseIntFunc(ua[strSubString](msie + 5, ua[strIndexOf]('.', msie)), 10); // IE 11 => return version number
        else if (trident > 0) result = parseIntFunc(ua[strSubString](rv + 3, ua[strIndexOf]('.', rv)), 10); // Edge (IE 12+) => return version number
          else if (edge > 0) result = parseIntFunc(ua[strSubString](edge + 5, ua[strIndexOf]('.', edge)), 10); // other browser

        return result;
      }();

      FRAMEWORK.extend(_base, {
        defaultOptions: defaultOptions,
        msie: msie,
        autoUpdateLoop: false,
        autoUpdateRecommended: !COMPATIBILITY.mO(),
        nativeScrollbarSize: nativeScrollbarSize,
        nativeScrollbarIsOverlaid: nativeScrollbarIsOverlaid,
        nativeScrollbarStyling: function () {
          var result = false;
          scrollbarDummyElement.addClass('os-viewport-native-scrollbars-invisible');

          try {
            result = scrollbarDummyElement.css('scrollbar-width') === 'none' && (msie > 9 || !msie) || window.getComputedStyle(scrollbarDummyElement0, '::-webkit-scrollbar').getPropertyValue('display') === 'none';
          } catch (ex) {} //fix opera bug: scrollbar styles will only appear if overflow value is scroll or auto during the activation of the style.
          //and set overflow to scroll
          //scrollbarDummyElement.css(strOverflow, strHidden).hide().css(strOverflow, strScroll).show();
          //return (scrollbarDummyElement0[LEXICON.oH] - scrollbarDummyElement0[LEXICON.cH]) === 0 && (scrollbarDummyElement0[LEXICON.oW] - scrollbarDummyElement0[LEXICON.cW]) === 0;


          return result;
        }(),
        overlayScrollbarDummySize: {
          x: 30,
          y: 30
        },
        cssCalc: VENDORS._cssPropertyValue('width', 'calc', '(1px)') || null,
        restrictedMeasuring: function () {
          //https://bugzilla.mozilla.org/show_bug.cgi?id=1439305
          //since 1.11.0 always false -> fixed via CSS (hopefully)
          scrollbarDummyElement.css(strOverflow, strHidden);
          var scrollSize = {
            w: scrollbarDummyElement0[LEXICON.sW],
            h: scrollbarDummyElement0[LEXICON.sH]
          };
          scrollbarDummyElement.css(strOverflow, 'visible');
          var scrollSize2 = {
            w: scrollbarDummyElement0[LEXICON.sW],
            h: scrollbarDummyElement0[LEXICON.sH]
          };
          return scrollSize.w - scrollSize2.w !== 0 || scrollSize.h - scrollSize2.h !== 0;
        }(),
        rtlScrollBehavior: function () {
          scrollbarDummyElement.css({
            'overflow-y': strHidden,
            'overflow-x': strScroll,
            'direction': 'rtl'
          }).scrollLeft(0);
          var dummyContainerOffset = scrollbarDummyElement.offset();
          var dummyContainerChildOffset = dummyContainerChild.offset(); //https://github.com/KingSora/OverlayScrollbars/issues/187

          scrollbarDummyElement.scrollLeft(-999);
          var dummyContainerChildOffsetAfterScroll = dummyContainerChild.offset();
          return {
            //origin direction = determines if the zero scroll position is on the left or right side
            //'i' means 'invert' (i === true means that the axis must be inverted to be correct)
            //true = on the left side
            //false = on the right side
            i: dummyContainerOffset.left === dummyContainerChildOffset.left,
            //negative = determines if the maximum scroll is positive or negative
            //'n' means 'negate' (n === true means that the axis must be negated to be correct)
            //true = negative
            //false = positive
            n: dummyContainerChildOffset.left !== dummyContainerChildOffsetAfterScroll.left
          };
        }(),
        supportTransform: !!VENDORS._cssProperty('transform'),
        supportTransition: !!VENDORS._cssProperty('transition'),
        supportPassiveEvents: function () {
          var supportsPassive = false;

          try {
            window.addEventListener('test', null, Object.defineProperty({}, 'passive', {
              get: function () {
                supportsPassive = true;
              }
            }));
          } catch (e) {}

          return supportsPassive;
        }(),
        supportResizeObserver: !!COMPATIBILITY.rO(),
        supportMutationObserver: !!COMPATIBILITY.mO()
      });
      scrollbarDummyElement.removeAttr(LEXICON.s).remove(); //Catch zoom event:

      (function () {
        if (nativeScrollbarIsOverlaid.x && nativeScrollbarIsOverlaid.y) return;
        var abs = MATH.abs;
        var windowWidth = COMPATIBILITY.wW();
        var windowHeight = COMPATIBILITY.wH();
        var windowDpr = getWindowDPR();

        var onResize = function () {
          if (INSTANCES().length > 0) {
            var newW = COMPATIBILITY.wW();
            var newH = COMPATIBILITY.wH();
            var deltaW = newW - windowWidth;
            var deltaH = newH - windowHeight;
            if (deltaW === 0 && deltaH === 0) return;
            var deltaWRatio = MATH.round(newW / (windowWidth / 100.0));
            var deltaHRatio = MATH.round(newH / (windowHeight / 100.0));
            var absDeltaW = abs(deltaW);
            var absDeltaH = abs(deltaH);
            var absDeltaWRatio = abs(deltaWRatio);
            var absDeltaHRatio = abs(deltaHRatio);
            var newDPR = getWindowDPR();
            var deltaIsBigger = absDeltaW > 2 && absDeltaH > 2;
            var difference = !differenceIsBiggerThanOne(absDeltaWRatio, absDeltaHRatio);
            var dprChanged = newDPR !== windowDpr && windowDpr > 0;
            var isZoom = deltaIsBigger && difference && dprChanged;
            var oldScrollbarSize = _base.nativeScrollbarSize;
            var newScrollbarSize;

            if (isZoom) {
              bodyElement.append(scrollbarDummyElement);
              newScrollbarSize = _base.nativeScrollbarSize = calcNativeScrollbarSize(scrollbarDummyElement[0]);
              scrollbarDummyElement.remove();

              if (oldScrollbarSize.x !== newScrollbarSize.x || oldScrollbarSize.y !== newScrollbarSize.y) {
                FRAMEWORK.each(INSTANCES(), function () {
                  if (INSTANCES(this)) INSTANCES(this).update('zoom');
                });
              }
            }

            windowWidth = newW;
            windowHeight = newH;
            windowDpr = newDPR;
          }
        };

        function differenceIsBiggerThanOne(valOne, valTwo) {
          var absValOne = abs(valOne);
          var absValTwo = abs(valTwo);
          return !(absValOne === absValTwo || absValOne + 1 === absValTwo || absValOne - 1 === absValTwo);
        }

        function getWindowDPR() {
          var dDPI = window.screen.deviceXDPI || 0;
          var sDPI = window.screen.logicalXDPI || 1;
          return window.devicePixelRatio || dDPI / sDPI;
        }

        FRAMEWORK(window).on('resize', onResize);
      })();

      function calcNativeScrollbarSize(measureElement) {
        return {
          x: measureElement[LEXICON.oH] - measureElement[LEXICON.cH],
          y: measureElement[LEXICON.oW] - measureElement[LEXICON.cW]
        };
      }
    }
    /**
     * The object which manages the auto update loop for all OverlayScrollbars objects. This object is initialized only once: if the first OverlayScrollbars object gets initialized.
     * @constructor
     */


    function OverlayScrollbarsAutoUpdateLoop(globals) {
      var _base = this;

      var _inArray = FRAMEWORK.inArray;
      var _getNow = COMPATIBILITY.now;
      var _strAutoUpdate = 'autoUpdate';

      var _strAutoUpdateInterval = _strAutoUpdate + 'Interval';

      var _strLength = LEXICON.l;
      var _loopingInstances = [];
      var _loopingInstancesIntervalCache = [];
      var _loopIsActive = false;
      var _loopIntervalDefault = 33;
      var _loopInterval = _loopIntervalDefault;

      var _loopTimeOld = _getNow();

      var _loopID;
      /**
       * The auto update loop which will run every 50 milliseconds or less if the update interval of a instance is lower than 50 milliseconds.
       */


      var loop = function () {
        if (_loopingInstances[_strLength] > 0 && _loopIsActive) {
          _loopID = COMPATIBILITY.rAF()(function () {
            loop();
          });

          var timeNew = _getNow();

          var timeDelta = timeNew - _loopTimeOld;
          var lowestInterval;
          var instance;
          var instanceOptions;
          var instanceAutoUpdateAllowed;
          var instanceAutoUpdateInterval;
          var now;

          if (timeDelta > _loopInterval) {
            _loopTimeOld = timeNew - timeDelta % _loopInterval;
            lowestInterval = _loopIntervalDefault;

            for (var i = 0; i < _loopingInstances[_strLength]; i++) {
              instance = _loopingInstances[i];

              if (instance !== undefined) {
                instanceOptions = instance.options();
                instanceAutoUpdateAllowed = instanceOptions[_strAutoUpdate];
                instanceAutoUpdateInterval = MATH.max(1, instanceOptions[_strAutoUpdateInterval]);
                now = _getNow();

                if ((instanceAutoUpdateAllowed === true || instanceAutoUpdateAllowed === null) && now - _loopingInstancesIntervalCache[i] > instanceAutoUpdateInterval) {
                  instance.update('auto');
                  _loopingInstancesIntervalCache[i] = new Date(now += instanceAutoUpdateInterval);
                }

                lowestInterval = MATH.max(1, MATH.min(lowestInterval, instanceAutoUpdateInterval));
              }
            }

            _loopInterval = lowestInterval;
          }
        } else {
          _loopInterval = _loopIntervalDefault;
        }
      };
      /**
       * Add OverlayScrollbars instance to the auto update loop. Only successful if the instance isn't already added.
       * @param instance The instance which shall be updated in a loop automatically.
       */


      _base.add = function (instance) {
        if (_inArray(instance, _loopingInstances) === -1) {
          _loopingInstances.push(instance);

          _loopingInstancesIntervalCache.push(_getNow());

          if (_loopingInstances[_strLength] > 0 && !_loopIsActive) {
            _loopIsActive = true;
            globals.autoUpdateLoop = _loopIsActive;
            loop();
          }
        }
      };
      /**
       * Remove OverlayScrollbars instance from the auto update loop. Only successful if the instance was added before.
       * @param instance The instance which shall be updated in a loop automatically.
       */


      _base.remove = function (instance) {
        var index = _inArray(instance, _loopingInstances);

        if (index > -1) {
          //remove from loopingInstances list
          _loopingInstancesIntervalCache.splice(index, 1);

          _loopingInstances.splice(index, 1); //correct update loop behavior


          if (_loopingInstances[_strLength] === 0 && _loopIsActive) {
            _loopIsActive = false;
            globals.autoUpdateLoop = _loopIsActive;

            if (_loopID !== undefined) {
              COMPATIBILITY.cAF()(_loopID);
              _loopID = -1;
            }
          }
        }
      };
    }
    /**
     * A object which manages the scrollbars visibility of the target element.
     * @param pluginTargetElement The element from which the scrollbars shall be hidden.
     * @param options The custom options.
     * @param extensions The custom extensions.
     * @param globals
     * @param autoUpdateLoop
     * @returns {*}
     * @constructor
     */


    function OverlayScrollbarsInstance(pluginTargetElement, options, extensions, globals, autoUpdateLoop) {
      //shortcuts
      var type = COMPATIBILITY.type;
      var inArray = FRAMEWORK.inArray;
      var each = FRAMEWORK.each; //make correct instanceof

      var _base = new _plugin();

      var _frameworkProto = FRAMEWORK[LEXICON.p]; //if passed element is no HTML element: skip and return

      if (!isHTMLElement(pluginTargetElement)) return; //if passed element is already initialized: set passed options if there are any and return its instance

      if (INSTANCES(pluginTargetElement)) {
        var inst = INSTANCES(pluginTargetElement);
        inst.options(options);
        return inst;
      } //globals:


      var _nativeScrollbarIsOverlaid;

      var _overlayScrollbarDummySize;

      var _rtlScrollBehavior;

      var _autoUpdateRecommended;

      var _msieVersion;

      var _nativeScrollbarStyling;

      var _cssCalc;

      var _nativeScrollbarSize;

      var _supportTransition;

      var _supportTransform;

      var _supportPassiveEvents;

      var _supportResizeObserver;

      var _supportMutationObserver;

      var _restrictedMeasuring; //general readonly:


      var _initialized;

      var _destroyed;

      var _isTextarea;

      var _isBody;

      var _documentMixed;

      var _domExists; //general:


      var _isBorderBox;

      var _sizeAutoObserverAdded;

      var _paddingX;

      var _paddingY;

      var _borderX;

      var _borderY;

      var _marginX;

      var _marginY;

      var _isRTL;

      var _sleeping;

      var _contentBorderSize = {};
      var _scrollHorizontalInfo = {};
      var _scrollVerticalInfo = {};
      var _viewportSize = {};
      var _nativeScrollbarMinSize = {}; //naming:	

      var _strMinusHidden = '-hidden';
      var _strMarginMinus = 'margin-';
      var _strPaddingMinus = 'padding-';
      var _strBorderMinus = 'border-';
      var _strTop = 'top';
      var _strRight = 'right';
      var _strBottom = 'bottom';
      var _strLeft = 'left';
      var _strMinMinus = 'min-';
      var _strMaxMinus = 'max-';
      var _strWidth = 'width';
      var _strHeight = 'height';
      var _strFloat = 'float';
      var _strEmpty = '';
      var _strAuto = 'auto';
      var _strSync = 'sync';
      var _strScroll = 'scroll';
      var _strHundredPercent = '100%';
      var _strX = 'x';
      var _strY = 'y';
      var _strDot = '.';
      var _strSpace = ' ';
      var _strScrollbar = 'scrollbar';
      var _strMinusHorizontal = '-horizontal';
      var _strMinusVertical = '-vertical';

      var _strScrollLeft = _strScroll + 'Left';

      var _strScrollTop = _strScroll + 'Top';

      var _strMouseTouchDownEvent = 'mousedown touchstart';
      var _strMouseTouchUpEvent = 'mouseup touchend touchcancel';
      var _strMouseTouchMoveEvent = 'mousemove touchmove';
      var _strMouseEnter = 'mouseenter';
      var _strMouseLeave = 'mouseleave';
      var _strKeyDownEvent = 'keydown';
      var _strKeyUpEvent = 'keyup';
      var _strSelectStartEvent = 'selectstart';
      var _strTransitionEndEvent = 'transitionend webkitTransitionEnd oTransitionEnd';
      var _strResizeObserverProperty = '__overlayScrollbarsRO__'; //class names:	

      var _cassNamesPrefix = 'os-';

      var _classNameHTMLElement = _cassNamesPrefix + 'html';

      var _classNameHostElement = _cassNamesPrefix + 'host';

      var _classNameHostElementForeign = _classNameHostElement + '-foreign';

      var _classNameHostTextareaElement = _classNameHostElement + '-textarea';

      var _classNameHostScrollbarHorizontalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusHorizontal + _strMinusHidden;

      var _classNameHostScrollbarVerticalHidden = _classNameHostElement + '-' + _strScrollbar + _strMinusVertical + _strMinusHidden;

      var _classNameHostTransition = _classNameHostElement + '-transition';

      var _classNameHostRTL = _classNameHostElement + '-rtl';

      var _classNameHostResizeDisabled = _classNameHostElement + '-resize-disabled';

      var _classNameHostScrolling = _classNameHostElement + '-scrolling';

      var _classNameHostOverflow = _classNameHostElement + '-overflow';

      var _classNameHostOverflow = _classNameHostElement + '-overflow';

      var _classNameHostOverflowX = _classNameHostOverflow + '-x';

      var _classNameHostOverflowY = _classNameHostOverflow + '-y';

      var _classNameTextareaElement = _cassNamesPrefix + 'textarea';

      var _classNameTextareaCoverElement = _classNameTextareaElement + '-cover';

      var _classNamePaddingElement = _cassNamesPrefix + 'padding';

      var _classNameViewportElement = _cassNamesPrefix + 'viewport';

      var _classNameViewportNativeScrollbarsInvisible = _classNameViewportElement + '-native-scrollbars-invisible';

      var _classNameViewportNativeScrollbarsOverlaid = _classNameViewportElement + '-native-scrollbars-overlaid';

      var _classNameContentElement = _cassNamesPrefix + 'content';

      var _classNameContentArrangeElement = _cassNamesPrefix + 'content-arrange';

      var _classNameContentGlueElement = _cassNamesPrefix + 'content-glue';

      var _classNameSizeAutoObserverElement = _cassNamesPrefix + 'size-auto-observer';

      var _classNameResizeObserverElement = _cassNamesPrefix + 'resize-observer';

      var _classNameResizeObserverItemElement = _cassNamesPrefix + 'resize-observer-item';

      var _classNameResizeObserverItemFinalElement = _classNameResizeObserverItemElement + '-final';

      var _classNameTextInherit = _cassNamesPrefix + 'text-inherit';

      var _classNameScrollbar = _cassNamesPrefix + _strScrollbar;

      var _classNameScrollbarTrack = _classNameScrollbar + '-track';

      var _classNameScrollbarTrackOff = _classNameScrollbarTrack + '-off';

      var _classNameScrollbarHandle = _classNameScrollbar + '-handle';

      var _classNameScrollbarHandleOff = _classNameScrollbarHandle + '-off';

      var _classNameScrollbarUnusable = _classNameScrollbar + '-unusable';

      var _classNameScrollbarAutoHidden = _classNameScrollbar + '-' + _strAuto + _strMinusHidden;

      var _classNameScrollbarCorner = _classNameScrollbar + '-corner';

      var _classNameScrollbarCornerResize = _classNameScrollbarCorner + '-resize';

      var _classNameScrollbarCornerResizeB = _classNameScrollbarCornerResize + '-both';

      var _classNameScrollbarCornerResizeH = _classNameScrollbarCornerResize + _strMinusHorizontal;

      var _classNameScrollbarCornerResizeV = _classNameScrollbarCornerResize + _strMinusVertical;

      var _classNameScrollbarHorizontal = _classNameScrollbar + _strMinusHorizontal;

      var _classNameScrollbarVertical = _classNameScrollbar + _strMinusVertical;

      var _classNameDragging = _cassNamesPrefix + 'dragging';

      var _classNameThemeNone = _cassNamesPrefix + 'theme-none';

      var _classNamesDynamicDestroy = [_classNameViewportNativeScrollbarsInvisible, _classNameViewportNativeScrollbarsOverlaid, _classNameScrollbarTrackOff, _classNameScrollbarHandleOff, _classNameScrollbarUnusable, _classNameScrollbarAutoHidden, _classNameScrollbarCornerResize, _classNameScrollbarCornerResizeB, _classNameScrollbarCornerResizeH, _classNameScrollbarCornerResizeV, _classNameDragging].join(_strSpace); //callbacks:	


      var _callbacksInitQeueue = []; //attrs viewport shall inherit from target	

      var _viewportAttrsFromTarget = [LEXICON.ti]; //options:	

      var _defaultOptions;

      var _currentOptions;

      var _currentPreparedOptions; //extensions:	


      var _extensions = {};
      var _extensionsPrivateMethods = 'added removed on contract'; //update	

      var _lastUpdateTime;

      var _swallowedUpdateHints = {};

      var _swallowedUpdateTimeout;

      var _swallowUpdateLag = 42;
      var _updateOnLoadEventName = 'load';
      var _updateOnLoadElms = []; //DOM elements:	

      var _windowElement;

      var _documentElement;

      var _htmlElement;

      var _bodyElement;

      var _targetElement; //the target element of this OverlayScrollbars object	


      var _hostElement; //the host element of this OverlayScrollbars object -> may be the same as targetElement	


      var _sizeAutoObserverElement; //observes size auto changes	


      var _sizeObserverElement; //observes size and padding changes	


      var _paddingElement; //manages the padding	


      var _viewportElement; //is the viewport of our scrollbar model	


      var _contentElement; //the element which holds the content	


      var _contentArrangeElement; //is needed for correct sizing of the content element (only if native scrollbars are overlays)	


      var _contentGlueElement; //has always the size of the content element	


      var _textareaCoverElement; //only applied if target is a textarea element. Used for correct size calculation and for prevention of uncontrolled scrolling	


      var _scrollbarCornerElement;

      var _scrollbarHorizontalElement;

      var _scrollbarHorizontalTrackElement;

      var _scrollbarHorizontalHandleElement;

      var _scrollbarVerticalElement;

      var _scrollbarVerticalTrackElement;

      var _scrollbarVerticalHandleElement;

      var _windowElementNative;

      var _documentElementNative;

      var _targetElementNative;

      var _hostElementNative;

      var _sizeAutoObserverElementNative;

      var _sizeObserverElementNative;

      var _paddingElementNative;

      var _viewportElementNative;

      var _contentElementNative; //Cache:	


      var _hostSizeCache;

      var _contentScrollSizeCache;

      var _arrangeContentSizeCache;

      var _hasOverflowCache;

      var _hideOverflowCache;

      var _widthAutoCache;

      var _heightAutoCache;

      var _cssBoxSizingCache;

      var _cssPaddingCache;

      var _cssBorderCache;

      var _cssMarginCache;

      var _cssDirectionCache;

      var _cssDirectionDetectedCache;

      var _paddingAbsoluteCache;

      var _clipAlwaysCache;

      var _contentGlueSizeCache;

      var _overflowBehaviorCache;

      var _overflowAmountCache;

      var _ignoreOverlayScrollbarHidingCache;

      var _autoUpdateCache;

      var _sizeAutoCapableCache;

      var _contentElementScrollSizeChangeDetectedCache;

      var _hostElementSizeChangeDetectedCache;

      var _scrollbarsVisibilityCache;

      var _scrollbarsAutoHideCache;

      var _scrollbarsClickScrollingCache;

      var _scrollbarsDragScrollingCache;

      var _resizeCache;

      var _normalizeRTLCache;

      var _classNameCache;

      var _oldClassName;

      var _textareaAutoWrappingCache;

      var _textareaInfoCache;

      var _textareaSizeCache;

      var _textareaDynHeightCache;

      var _textareaDynWidthCache;

      var _bodyMinSizeCache;

      var _updateAutoCache = {}; //MutationObserver:	

      var _mutationObserverHost;

      var _mutationObserverContent;

      var _mutationObserverHostCallback;

      var _mutationObserverContentCallback;

      var _mutationObserversConnected;

      var _mutationObserverAttrsTextarea = ['wrap', 'cols', 'rows'];

      var _mutationObserverAttrsHost = [LEXICON.i, LEXICON.c, LEXICON.s, 'open'].concat(_viewportAttrsFromTarget); //events:	


      var _destroyEvents = []; //textarea:	

      var _textareaHasFocus; //scrollbars:	


      var _scrollbarsAutoHideTimeoutId;

      var _scrollbarsAutoHideMoveTimeoutId;

      var _scrollbarsAutoHideDelay;

      var _scrollbarsAutoHideNever;

      var _scrollbarsAutoHideScroll;

      var _scrollbarsAutoHideMove;

      var _scrollbarsAutoHideLeave;

      var _scrollbarsHandleHovered;

      var _scrollbarsHandlesDefineScrollPos; //resize	


      var _resizeNone;

      var _resizeBoth;

      var _resizeHorizontal;

      var _resizeVertical; //==== Event Listener ====//	

      /**	
       * Adds or removes a event listener from the given element. 	
       * @param element The element to which the event listener shall be applied or removed.	
       * @param eventNames The name(s) of the events.	
       * @param listener The method which shall be called.	
       * @param remove True if the handler shall be removed, false or undefined if the handler shall be added.	
       */


      function setupResponsiveEventListener(element, eventNames, listener, remove, passive) {
        var collected = COMPATIBILITY.isA(eventNames) && COMPATIBILITY.isA(listener);
        var method = remove ? 'removeEventListener' : 'addEventListener';
        var onOff = remove ? 'off' : 'on';
        var events = collected ? false : eventNames.split(_strSpace);
        var i = 0;

        if (collected) {
          for (; i < eventNames[LEXICON.l]; i++) setupResponsiveEventListener(element, eventNames[i], listener[i], remove);
        } else {
          for (; i < events[LEXICON.l]; i++) {
            if (_supportPassiveEvents) element[0][method](events[i], listener, {
              passive: passive || false
            });else element[onOff](events[i], listener);
          }
        }
      }

      function addDestroyEventListener(element, eventNames, listener, passive) {
        setupResponsiveEventListener(element, eventNames, listener, false, passive);

        _destroyEvents.push(COMPATIBILITY.bind(setupResponsiveEventListener, 0, element, eventNames, listener, true, passive));
      } //==== Resize Observer ====//

      /**
       * Adds or removes a resize observer from the given element.
       * @param targetElement The element to which the resize observer shall be added or removed.
       * @param onElementResizedCallback The callback which is fired every time the resize observer registers a size change or false / undefined if the resizeObserver shall be removed.
       */


      function setupResizeObserver(targetElement, onElementResizedCallback) {
        if (targetElement) {
          var resizeObserver = COMPATIBILITY.rO();
          var strAnimationStartEvent = 'animationstart mozAnimationStart webkitAnimationStart MSAnimationStart';
          var strChildNodes = 'childNodes';
          var constScroll = 3333333;

          var callback = function () {
            targetElement[_strScrollTop](constScroll)[_strScrollLeft](_isRTL ? _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll : constScroll);

            onElementResizedCallback();
          }; //add resize observer:


          if (onElementResizedCallback) {
            if (_supportResizeObserver) {
              var element = targetElement.addClass('observed').append(generateDiv(_classNameResizeObserverElement)).contents()[0];
              var observer = element[_strResizeObserverProperty] = new resizeObserver(callback);
              observer.observe(element);
            } else {
              if (_msieVersion > 9 || !_autoUpdateRecommended) {
                targetElement.prepend(generateDiv(_classNameResizeObserverElement, generateDiv({
                  c: _classNameResizeObserverItemElement,
                  dir: 'ltr'
                }, generateDiv(_classNameResizeObserverItemElement, generateDiv(_classNameResizeObserverItemFinalElement)) + generateDiv(_classNameResizeObserverItemElement, generateDiv({
                  c: _classNameResizeObserverItemFinalElement,
                  style: 'width: 200%; height: 200%'
                })))));
                var observerElement = targetElement[0][strChildNodes][0][strChildNodes][0];
                var shrinkElement = FRAMEWORK(observerElement[strChildNodes][1]);
                var expandElement = FRAMEWORK(observerElement[strChildNodes][0]);
                var expandElementChild = FRAMEWORK(expandElement[0][strChildNodes][0]);
                var widthCache = observerElement[LEXICON.oW];
                var heightCache = observerElement[LEXICON.oH];
                var isDirty;
                var rAFId;
                var currWidth;
                var currHeight;
                var factor = 2;
                var nativeScrollbarSize = globals.nativeScrollbarSize; //care don't make changes to this object!!!

                var reset = function () {
                  /*
                   var sizeResetWidth = observerElement[LEXICON.oW] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                   var sizeResetHeight = observerElement[LEXICON.oH] + nativeScrollbarSize.x * factor + nativeScrollbarSize.y * factor + _overlayScrollbarDummySize.x + _overlayScrollbarDummySize.y;
                   var expandChildCSS = {};
                   expandChildCSS[_strWidth] = sizeResetWidth;
                   expandChildCSS[_strHeight] = sizeResetHeight;
                   expandElementChild.css(expandChildCSS);
                       expandElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                   shrinkElement[_strScrollLeft](sizeResetWidth)[_strScrollTop](sizeResetHeight);
                   */
                  expandElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);

                  shrinkElement[_strScrollLeft](constScroll)[_strScrollTop](constScroll);
                };

                var onResized = function () {
                  rAFId = 0;
                  if (!isDirty) return;
                  widthCache = currWidth;
                  heightCache = currHeight;
                  callback();
                };

                var onScroll = function (event) {
                  currWidth = observerElement[LEXICON.oW];
                  currHeight = observerElement[LEXICON.oH];
                  isDirty = currWidth != widthCache || currHeight != heightCache;

                  if (event && isDirty && !rAFId) {
                    COMPATIBILITY.cAF()(rAFId);
                    rAFId = COMPATIBILITY.rAF()(onResized);
                  } else if (!event) onResized();

                  reset();

                  if (event) {
                    COMPATIBILITY.prvD(event);
                    COMPATIBILITY.stpP(event);
                  }

                  return false;
                };

                var expandChildCSS = {};
                var observerElementCSS = {};
                setTopRightBottomLeft(observerElementCSS, _strEmpty, [-((nativeScrollbarSize.y + 1) * factor), nativeScrollbarSize.x * -factor, nativeScrollbarSize.y * -factor, -((nativeScrollbarSize.x + 1) * factor)]);
                FRAMEWORK(observerElement).css(observerElementCSS);
                expandElement.on(_strScroll, onScroll);
                shrinkElement.on(_strScroll, onScroll);
                targetElement.on(strAnimationStartEvent, function () {
                  onScroll(false);
                }); //lets assume that the divs will never be that large and a constant value is enough

                expandChildCSS[_strWidth] = constScroll;
                expandChildCSS[_strHeight] = constScroll;
                expandElementChild.css(expandChildCSS);
                reset();
              } else {
                var attachEvent = _documentElementNative.attachEvent;
                var isIE = _msieVersion !== undefined;

                if (attachEvent) {
                  targetElement.prepend(generateDiv(_classNameResizeObserverElement));
                  findFirst(targetElement, _strDot + _classNameResizeObserverElement)[0].attachEvent('onresize', callback);
                } else {
                  var obj = _documentElementNative.createElement(TYPES.o);

                  obj.setAttribute(LEXICON.ti, '-1');
                  obj.setAttribute(LEXICON.c, _classNameResizeObserverElement);

                  obj.onload = function () {
                    var wnd = this.contentDocument.defaultView;
                    wnd.addEventListener('resize', callback);
                    wnd.document.documentElement.style.display = 'none';
                  };

                  obj.type = 'text/html';
                  if (isIE) targetElement.prepend(obj);
                  obj.data = 'about:blank';
                  if (!isIE) targetElement.prepend(obj);
                  targetElement.on(strAnimationStartEvent, callback);
                }
              }
            }

            if (targetElement[0] === _sizeObserverElementNative) {
              var directionChanged = function () {
                var dir = _hostElement.css('direction');

                var css = {};
                var scrollLeftValue = 0;
                var result = false;

                if (dir !== _cssDirectionDetectedCache) {
                  if (dir === 'ltr') {
                    css[_strLeft] = 0;
                    css[_strRight] = _strAuto;
                    scrollLeftValue = constScroll;
                  } else {
                    css[_strLeft] = _strAuto;
                    css[_strRight] = 0;
                    scrollLeftValue = _rtlScrollBehavior.n ? -constScroll : _rtlScrollBehavior.i ? 0 : constScroll;
                  } //execution order is important for IE!!!


                  _sizeObserverElement.children().eq(0).css(css);

                  _sizeObserverElement[_strScrollLeft](scrollLeftValue)[_strScrollTop](constScroll);

                  _cssDirectionDetectedCache = dir;
                  result = true;
                }

                return result;
              };

              directionChanged();
              addDestroyEventListener(targetElement, _strScroll, function (event) {
                if (directionChanged()) update();
                COMPATIBILITY.prvD(event);
                COMPATIBILITY.stpP(event);
                return false;
              });
            }
          } //remove resize observer:
          else {
              if (_supportResizeObserver) {
                var element = targetElement.contents()[0];
                var resizeObserverObj = element[_strResizeObserverProperty];

                if (resizeObserverObj) {
                  resizeObserverObj.disconnect();
                  delete element[_strResizeObserverProperty];
                }
              } else {
                remove(targetElement.children(_strDot + _classNameResizeObserverElement).eq(0));
              }
            }
        }
      }
      /**
       * Freezes or unfreezes the given resize observer.
       * @param targetElement The element to which the target resize observer is applied.
       * @param freeze True if the resize observer shall be frozen, false otherwise.
       
      function freezeResizeObserver(targetElement, freeze) {
          if (targetElement !== undefined) {
              if(freeze) {
                  if (_supportResizeObserver) {
                      var element = targetElement.contents()[0];
                      element[_strResizeObserverProperty].unobserve(element);
                  }
                  else {
                      targetElement = targetElement.children(_strDot + _classNameResizeObserverElement).eq(0);
                      var w = targetElement.css(_strWidth);
                      var h = targetElement.css(_strHeight);
                      var css = {};
                      css[_strWidth] = w;
                      css[_strHeight] = h;
                      targetElement.css(css);
                  }
              }
              else {
                  if (_supportResizeObserver) {
                      var element = targetElement.contents()[0];
                      element[_strResizeObserverProperty].observe(element);
                  }
                  else {
                      var css = { };
                      css[_strHeight] = _strEmpty;
                      css[_strWidth] = _strEmpty;
                      targetElement.children(_strDot + _classNameResizeObserverElement).eq(0).css(css);
                  }
              }
          }
      }
      */
      //==== Mutation Observers ====//

      /**
       * Creates MutationObservers for the host and content Element if they are supported.
       */


      function createMutationObservers() {
        if (_supportMutationObserver) {
          var mutationObserverContentLag = 11;
          var mutationObserver = COMPATIBILITY.mO();
          var contentLastUpdate = COMPATIBILITY.now();
          var mutationTarget;
          var mutationAttrName;
          var mutationIsClass;
          var oldMutationVal;
          var newClassVal;
          var hostClassNameRegex;
          var contentTimeout;
          var now;
          var sizeAuto;
          var action;

          _mutationObserverHostCallback = function (mutations) {
            var doUpdate = false;
            var doUpdateForce = false;
            var mutation;
            var mutatedAttrs = [];

            if (_initialized && !_sleeping) {
              each(mutations, function () {
                mutation = this;
                mutationTarget = mutation.target;
                mutationAttrName = mutation.attributeName;
                mutationIsClass = mutationAttrName === LEXICON.c;
                oldMutationVal = mutation.oldValue;
                newClassVal = mutationTarget.className;

                if (_domExists && mutationIsClass && !doUpdateForce) {
                  // if old class value contains _classNameHostElementForeign and new class value doesn't
                  if (oldMutationVal.indexOf(_classNameHostElementForeign) > -1 && newClassVal.indexOf(_classNameHostElementForeign) < 0) {
                    hostClassNameRegex = createHostClassNameRegExp(true);
                    _hostElementNative.className = newClassVal.split(_strSpace).concat(oldMutationVal.split(_strSpace).filter(function (name) {
                      return name.match(hostClassNameRegex);
                    })).join(_strSpace);
                    doUpdate = doUpdateForce = true;
                  }
                }

                if (!doUpdate) {
                  doUpdate = mutationIsClass ? hostClassNamesChanged(oldMutationVal, newClassVal) : mutationAttrName === LEXICON.s ? oldMutationVal !== mutationTarget[LEXICON.s].cssText : true;
                }

                mutatedAttrs.push(mutationAttrName);
              });
              updateViewportAttrsFromTarget(mutatedAttrs);
              if (doUpdate) _base.update(doUpdateForce || _strAuto);
            }

            return doUpdate;
          };

          _mutationObserverContentCallback = function (mutations) {
            var doUpdate = false;
            var mutation;

            if (_initialized && !_sleeping) {
              each(mutations, function () {
                mutation = this;
                doUpdate = isUnknownMutation(mutation);
                return !doUpdate;
              });

              if (doUpdate) {
                now = COMPATIBILITY.now();
                sizeAuto = _heightAutoCache || _widthAutoCache;

                action = function () {
                  if (!_destroyed) {
                    contentLastUpdate = now; //if cols, rows or wrap attr was changed

                    if (_isTextarea) textareaUpdate();
                    if (sizeAuto) update();else _base.update(_strAuto);
                  }
                };

                clearTimeout(contentTimeout);
                if (mutationObserverContentLag <= 0 || now - contentLastUpdate > mutationObserverContentLag || !sizeAuto) action();else contentTimeout = setTimeout(action, mutationObserverContentLag);
              }
            }

            return doUpdate;
          };

          _mutationObserverHost = new mutationObserver(_mutationObserverHostCallback);
          _mutationObserverContent = new mutationObserver(_mutationObserverContentCallback);
        }
      }
      /**
       * Connects the MutationObservers if they are supported.
       */


      function connectMutationObservers() {
        if (_supportMutationObserver && !_mutationObserversConnected) {
          _mutationObserverHost.observe(_hostElementNative, {
            attributes: true,
            attributeOldValue: true,
            attributeFilter: _mutationObserverAttrsHost
          });

          _mutationObserverContent.observe(_isTextarea ? _targetElementNative : _contentElementNative, {
            attributes: true,
            attributeOldValue: true,
            subtree: !_isTextarea,
            childList: !_isTextarea,
            characterData: !_isTextarea,
            attributeFilter: _isTextarea ? _mutationObserverAttrsTextarea : _mutationObserverAttrsHost
          });

          _mutationObserversConnected = true;
        }
      }
      /**
       * Disconnects the MutationObservers if they are supported.
       */


      function disconnectMutationObservers() {
        if (_supportMutationObserver && _mutationObserversConnected) {
          _mutationObserverHost.disconnect();

          _mutationObserverContent.disconnect();

          _mutationObserversConnected = false;
        }
      } //==== Events of elements ====//

      /**
       * This method gets called every time the host element gets resized. IMPORTANT: Padding changes are detected too!!
       * It refreshes the hostResizedEventArgs and the hostSizeResizeCache.
       * If there are any size changes, the update method gets called.
       */


      function hostOnResized() {
        if (!_sleeping) {
          var changed;
          var hostSize = {
            w: _sizeObserverElementNative[LEXICON.sW],
            h: _sizeObserverElementNative[LEXICON.sH]
          };
          changed = checkCache(hostSize, _hostElementSizeChangeDetectedCache);
          _hostElementSizeChangeDetectedCache = hostSize;
          if (changed) update({
            _hostSizeChanged: true
          });
        }
      }
      /**
       * The mouse enter event of the host element. This event is only needed for the autoHide feature.
       */


      function hostOnMouseEnter() {
        if (_scrollbarsAutoHideLeave) refreshScrollbarsAutoHide(true);
      }
      /**
       * The mouse leave event of the host element. This event is only needed for the autoHide feature.
       */


      function hostOnMouseLeave() {
        if (_scrollbarsAutoHideLeave && !_bodyElement.hasClass(_classNameDragging)) refreshScrollbarsAutoHide(false);
      }
      /**
       * The mouse move event of the host element. This event is only needed for the autoHide "move" feature.
       */


      function hostOnMouseMove() {
        if (_scrollbarsAutoHideMove) {
          refreshScrollbarsAutoHide(true);
          clearTimeout(_scrollbarsAutoHideMoveTimeoutId);
          _scrollbarsAutoHideMoveTimeoutId = setTimeout(function () {
            if (_scrollbarsAutoHideMove && !_destroyed) refreshScrollbarsAutoHide(false);
          }, 100);
        }
      }
      /**
       * Prevents text from deselection if attached to the document element on the mousedown event of a DOM element.
       * @param event The select start event.
       */


      function documentOnSelectStart(event) {
        COMPATIBILITY.prvD(event);
        return false;
      }
      /**	
       * A callback which will be called after a element has loaded.	
       */


      function updateOnLoadCallback(event) {
        var elm = FRAMEWORK(event.target);
        eachUpdateOnLoad(function (i, updateOnLoadSelector) {
          if (elm.is(updateOnLoadSelector)) {
            update({
              _contentSizeChanged: true
            });
          }
        });
      }
      /**
      * Adds or removes mouse & touch events of the host element. (for handling auto-hiding of the scrollbars)
      * @param destroy Indicates whether the events shall be added or removed.
      */


      function setupHostMouseTouchEvents(destroy) {
        if (!destroy) setupHostMouseTouchEvents(true);
        setupResponsiveEventListener(_hostElement, _strMouseTouchMoveEvent.split(_strSpace)[0], hostOnMouseMove, !_scrollbarsAutoHideMove || destroy, true);
        setupResponsiveEventListener(_hostElement, [_strMouseEnter, _strMouseLeave], [hostOnMouseEnter, hostOnMouseLeave], !_scrollbarsAutoHideLeave || destroy, true); //if the plugin is initialized and the mouse is over the host element, make the scrollbars visible

        if (!_initialized && !destroy) _hostElement.one('mouseover', hostOnMouseEnter);
      } //==== Update Detection ====//

      /**
       * Measures the min width and min height of the body element and refreshes the related cache.
       * @returns {boolean} True if the min width or min height has changed, false otherwise.
       */


      function bodyMinSizeChanged() {
        var bodyMinSize = {};

        if (_isBody && _contentArrangeElement) {
          bodyMinSize.w = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strWidth));
          bodyMinSize.h = parseToZeroOrNumber(_contentArrangeElement.css(_strMinMinus + _strHeight));
          bodyMinSize.c = checkCache(bodyMinSize, _bodyMinSizeCache);
          bodyMinSize.f = true; //flag for "measured at least once"
        }

        _bodyMinSizeCache = bodyMinSize;
        return !!bodyMinSize.c;
      }
      /**
       * Returns true if the class names really changed (new class without plugin host prefix)
       * @param oldClassNames The old ClassName string or array.
       * @param newClassNames The new ClassName string or array.
       * @returns {boolean} True if the class names has really changed, false otherwise.
       */


      function hostClassNamesChanged(oldClassNames, newClassNames) {
        var currClasses = typeof newClassNames == TYPES.s ? newClassNames.split(_strSpace) : [];
        var oldClasses = typeof oldClassNames == TYPES.s ? oldClassNames.split(_strSpace) : [];
        var diff = getArrayDifferences(oldClasses, currClasses); // remove none theme from diff list to prevent update

        var idx = inArray(_classNameThemeNone, diff);
        var i;
        var regex;
        if (idx > -1) diff.splice(idx, 1);

        if (diff[LEXICON.l] > 0) {
          regex = createHostClassNameRegExp(true, true);

          for (i = 0; i < diff.length; i++) {
            if (!diff[i].match(regex)) {
              return true;
            }
          }
        }

        return false;
      }
      /**
       * Returns true if the given mutation is not from a from the plugin generated element. If the target element is a textarea the mutation is always unknown.
       * @param mutation The mutation which shall be checked.
       * @returns {boolean} True if the mutation is from a unknown element, false otherwise.
       */


      function isUnknownMutation(mutation) {
        var attributeName = mutation.attributeName;
        var mutationTarget = mutation.target;
        var mutationType = mutation.type;
        var strClosest = 'closest';
        if (mutationTarget === _contentElementNative) return attributeName === null;

        if (mutationType === 'attributes' && (attributeName === LEXICON.c || attributeName === LEXICON.s) && !_isTextarea) {
          //ignore className changes by the plugin	
          if (attributeName === LEXICON.c && FRAMEWORK(mutationTarget).hasClass(_classNameHostElement)) return hostClassNamesChanged(mutation.oldValue, mutationTarget.className); //only do it of browser support it natively	

          if (typeof mutationTarget[strClosest] != TYPES.f) return true;
          if (mutationTarget[strClosest](_strDot + _classNameResizeObserverElement) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbar) !== null || mutationTarget[strClosest](_strDot + _classNameScrollbarCorner) !== null) return false;
        }

        return true;
      }
      /**
       * Returns true if the content size was changed since the last time this method was called.
       * @returns {boolean} True if the content size was changed, false otherwise.
       */


      function updateAutoContentSizeChanged() {
        if (_sleeping) return false;
        var contentMeasureElement = getContentMeasureElement();
        var textareaValueLength = _isTextarea && _widthAutoCache && !_textareaAutoWrappingCache ? _targetElement.val().length : 0;
        var setCSS = !_mutationObserversConnected && _widthAutoCache && !_isTextarea;
        var css = {};
        var float;
        var bodyMinSizeC;
        var changed;
        var contentElementScrollSize;

        if (setCSS) {
          float = _contentElement.css(_strFloat);
          css[_strFloat] = _isRTL ? _strRight : _strLeft;
          css[_strWidth] = _strAuto;

          _contentElement.css(css);
        }

        contentElementScrollSize = {
          w: contentMeasureElement[LEXICON.sW] + textareaValueLength,
          h: contentMeasureElement[LEXICON.sH] + textareaValueLength
        };

        if (setCSS) {
          css[_strFloat] = float;
          css[_strWidth] = _strHundredPercent;

          _contentElement.css(css);
        }

        bodyMinSizeC = bodyMinSizeChanged();
        changed = checkCache(contentElementScrollSize, _contentElementScrollSizeChangeDetectedCache);
        _contentElementScrollSizeChangeDetectedCache = contentElementScrollSize;
        return changed || bodyMinSizeC;
      }
      /**
       * Returns true when a attribute which the MutationObserver would observe has changed.  
       * @returns {boolean} True if one of the attributes which a MutationObserver would observe has changed, false or undefined otherwise.
       */


      function meaningfulAttrsChanged() {
        if (_sleeping || _mutationObserversConnected) return;
        var elem;
        var curr;
        var cache;
        var changedAttrs = [];
        var checks = [{
          _elem: _hostElement,
          _attrs: _mutationObserverAttrsHost.concat(':visible')
        }, {
          _elem: _isTextarea ? _targetElement : undefined,
          _attrs: _mutationObserverAttrsTextarea
        }];
        each(checks, function (index, check) {
          elem = check._elem;

          if (elem) {
            each(check._attrs, function (index, attr) {
              curr = attr.charAt(0) === ':' ? elem.is(attr) : elem.attr(attr);
              cache = _updateAutoCache[attr];

              if (checkCache(curr, cache)) {
                changedAttrs.push(attr);
              }

              _updateAutoCache[attr] = curr;
            });
          }
        });
        updateViewportAttrsFromTarget(changedAttrs);
        return changedAttrs[LEXICON.l] > 0;
      }
      /**
       * Checks is a CSS Property of a child element is affecting the scroll size of the content.
       * @param propertyName The CSS property name.
       * @returns {boolean} True if the property is affecting the content scroll size, false otherwise.
       */


      function isSizeAffectingCSSProperty(propertyName) {
        if (!_initialized) return true;
        var flexGrow = 'flex-grow';
        var flexShrink = 'flex-shrink';
        var flexBasis = 'flex-basis';
        var affectingPropsX = [_strWidth, _strMinMinus + _strWidth, _strMaxMinus + _strWidth, _strMarginMinus + _strLeft, _strMarginMinus + _strRight, _strLeft, _strRight, 'font-weight', 'word-spacing', flexGrow, flexShrink, flexBasis];
        var affectingPropsXContentBox = [_strPaddingMinus + _strLeft, _strPaddingMinus + _strRight, _strBorderMinus + _strLeft + _strWidth, _strBorderMinus + _strRight + _strWidth];
        var affectingPropsY = [_strHeight, _strMinMinus + _strHeight, _strMaxMinus + _strHeight, _strMarginMinus + _strTop, _strMarginMinus + _strBottom, _strTop, _strBottom, 'line-height', flexGrow, flexShrink, flexBasis];
        var affectingPropsYContentBox = [_strPaddingMinus + _strTop, _strPaddingMinus + _strBottom, _strBorderMinus + _strTop + _strWidth, _strBorderMinus + _strBottom + _strWidth];
        var _strS = 's';
        var _strVS = 'v-s';
        var checkX = _overflowBehaviorCache.x === _strS || _overflowBehaviorCache.x === _strVS;
        var checkY = _overflowBehaviorCache.y === _strS || _overflowBehaviorCache.y === _strVS;
        var sizeIsAffected = false;

        var checkPropertyName = function (arr, name) {
          for (var i = 0; i < arr[LEXICON.l]; i++) {
            if (arr[i] === name) return true;
          }

          return false;
        };

        if (checkY) {
          sizeIsAffected = checkPropertyName(affectingPropsY, propertyName);
          if (!sizeIsAffected && !_isBorderBox) sizeIsAffected = checkPropertyName(affectingPropsYContentBox, propertyName);
        }

        if (checkX && !sizeIsAffected) {
          sizeIsAffected = checkPropertyName(affectingPropsX, propertyName);
          if (!sizeIsAffected && !_isBorderBox) sizeIsAffected = checkPropertyName(affectingPropsXContentBox, propertyName);
        }

        return sizeIsAffected;
      } //==== Update ====//

      /**
       * Sets the attribute values of the viewport element to the values from the target element.
       * The value of a attribute is only set if the attribute is whitelisted.
       * @attrs attrs The array of attributes which shall be set or undefined if all whitelisted shall be set.
       */


      function updateViewportAttrsFromTarget(attrs) {
        attrs = attrs || _viewportAttrsFromTarget;
        each(attrs, function (index, attr) {
          if (COMPATIBILITY.inA(attr, _viewportAttrsFromTarget) > -1) {
            var targetAttr = _targetElement.attr(attr);

            if (type(targetAttr) == TYPES.s) {
              _viewportElement.attr(attr, targetAttr);
            } else {
              _viewportElement.removeAttr(attr);
            }
          }
        });
      }
      /**
       * Updates the variables and size of the textarea element, and manages the scroll on new line or new character.
       */


      function textareaUpdate() {
        if (!_sleeping) {
          var wrapAttrOff = !_textareaAutoWrappingCache;
          var minWidth = _viewportSize.w;
          var minHeight = _viewportSize.h;
          var css = {};
          var doMeasure = _widthAutoCache || wrapAttrOff;
          var origWidth;
          var width;
          var origHeight;
          var height; //reset min size

          css[_strMinMinus + _strWidth] = _strEmpty;
          css[_strMinMinus + _strHeight] = _strEmpty; //set width auto

          css[_strWidth] = _strAuto;

          _targetElement.css(css); //measure width


          origWidth = _targetElementNative[LEXICON.oW];
          width = doMeasure ? MATH.max(origWidth, _targetElementNative[LEXICON.sW] - 1) : 1;
          /*width += (_widthAutoCache ? _marginX + (!_isBorderBox ? wrapAttrOff ? 0 : _paddingX + _borderX : 0) : 0);*/
          //set measured width

          css[_strWidth] = _widthAutoCache ? _strAuto
          /*width*/
          : _strHundredPercent;
          css[_strMinMinus + _strWidth] = _strHundredPercent; //set height auto

          css[_strHeight] = _strAuto;

          _targetElement.css(css); //measure height


          origHeight = _targetElementNative[LEXICON.oH];
          height = MATH.max(origHeight, _targetElementNative[LEXICON.sH] - 1); //append correct size values

          css[_strWidth] = width;
          css[_strHeight] = height;

          _textareaCoverElement.css(css); //apply min width / min height to prevent textarea collapsing


          css[_strMinMinus + _strWidth] = minWidth
          /*+ (!_isBorderBox && _widthAutoCache ? _paddingX + _borderX : 0)*/
          ;
          css[_strMinMinus + _strHeight] = minHeight
          /*+ (!_isBorderBox && _heightAutoCache ? _paddingY + _borderY : 0)*/
          ;

          _targetElement.css(css);

          return {
            _originalWidth: origWidth,
            _originalHeight: origHeight,
            _dynamicWidth: width,
            _dynamicHeight: height
          };
        }
      }
      /**
       * Updates the plugin and DOM to the current options.
       * This method should only be called if a update is 100% required.
       * @param updateHints A objects which contains hints for this update:
       * {
       *   _hostSizeChanged : boolean,
       *   _contentSizeChanged : boolean,
       *   _force : boolean,                             == preventSwallowing
       *   _changedOptions : { },                        == preventSwallowing && preventSleep
      *  }
       */


      function update(updateHints) {
        clearTimeout(_swallowedUpdateTimeout);
        updateHints = updateHints || {};
        _swallowedUpdateHints._hostSizeChanged |= updateHints._hostSizeChanged;
        _swallowedUpdateHints._contentSizeChanged |= updateHints._contentSizeChanged;
        _swallowedUpdateHints._force |= updateHints._force;
        var now = COMPATIBILITY.now();
        var hostSizeChanged = !!_swallowedUpdateHints._hostSizeChanged;
        var contentSizeChanged = !!_swallowedUpdateHints._contentSizeChanged;
        var force = !!_swallowedUpdateHints._force;
        var changedOptions = updateHints._changedOptions;
        var swallow = _swallowUpdateLag > 0 && _initialized && !_destroyed && !force && !changedOptions && now - _lastUpdateTime < _swallowUpdateLag && !_heightAutoCache && !_widthAutoCache;
        var displayIsHidden;
        if (swallow) _swallowedUpdateTimeout = setTimeout(update, _swallowUpdateLag); //abort update due to:
        //destroyed
        //swallowing
        //sleeping
        //host is hidden or has false display

        if (_destroyed || swallow || _sleeping && !changedOptions || _initialized && !force && (displayIsHidden = _hostElement.is(':hidden')) || _hostElement.css('display') === 'inline') return;
        _lastUpdateTime = now;
        _swallowedUpdateHints = {}; //if scrollbar styling is possible and native scrollbars aren't overlaid the scrollbar styling will be applied which hides the native scrollbars completely.

        if (_nativeScrollbarStyling && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
          //native scrollbars are hidden, so change the values to zero
          _nativeScrollbarSize.x = 0;
          _nativeScrollbarSize.y = 0;
        } else {
          //refresh native scrollbar size (in case of zoom)
          _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
        } // Scrollbar padding is needed for firefox, because firefox hides scrollbar automatically if the size of the div is too small.
        // The calculation: [scrollbar size +3 *3]
        // (+3 because of possible decoration e.g. borders, margins etc., but only if native scrollbar is NOT a overlaid scrollbar)
        // (*3 because (1)increase / (2)decrease -button and (3)resize handle)


        _nativeScrollbarMinSize = {
          x: (_nativeScrollbarSize.x + (_nativeScrollbarIsOverlaid.x ? 0 : 3)) * 3,
          y: (_nativeScrollbarSize.y + (_nativeScrollbarIsOverlaid.y ? 0 : 3)) * 3
        };
        changedOptions = changedOptions || {}; //freezeResizeObserver(_sizeObserverElement, true);
        //freezeResizeObserver(_sizeAutoObserverElement, true);

        var checkCacheAutoForce = function () {
          return checkCache.apply(this, [].slice.call(arguments).concat([force]));
        }; //save current scroll offset


        var currScroll = {
          x: _viewportElement[_strScrollLeft](),
          y: _viewportElement[_strScrollTop]()
        };
        var currentPreparedOptionsScrollbars = _currentPreparedOptions.scrollbars;
        var currentPreparedOptionsTextarea = _currentPreparedOptions.textarea; //scrollbars visibility:

        var scrollbarsVisibility = currentPreparedOptionsScrollbars.visibility;
        var scrollbarsVisibilityChanged = checkCacheAutoForce(scrollbarsVisibility, _scrollbarsVisibilityCache); //scrollbars autoHide:

        var scrollbarsAutoHide = currentPreparedOptionsScrollbars.autoHide;
        var scrollbarsAutoHideChanged = checkCacheAutoForce(scrollbarsAutoHide, _scrollbarsAutoHideCache); //scrollbars click scrolling

        var scrollbarsClickScrolling = currentPreparedOptionsScrollbars.clickScrolling;
        var scrollbarsClickScrollingChanged = checkCacheAutoForce(scrollbarsClickScrolling, _scrollbarsClickScrollingCache); //scrollbars drag scrolling

        var scrollbarsDragScrolling = currentPreparedOptionsScrollbars.dragScrolling;
        var scrollbarsDragScrollingChanged = checkCacheAutoForce(scrollbarsDragScrolling, _scrollbarsDragScrollingCache); //className

        var className = _currentPreparedOptions.className;
        var classNameChanged = checkCacheAutoForce(className, _classNameCache); //resize

        var resize = _currentPreparedOptions.resize;
        var resizeChanged = checkCacheAutoForce(resize, _resizeCache) && !_isBody; //body can't be resized since the window itself acts as resize possibility.
        //paddingAbsolute

        var paddingAbsolute = _currentPreparedOptions.paddingAbsolute;
        var paddingAbsoluteChanged = checkCacheAutoForce(paddingAbsolute, _paddingAbsoluteCache); //clipAlways

        var clipAlways = _currentPreparedOptions.clipAlways;
        var clipAlwaysChanged = checkCacheAutoForce(clipAlways, _clipAlwaysCache); //sizeAutoCapable

        var sizeAutoCapable = _currentPreparedOptions.sizeAutoCapable && !_isBody; //body can never be size auto, because it shall be always as big as the viewport.

        var sizeAutoCapableChanged = checkCacheAutoForce(sizeAutoCapable, _sizeAutoCapableCache); //showNativeScrollbars

        var ignoreOverlayScrollbarHiding = _currentPreparedOptions.nativeScrollbarsOverlaid.showNativeScrollbars;
        var ignoreOverlayScrollbarHidingChanged = checkCacheAutoForce(ignoreOverlayScrollbarHiding, _ignoreOverlayScrollbarHidingCache); //autoUpdate

        var autoUpdate = _currentPreparedOptions.autoUpdate;
        var autoUpdateChanged = checkCacheAutoForce(autoUpdate, _autoUpdateCache); //overflowBehavior

        var overflowBehavior = _currentPreparedOptions.overflowBehavior;
        var overflowBehaviorChanged = checkCacheAutoForce(overflowBehavior, _overflowBehaviorCache, force); //dynWidth:

        var textareaDynWidth = currentPreparedOptionsTextarea.dynWidth;
        var textareaDynWidthChanged = checkCacheAutoForce(_textareaDynWidthCache, textareaDynWidth); //dynHeight:

        var textareaDynHeight = currentPreparedOptionsTextarea.dynHeight;
        var textareaDynHeightChanged = checkCacheAutoForce(_textareaDynHeightCache, textareaDynHeight); //scrollbars visibility

        _scrollbarsAutoHideNever = scrollbarsAutoHide === 'n';
        _scrollbarsAutoHideScroll = scrollbarsAutoHide === 's';
        _scrollbarsAutoHideMove = scrollbarsAutoHide === 'm';
        _scrollbarsAutoHideLeave = scrollbarsAutoHide === 'l'; //scrollbars autoHideDelay

        _scrollbarsAutoHideDelay = currentPreparedOptionsScrollbars.autoHideDelay; //old className

        _oldClassName = _classNameCache; //resize

        _resizeNone = resize === 'n';
        _resizeBoth = resize === 'b';
        _resizeHorizontal = resize === 'h';
        _resizeVertical = resize === 'v'; //normalizeRTL

        _normalizeRTLCache = _currentPreparedOptions.normalizeRTL; //ignore overlay scrollbar hiding

        ignoreOverlayScrollbarHiding = ignoreOverlayScrollbarHiding && _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y; //refresh options cache

        _scrollbarsVisibilityCache = scrollbarsVisibility;
        _scrollbarsAutoHideCache = scrollbarsAutoHide;
        _scrollbarsClickScrollingCache = scrollbarsClickScrolling;
        _scrollbarsDragScrollingCache = scrollbarsDragScrolling;
        _classNameCache = className;
        _resizeCache = resize;
        _paddingAbsoluteCache = paddingAbsolute;
        _clipAlwaysCache = clipAlways;
        _sizeAutoCapableCache = sizeAutoCapable;
        _ignoreOverlayScrollbarHidingCache = ignoreOverlayScrollbarHiding;
        _autoUpdateCache = autoUpdate;
        _overflowBehaviorCache = extendDeep({}, overflowBehavior);
        _textareaDynWidthCache = textareaDynWidth;
        _textareaDynHeightCache = textareaDynHeight;
        _hasOverflowCache = _hasOverflowCache || {
          x: false,
          y: false
        }; //set correct class name to the host element

        if (classNameChanged) {
          removeClass(_hostElement, _oldClassName + _strSpace + _classNameThemeNone);
          addClass(_hostElement, className !== undefined && className !== null && className.length > 0 ? className : _classNameThemeNone);
        } //set correct auto Update


        if (autoUpdateChanged) {
          if (autoUpdate === true || autoUpdate === null && _autoUpdateRecommended) {
            disconnectMutationObservers();
            autoUpdateLoop.add(_base);
          } else {
            autoUpdateLoop.remove(_base);
            connectMutationObservers();
          }
        } //activate or deactivate size auto capability


        if (sizeAutoCapableChanged) {
          if (sizeAutoCapable) {
            if (_contentGlueElement) {
              _contentGlueElement.show();
            } else {
              _contentGlueElement = FRAMEWORK(generateDiv(_classNameContentGlueElement));

              _paddingElement.before(_contentGlueElement);
            }

            if (_sizeAutoObserverAdded) {
              _sizeAutoObserverElement.show();
            } else {
              _sizeAutoObserverElement = FRAMEWORK(generateDiv(_classNameSizeAutoObserverElement));
              _sizeAutoObserverElementNative = _sizeAutoObserverElement[0];

              _contentGlueElement.before(_sizeAutoObserverElement);

              var oldSize = {
                w: -1,
                h: -1
              };
              setupResizeObserver(_sizeAutoObserverElement, function () {
                var newSize = {
                  w: _sizeAutoObserverElementNative[LEXICON.oW],
                  h: _sizeAutoObserverElementNative[LEXICON.oH]
                };

                if (checkCache(newSize, oldSize)) {
                  if (_initialized && _heightAutoCache && newSize.h > 0 || _widthAutoCache && newSize.w > 0) {
                    update();
                  } else if (_initialized && !_heightAutoCache && newSize.h === 0 || !_widthAutoCache && newSize.w === 0) {
                    update();
                  }
                }

                oldSize = newSize;
              });
              _sizeAutoObserverAdded = true; //fix heightAuto detector bug if height is fixed but contentHeight is 0.
              //the probability this bug will ever happen is very very low, thats why its ok if we use calc which isn't supported in IE8.

              if (_cssCalc !== null) _sizeAutoObserverElement.css(_strHeight, _cssCalc + '(100% + 1px)');
            }
          } else {
            if (_sizeAutoObserverAdded) _sizeAutoObserverElement.hide();
            if (_contentGlueElement) _contentGlueElement.hide();
          }
        } //if force, update all resizeObservers too


        if (force) {
          _sizeObserverElement.find('*').trigger(_strScroll);

          if (_sizeAutoObserverAdded) _sizeAutoObserverElement.find('*').trigger(_strScroll);
        } //display hidden:


        displayIsHidden = displayIsHidden === undefined ? _hostElement.is(':hidden') : displayIsHidden; //textarea AutoWrapping:

        var textareaAutoWrapping = _isTextarea ? _targetElement.attr('wrap') !== 'off' : false;
        var textareaAutoWrappingChanged = checkCacheAutoForce(textareaAutoWrapping, _textareaAutoWrappingCache); //detect direction:

        var cssDirection = _hostElement.css('direction');

        var cssDirectionChanged = checkCacheAutoForce(cssDirection, _cssDirectionCache); //detect box-sizing:

        var boxSizing = _hostElement.css('box-sizing');

        var boxSizingChanged = checkCacheAutoForce(boxSizing, _cssBoxSizingCache); //detect padding:

        var padding = getTopRightBottomLeftHost(_strPaddingMinus); //width + height auto detecting var:

        var sizeAutoObserverElementBCRect; //exception occurs in IE8 sometimes (unknown exception)

        try {
          sizeAutoObserverElementBCRect = _sizeAutoObserverAdded ? _sizeAutoObserverElementNative[LEXICON.bCR]() : null;
        } catch (ex) {
          return;
        }

        _isRTL = cssDirection === 'rtl';
        _isBorderBox = boxSizing === 'border-box';
        var isRTLLeft = _isRTL ? _strLeft : _strRight;
        var isRTLRight = _isRTL ? _strRight : _strLeft; //detect width auto:

        var widthAutoResizeDetection = false;
        var widthAutoObserverDetection = _sizeAutoObserverAdded && _hostElement.css(_strFloat) !== 'none'
        /*|| _isTextarea */
        ? MATH.round(sizeAutoObserverElementBCRect.right - sizeAutoObserverElementBCRect.left) === 0 && (!paddingAbsolute ? _hostElementNative[LEXICON.cW] - _paddingX > 0 : true) : false;

        if (sizeAutoCapable && !widthAutoObserverDetection) {
          var tmpCurrHostWidth = _hostElementNative[LEXICON.oW];

          var tmpCurrContentGlueWidth = _contentGlueElement.css(_strWidth);

          _contentGlueElement.css(_strWidth, _strAuto);

          var tmpNewHostWidth = _hostElementNative[LEXICON.oW];

          _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);

          widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;

          if (!widthAutoResizeDetection) {
            _contentGlueElement.css(_strWidth, tmpCurrHostWidth + 1);

            tmpNewHostWidth = _hostElementNative[LEXICON.oW];

            _contentGlueElement.css(_strWidth, tmpCurrContentGlueWidth);

            widthAutoResizeDetection = tmpCurrHostWidth !== tmpNewHostWidth;
          }
        }

        var widthAuto = (widthAutoObserverDetection || widthAutoResizeDetection) && sizeAutoCapable && !displayIsHidden;
        var widthAutoChanged = checkCacheAutoForce(widthAuto, _widthAutoCache);
        var wasWidthAuto = !widthAuto && _widthAutoCache; //detect height auto:

        var heightAuto = _sizeAutoObserverAdded && sizeAutoCapable && !displayIsHidden ? MATH.round(sizeAutoObserverElementBCRect.bottom - sizeAutoObserverElementBCRect.top) === 0 :
        /* && (!paddingAbsolute && (_msieVersion > 9 || !_msieVersion) ? true : true) */
        false;
        var heightAutoChanged = checkCacheAutoForce(heightAuto, _heightAutoCache);
        var wasHeightAuto = !heightAuto && _heightAutoCache; //detect border:
        //we need the border only if border box and auto size

        var updateBorderX = widthAuto && _isBorderBox || !_isBorderBox;
        var updateBorderY = heightAuto && _isBorderBox || !_isBorderBox;
        var border = getTopRightBottomLeftHost(_strBorderMinus, '-' + _strWidth, !updateBorderX, !updateBorderY); //detect margin:

        var margin = getTopRightBottomLeftHost(_strMarginMinus); //vars to apply correct css

        var contentElementCSS = {};
        var contentGlueElementCSS = {}; //funcs

        var getHostSize = function () {
          //has to be clientSize because offsetSize respect borders
          return {
            w: _hostElementNative[LEXICON.cW],
            h: _hostElementNative[LEXICON.cH]
          };
        };

        var getViewportSize = function () {
          //viewport size is padding container because it never has padding, margin and a border
          //determine zoom rounding error -> sometimes scrollWidth/Height is smaller than clientWidth/Height
          //if this happens add the difference to the viewportSize to compensate the rounding error
          return {
            w: _paddingElementNative[LEXICON.oW] + MATH.max(0, _contentElementNative[LEXICON.cW] - _contentElementNative[LEXICON.sW]),
            h: _paddingElementNative[LEXICON.oH] + MATH.max(0, _contentElementNative[LEXICON.cH] - _contentElementNative[LEXICON.sH])
          };
        }; //set info for padding


        var paddingAbsoluteX = _paddingX = padding.l + padding.r;
        var paddingAbsoluteY = _paddingY = padding.t + padding.b;
        paddingAbsoluteX *= paddingAbsolute ? 1 : 0;
        paddingAbsoluteY *= paddingAbsolute ? 1 : 0;
        padding.c = checkCacheAutoForce(padding, _cssPaddingCache); //set info for border

        _borderX = border.l + border.r;
        _borderY = border.t + border.b;
        border.c = checkCacheAutoForce(border, _cssBorderCache); //set info for margin

        _marginX = margin.l + margin.r;
        _marginY = margin.t + margin.b;
        margin.c = checkCacheAutoForce(margin, _cssMarginCache); //refresh cache

        _textareaAutoWrappingCache = textareaAutoWrapping;
        _cssDirectionCache = cssDirection;
        _cssBoxSizingCache = boxSizing;
        _widthAutoCache = widthAuto;
        _heightAutoCache = heightAuto;
        _cssPaddingCache = padding;
        _cssBorderCache = border;
        _cssMarginCache = margin; //IEFix direction changed

        if (cssDirectionChanged && _sizeAutoObserverAdded) _sizeAutoObserverElement.css(_strFloat, isRTLRight); //apply padding:

        if (padding.c || cssDirectionChanged || paddingAbsoluteChanged || widthAutoChanged || heightAutoChanged || boxSizingChanged || sizeAutoCapableChanged) {
          var paddingElementCSS = {};
          var textareaCSS = {};
          var paddingValues = [padding.t, padding.r, padding.b, padding.l];
          setTopRightBottomLeft(contentGlueElementCSS, _strMarginMinus, [-padding.t, -padding.r, -padding.b, -padding.l]);

          if (paddingAbsolute) {
            setTopRightBottomLeft(paddingElementCSS, _strEmpty, paddingValues);
            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus);
          } else {
            setTopRightBottomLeft(paddingElementCSS, _strEmpty);
            setTopRightBottomLeft(_isTextarea ? textareaCSS : contentElementCSS, _strPaddingMinus, paddingValues);
          }

          _paddingElement.css(paddingElementCSS);

          _targetElement.css(textareaCSS);
        } //viewport size is padding container because it never has padding, margin and a border.


        _viewportSize = getViewportSize(); //update Textarea

        var textareaSize = _isTextarea ? textareaUpdate() : false;

        var textareaSizeChanged = _isTextarea && checkCacheAutoForce(textareaSize, _textareaSizeCache);

        var textareaDynOrigSize = _isTextarea && textareaSize ? {
          w: textareaDynWidth ? textareaSize._dynamicWidth : textareaSize._originalWidth,
          h: textareaDynHeight ? textareaSize._dynamicHeight : textareaSize._originalHeight
        } : {};
        _textareaSizeCache = textareaSize; //fix height auto / width auto in cooperation with current padding & boxSizing behavior:

        if (heightAuto && (heightAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c)) {
          contentElementCSS[_strHeight] = _strAuto;
        } else if (heightAutoChanged || paddingAbsoluteChanged) {
          contentElementCSS[_strHeight] = _strHundredPercent;
        }

        if (widthAuto && (widthAutoChanged || paddingAbsoluteChanged || boxSizingChanged || padding.c || border.c || cssDirectionChanged)) {
          contentElementCSS[_strWidth] = _strAuto;
          contentGlueElementCSS[_strMaxMinus + _strWidth] = _strHundredPercent; //IE Fix
        } else if (widthAutoChanged || paddingAbsoluteChanged) {
          contentElementCSS[_strWidth] = _strHundredPercent;
          contentElementCSS[_strFloat] = _strEmpty;
          contentGlueElementCSS[_strMaxMinus + _strWidth] = _strEmpty; //IE Fix
        }

        if (widthAuto) {
          //textareaDynOrigSize.w || _strAuto :: doesnt works because applied margin will shift width
          contentGlueElementCSS[_strWidth] = _strAuto;
          contentElementCSS[_strWidth] = VENDORS._cssPropertyValue(_strWidth, 'max-content intrinsic') || _strAuto;
          contentElementCSS[_strFloat] = isRTLRight;
        } else {
          contentGlueElementCSS[_strWidth] = _strEmpty;
        }

        if (heightAuto) {
          //textareaDynOrigSize.h || _contentElementNative[LEXICON.cH] :: use for anti scroll jumping
          contentGlueElementCSS[_strHeight] = textareaDynOrigSize.h || _contentElementNative[LEXICON.cH];
        } else {
          contentGlueElementCSS[_strHeight] = _strEmpty;
        }

        if (sizeAutoCapable) _contentGlueElement.css(contentGlueElementCSS);

        _contentElement.css(contentElementCSS); //CHECKPOINT HERE ~


        contentElementCSS = {};
        contentGlueElementCSS = {}; //if [content(host) client / scroll size, or target element direction, or content(host) max-sizes] changed, or force is true

        if (hostSizeChanged || contentSizeChanged || textareaSizeChanged || cssDirectionChanged || boxSizingChanged || paddingAbsoluteChanged || widthAutoChanged || widthAuto || heightAutoChanged || heightAuto || ignoreOverlayScrollbarHidingChanged || overflowBehaviorChanged || clipAlwaysChanged || resizeChanged || scrollbarsVisibilityChanged || scrollbarsAutoHideChanged || scrollbarsDragScrollingChanged || scrollbarsClickScrollingChanged || textareaDynWidthChanged || textareaDynHeightChanged || textareaAutoWrappingChanged) {
          var strOverflow = 'overflow';
          var strOverflowX = strOverflow + '-x';
          var strOverflowY = strOverflow + '-y';
          var strHidden = 'hidden';
          var strVisible = 'visible'; //Reset the viewport (very important for natively overlaid scrollbars and zoom change
          //don't change the overflow prop as it is very expensive and affects performance !A LOT!

          if (!_nativeScrollbarStyling) {
            var viewportElementResetCSS = {};
            var resetXTmp = _hasOverflowCache.y && _hideOverflowCache.ys && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.y ? _viewportElement.css(isRTLLeft) : -_nativeScrollbarSize.y : 0;
            var resetBottomTmp = _hasOverflowCache.x && _hideOverflowCache.xs && !ignoreOverlayScrollbarHiding ? _nativeScrollbarIsOverlaid.x ? _viewportElement.css(_strBottom) : -_nativeScrollbarSize.x : 0;
            setTopRightBottomLeft(viewportElementResetCSS, _strEmpty);

            _viewportElement.css(viewportElementResetCSS);
          } //measure several sizes:


          var contentMeasureElement = getContentMeasureElement(); //in Firefox content element has to have overflow hidden, else element margins aren't calculated properly, this element prevents this bug, but only if scrollbars aren't overlaid

          var contentSize = {
            //use clientSize because natively overlaidScrollbars add borders
            w: textareaDynOrigSize.w || contentMeasureElement[LEXICON.cW],
            h: textareaDynOrigSize.h || contentMeasureElement[LEXICON.cH]
          };
          var scrollSize = {
            w: contentMeasureElement[LEXICON.sW],
            h: contentMeasureElement[LEXICON.sH]
          }; //apply the correct viewport style and measure viewport size

          if (!_nativeScrollbarStyling) {
            viewportElementResetCSS[_strBottom] = wasHeightAuto ? _strEmpty : resetBottomTmp;
            viewportElementResetCSS[isRTLLeft] = wasWidthAuto ? _strEmpty : resetXTmp;

            _viewportElement.css(viewportElementResetCSS);
          }

          _viewportSize = getViewportSize(); //measure and correct several sizes

          var hostSize = getHostSize();
          var hostAbsoluteRectSize = {
            w: hostSize.w - _marginX - _borderX - (_isBorderBox ? 0 : _paddingX),
            h: hostSize.h - _marginY - _borderY - (_isBorderBox ? 0 : _paddingY)
          };
          var contentGlueSize = {
            //client/scrollSize + AbsolutePadding -> because padding is only applied to the paddingElement if its absolute, so you have to add it manually
            //hostSize is clientSize -> so padding should be added manually, right? FALSE! Because content glue is inside hostElement, so we don't have to worry about padding
            w: MATH.max((widthAuto ? contentSize.w : scrollSize.w) + paddingAbsoluteX, hostAbsoluteRectSize.w),
            h: MATH.max((heightAuto ? contentSize.h : scrollSize.h) + paddingAbsoluteY, hostAbsoluteRectSize.h)
          };
          contentGlueSize.c = checkCacheAutoForce(contentGlueSize, _contentGlueSizeCache);
          _contentGlueSizeCache = contentGlueSize; //apply correct contentGlue size

          if (sizeAutoCapable) {
            //size contentGlue correctly to make sure the element has correct size if the sizing switches to auto
            if (contentGlueSize.c || heightAuto || widthAuto) {
              contentGlueElementCSS[_strWidth] = contentGlueSize.w;
              contentGlueElementCSS[_strHeight] = contentGlueSize.h; //textarea-sizes are already calculated correctly at this point

              if (!_isTextarea) {
                contentSize = {
                  //use clientSize because natively overlaidScrollbars add borders
                  w: contentMeasureElement[LEXICON.cW],
                  h: contentMeasureElement[LEXICON.cH]
                };
              }
            }

            var textareaCoverCSS = {};

            var setContentGlueElementCSSfunction = function (horizontal) {
              var scrollbarVars = getScrollbarVars(horizontal);
              var wh = scrollbarVars._w_h;
              var strWH = scrollbarVars._width_height;
              var autoSize = horizontal ? widthAuto : heightAuto;
              var borderSize = horizontal ? _borderX : _borderY;
              var paddingSize = horizontal ? _paddingX : _paddingY;
              var marginSize = horizontal ? _marginX : _marginY;
              var viewportSize = _viewportSize[wh] - borderSize - marginSize - (_isBorderBox ? 0 : paddingSize); //make contentGlue size -1 if element is not auto sized, to make sure that a resize event happens when the element shrinks

              if (!autoSize || !autoSize && border.c) contentGlueElementCSS[strWH] = hostAbsoluteRectSize[wh] - 1; //if size is auto and host is smaller than size as min size, make content glue size -1 to make sure size changes will be detected (this is only needed if padding is 0)

              if (autoSize && contentSize[wh] < viewportSize && (horizontal && _isTextarea ? !textareaAutoWrapping : true)) {
                if (_isTextarea) textareaCoverCSS[strWH] = parseToZeroOrNumber(_textareaCoverElement.css(strWH)) - 1;
                contentGlueElementCSS[strWH] -= 1;
              } //make sure content glue size is at least 1


              if (contentSize[wh] > 0) contentGlueElementCSS[strWH] = MATH.max(1, contentGlueElementCSS[strWH]);
            };

            setContentGlueElementCSSfunction(true);
            setContentGlueElementCSSfunction(false);
            if (_isTextarea) _textareaCoverElement.css(textareaCoverCSS);

            _contentGlueElement.css(contentGlueElementCSS);
          }

          if (widthAuto) contentElementCSS[_strWidth] = _strHundredPercent;
          if (widthAuto && !_isBorderBox && !_mutationObserversConnected) contentElementCSS[_strFloat] = 'none'; //apply and reset content style

          _contentElement.css(contentElementCSS);

          contentElementCSS = {}; //measure again, but this time all correct sizes:

          var contentScrollSize = {
            w: contentMeasureElement[LEXICON.sW],
            h: contentMeasureElement[LEXICON.sH]
          };
          contentScrollSize.c = contentSizeChanged = checkCacheAutoForce(contentScrollSize, _contentScrollSizeCache);
          _contentScrollSizeCache = contentScrollSize; //refresh viewport size after correct measuring

          _viewportSize = getViewportSize();
          hostSize = getHostSize();
          hostSizeChanged = checkCacheAutoForce(hostSize, _hostSizeCache);
          _hostSizeCache = hostSize;
          var hideOverflowForceTextarea = _isTextarea && (_viewportSize.w === 0 || _viewportSize.h === 0);
          var previousOverflowAmount = _overflowAmountCache;
          var overflowBehaviorIsVS = {};
          var overflowBehaviorIsVH = {};
          var overflowBehaviorIsS = {};
          var overflowAmount = {};
          var hasOverflow = {};
          var hideOverflow = {};
          var canScroll = {};

          var viewportRect = _paddingElementNative[LEXICON.bCR]();

          var setOverflowVariables = function (horizontal) {
            var scrollbarVars = getScrollbarVars(horizontal);
            var scrollbarVarsInverted = getScrollbarVars(!horizontal);
            var xyI = scrollbarVarsInverted._x_y;
            var xy = scrollbarVars._x_y;
            var wh = scrollbarVars._w_h;
            var widthHeight = scrollbarVars._width_height;
            var scrollMax = _strScroll + scrollbarVars._Left_Top + 'Max';
            var fractionalOverflowAmount = viewportRect[widthHeight] ? MATH.abs(viewportRect[widthHeight] - _viewportSize[wh]) : 0;
            var checkFractionalOverflowAmount = previousOverflowAmount && previousOverflowAmount[xy] > 0 && _viewportElementNative[scrollMax] === 0;
            overflowBehaviorIsVS[xy] = overflowBehavior[xy] === 'v-s';
            overflowBehaviorIsVH[xy] = overflowBehavior[xy] === 'v-h';
            overflowBehaviorIsS[xy] = overflowBehavior[xy] === 's';
            overflowAmount[xy] = MATH.max(0, MATH.round((contentScrollSize[wh] - _viewportSize[wh]) * 100) / 100);
            overflowAmount[xy] *= hideOverflowForceTextarea || checkFractionalOverflowAmount && fractionalOverflowAmount > 0 && fractionalOverflowAmount < 1 ? 0 : 1;
            hasOverflow[xy] = overflowAmount[xy] > 0; //hideOverflow:
            //x || y : true === overflow is hidden by "overflow: scroll" OR "overflow: hidden"
            //xs || ys : true === overflow is hidden by "overflow: scroll"

            hideOverflow[xy] = overflowBehaviorIsVS[xy] || overflowBehaviorIsVH[xy] ? hasOverflow[xyI] && !overflowBehaviorIsVS[xyI] && !overflowBehaviorIsVH[xyI] : hasOverflow[xy];
            hideOverflow[xy + 's'] = hideOverflow[xy] ? overflowBehaviorIsS[xy] || overflowBehaviorIsVS[xy] : false;
            canScroll[xy] = hasOverflow[xy] && hideOverflow[xy + 's'];
          };

          setOverflowVariables(true);
          setOverflowVariables(false);
          overflowAmount.c = checkCacheAutoForce(overflowAmount, _overflowAmountCache);
          _overflowAmountCache = overflowAmount;
          hasOverflow.c = checkCacheAutoForce(hasOverflow, _hasOverflowCache);
          _hasOverflowCache = hasOverflow;
          hideOverflow.c = checkCacheAutoForce(hideOverflow, _hideOverflowCache);
          _hideOverflowCache = hideOverflow; //if native scrollbar is overlay at x OR y axis, prepare DOM

          if (_nativeScrollbarIsOverlaid.x || _nativeScrollbarIsOverlaid.y) {
            var borderDesign = 'px solid transparent';
            var contentArrangeElementCSS = {};
            var arrangeContent = {};
            var arrangeChanged = force;
            var setContentElementCSS;

            if (hasOverflow.x || hasOverflow.y) {
              arrangeContent.w = _nativeScrollbarIsOverlaid.y && hasOverflow.y ? contentScrollSize.w + _overlayScrollbarDummySize.y : _strEmpty;
              arrangeContent.h = _nativeScrollbarIsOverlaid.x && hasOverflow.x ? contentScrollSize.h + _overlayScrollbarDummySize.x : _strEmpty;
              arrangeChanged = checkCacheAutoForce(arrangeContent, _arrangeContentSizeCache);
              _arrangeContentSizeCache = arrangeContent;
            }

            if (hasOverflow.c || hideOverflow.c || contentScrollSize.c || cssDirectionChanged || widthAutoChanged || heightAutoChanged || widthAuto || heightAuto || ignoreOverlayScrollbarHidingChanged) {
              contentElementCSS[_strMarginMinus + isRTLRight] = contentElementCSS[_strBorderMinus + isRTLRight] = _strEmpty;

              setContentElementCSS = function (horizontal) {
                var scrollbarVars = getScrollbarVars(horizontal);
                var scrollbarVarsInverted = getScrollbarVars(!horizontal);
                var xy = scrollbarVars._x_y;
                var strDirection = horizontal ? _strBottom : isRTLLeft;
                var invertedAutoSize = horizontal ? heightAuto : widthAuto;

                if (_nativeScrollbarIsOverlaid[xy] && hasOverflow[xy] && hideOverflow[xy + 's']) {
                  contentElementCSS[_strMarginMinus + strDirection] = invertedAutoSize ? ignoreOverlayScrollbarHiding ? _strEmpty : _overlayScrollbarDummySize[xy] : _strEmpty;
                  contentElementCSS[_strBorderMinus + strDirection] = (horizontal ? !invertedAutoSize : true) && !ignoreOverlayScrollbarHiding ? _overlayScrollbarDummySize[xy] + borderDesign : _strEmpty;
                } else {
                  arrangeContent[scrollbarVarsInverted._w_h] = contentElementCSS[_strMarginMinus + strDirection] = contentElementCSS[_strBorderMinus + strDirection] = _strEmpty;
                  arrangeChanged = true;
                }
              };

              if (_nativeScrollbarStyling) {
                addRemoveClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible, !ignoreOverlayScrollbarHiding);
              } else {
                setContentElementCSS(true);
                setContentElementCSS(false);
              }
            }

            if (ignoreOverlayScrollbarHiding) {
              arrangeContent.w = arrangeContent.h = _strEmpty;
              arrangeChanged = true;
            }

            if (arrangeChanged && !_nativeScrollbarStyling) {
              contentArrangeElementCSS[_strWidth] = hideOverflow.y ? arrangeContent.w : _strEmpty;
              contentArrangeElementCSS[_strHeight] = hideOverflow.x ? arrangeContent.h : _strEmpty;

              if (!_contentArrangeElement) {
                _contentArrangeElement = FRAMEWORK(generateDiv(_classNameContentArrangeElement));

                _viewportElement.prepend(_contentArrangeElement);
              }

              _contentArrangeElement.css(contentArrangeElementCSS);
            }

            _contentElement.css(contentElementCSS);
          }

          var viewportElementCSS = {};
          var paddingElementCSS = {};
          var setViewportCSS;

          if (hostSizeChanged || hasOverflow.c || hideOverflow.c || contentScrollSize.c || overflowBehaviorChanged || boxSizingChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged || clipAlwaysChanged || heightAutoChanged) {
            viewportElementCSS[isRTLRight] = _strEmpty;

            setViewportCSS = function (horizontal) {
              var scrollbarVars = getScrollbarVars(horizontal);
              var scrollbarVarsInverted = getScrollbarVars(!horizontal);
              var xy = scrollbarVars._x_y;
              var XY = scrollbarVars._X_Y;
              var strDirection = horizontal ? _strBottom : isRTLLeft;

              var reset = function () {
                viewportElementCSS[strDirection] = _strEmpty;
                _contentBorderSize[scrollbarVarsInverted._w_h] = 0;
              };

              if (hasOverflow[xy] && hideOverflow[xy + 's']) {
                viewportElementCSS[strOverflow + XY] = _strScroll;

                if (ignoreOverlayScrollbarHiding || _nativeScrollbarStyling) {
                  reset();
                } else {
                  viewportElementCSS[strDirection] = -(_nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[xy] : _nativeScrollbarSize[xy]);
                  _contentBorderSize[scrollbarVarsInverted._w_h] = _nativeScrollbarIsOverlaid[xy] ? _overlayScrollbarDummySize[scrollbarVarsInverted._x_y] : 0;
                }
              } else {
                viewportElementCSS[strOverflow + XY] = _strEmpty;
                reset();
              }
            };

            setViewportCSS(true);
            setViewportCSS(false); // if the scroll container is too small and if there is any overflow with no overlay scrollbar (and scrollbar styling isn't possible), 
            // make viewport element greater in size (Firefox hide Scrollbars fix)
            // because firefox starts hiding scrollbars on too small elements
            // with this behavior the overflow calculation may be incorrect or the scrollbars would appear suddenly
            // https://bugzilla.mozilla.org/show_bug.cgi?id=292284

            if (!_nativeScrollbarStyling && (_viewportSize.h < _nativeScrollbarMinSize.x || _viewportSize.w < _nativeScrollbarMinSize.y) && (hasOverflow.x && hideOverflow.x && !_nativeScrollbarIsOverlaid.x || hasOverflow.y && hideOverflow.y && !_nativeScrollbarIsOverlaid.y)) {
              viewportElementCSS[_strPaddingMinus + _strTop] = _nativeScrollbarMinSize.x;
              viewportElementCSS[_strMarginMinus + _strTop] = -_nativeScrollbarMinSize.x;
              viewportElementCSS[_strPaddingMinus + isRTLRight] = _nativeScrollbarMinSize.y;
              viewportElementCSS[_strMarginMinus + isRTLRight] = -_nativeScrollbarMinSize.y;
            } else {
              viewportElementCSS[_strPaddingMinus + _strTop] = viewportElementCSS[_strMarginMinus + _strTop] = viewportElementCSS[_strPaddingMinus + isRTLRight] = viewportElementCSS[_strMarginMinus + isRTLRight] = _strEmpty;
            }

            viewportElementCSS[_strPaddingMinus + isRTLLeft] = viewportElementCSS[_strMarginMinus + isRTLLeft] = _strEmpty; //if there is any overflow (x OR y axis) and this overflow shall be hidden, make overflow hidden, else overflow visible

            if (hasOverflow.x && hideOverflow.x || hasOverflow.y && hideOverflow.y || hideOverflowForceTextarea) {
              //only hide if is Textarea
              if (_isTextarea && hideOverflowForceTextarea) {
                paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = strHidden;
              }
            } else {
              if (!clipAlways || overflowBehaviorIsVH.x || overflowBehaviorIsVS.x || overflowBehaviorIsVH.y || overflowBehaviorIsVS.y) {
                //only un-hide if Textarea
                if (_isTextarea) {
                  paddingElementCSS[strOverflowX] = paddingElementCSS[strOverflowY] = _strEmpty;
                }

                viewportElementCSS[strOverflowX] = viewportElementCSS[strOverflowY] = strVisible;
              }
            }

            _paddingElement.css(paddingElementCSS);

            _viewportElement.css(viewportElementCSS);

            viewportElementCSS = {}; //force soft redraw in webkit because without the scrollbars will may appear because DOM wont be redrawn under special conditions

            if ((hasOverflow.c || boxSizingChanged || widthAutoChanged || heightAutoChanged) && !(_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y)) {
              var elementStyle = _contentElementNative[LEXICON.s];
              var dump;
              elementStyle.webkitTransform = 'scale(1)';
              elementStyle.display = 'run-in';
              dump = _contentElementNative[LEXICON.oH];
              elementStyle.display = _strEmpty; //|| dump; //use dump to prevent it from deletion if minify

              elementStyle.webkitTransform = _strEmpty;
            }
            /*
            //force hard redraw in webkit if native overlaid scrollbars shall appear
            if (ignoreOverlayScrollbarHidingChanged && ignoreOverlayScrollbarHiding) {
                _hostElement.hide();
                var dump = _hostElementNative[LEXICON.oH];
                _hostElement.show();
            }
            */

          } //change to direction RTL and width auto Bugfix in Webkit
          //without this fix, the DOM still thinks the scrollbar is LTR and thus the content is shifted to the left


          contentElementCSS = {};

          if (cssDirectionChanged || widthAutoChanged || heightAutoChanged) {
            if (_isRTL && widthAuto) {
              var floatTmp = _contentElement.css(_strFloat);

              var posLeftWithoutFloat = MATH.round(_contentElement.css(_strFloat, _strEmpty).css(_strLeft, _strEmpty).position().left);

              _contentElement.css(_strFloat, floatTmp);

              var posLeftWithFloat = MATH.round(_contentElement.position().left);
              if (posLeftWithoutFloat !== posLeftWithFloat) contentElementCSS[_strLeft] = posLeftWithoutFloat;
            } else {
              contentElementCSS[_strLeft] = _strEmpty;
            }
          }

          _contentElement.css(contentElementCSS); //handle scroll position


          if (_isTextarea && contentSizeChanged) {
            var textareaInfo = getTextareaInfo();

            if (textareaInfo) {
              var textareaRowsChanged = _textareaInfoCache === undefined ? true : textareaInfo._rows !== _textareaInfoCache._rows;
              var cursorRow = textareaInfo._cursorRow;
              var cursorCol = textareaInfo._cursorColumn;
              var widestRow = textareaInfo._widestRow;
              var lastRow = textareaInfo._rows;
              var lastCol = textareaInfo._columns;
              var cursorPos = textareaInfo._cursorPosition;
              var cursorMax = textareaInfo._cursorMax;
              var cursorIsLastPosition = cursorPos >= cursorMax && _textareaHasFocus;
              var textareaScrollAmount = {
                x: !textareaAutoWrapping && cursorCol === lastCol && cursorRow === widestRow ? _overflowAmountCache.x : -1,
                y: (textareaAutoWrapping ? cursorIsLastPosition || textareaRowsChanged && (previousOverflowAmount ? currScroll.y === previousOverflowAmount.y : false) : (cursorIsLastPosition || textareaRowsChanged) && cursorRow === lastRow) ? _overflowAmountCache.y : -1
              };
              currScroll.x = textareaScrollAmount.x > -1 ? _isRTL && _normalizeRTLCache && _rtlScrollBehavior.i ? 0 : textareaScrollAmount.x : currScroll.x; //if inverted, scroll to 0 -> normalized this means to max scroll offset.

              currScroll.y = textareaScrollAmount.y > -1 ? textareaScrollAmount.y : currScroll.y;
            }

            _textareaInfoCache = textareaInfo;
          }

          if (_isRTL && _rtlScrollBehavior.i && _nativeScrollbarIsOverlaid.y && hasOverflow.x && _normalizeRTLCache) currScroll.x += _contentBorderSize.w || 0;
          if (widthAuto) _hostElement[_strScrollLeft](0);
          if (heightAuto) _hostElement[_strScrollTop](0);

          _viewportElement[_strScrollLeft](currScroll.x)[_strScrollTop](currScroll.y); //scrollbars management:


          var scrollbarsVisibilityVisible = scrollbarsVisibility === 'v';
          var scrollbarsVisibilityHidden = scrollbarsVisibility === 'h';
          var scrollbarsVisibilityAuto = scrollbarsVisibility === 'a';

          var refreshScrollbarsVisibility = function (showX, showY) {
            showY = showY === undefined ? showX : showY;
            refreshScrollbarAppearance(true, showX, canScroll.x);
            refreshScrollbarAppearance(false, showY, canScroll.y);
          }; //manage class name which indicates scrollable overflow


          addRemoveClass(_hostElement, _classNameHostOverflow, hideOverflow.x || hideOverflow.y);
          addRemoveClass(_hostElement, _classNameHostOverflowX, hideOverflow.x);
          addRemoveClass(_hostElement, _classNameHostOverflowY, hideOverflow.y); //add or remove rtl class name for styling purposes

          if (cssDirectionChanged) {
            addRemoveClass(_hostElement, _classNameHostRTL, _isRTL);
          } //manage the resize feature (CSS3 resize "polyfill" for this plugin)


          if (_isBody) addClass(_hostElement, _classNameHostResizeDisabled);

          if (resizeChanged) {
            addRemoveClass(_hostElement, _classNameHostResizeDisabled, _resizeNone);
            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResize, !_resizeNone);
            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeB, _resizeBoth);
            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeH, _resizeHorizontal);
            addRemoveClass(_scrollbarCornerElement, _classNameScrollbarCornerResizeV, _resizeVertical);
          } //manage the scrollbars general visibility + the scrollbar interactivity (unusable class name)


          if (scrollbarsVisibilityChanged || overflowBehaviorChanged || hideOverflow.c || hasOverflow.c || ignoreOverlayScrollbarHidingChanged) {
            if (ignoreOverlayScrollbarHiding) {
              if (ignoreOverlayScrollbarHidingChanged) {
                removeClass(_hostElement, _classNameHostScrolling);

                if (ignoreOverlayScrollbarHiding) {
                  refreshScrollbarsVisibility(false);
                }
              }
            } else if (scrollbarsVisibilityAuto) {
              refreshScrollbarsVisibility(canScroll.x, canScroll.y);
            } else if (scrollbarsVisibilityVisible) {
              refreshScrollbarsVisibility(true);
            } else if (scrollbarsVisibilityHidden) {
              refreshScrollbarsVisibility(false);
            }
          } //manage the scrollbars auto hide feature (auto hide them after specific actions)


          if (scrollbarsAutoHideChanged || ignoreOverlayScrollbarHidingChanged) {
            setupHostMouseTouchEvents(!_scrollbarsAutoHideLeave && !_scrollbarsAutoHideMove);
            refreshScrollbarsAutoHide(_scrollbarsAutoHideNever, !_scrollbarsAutoHideNever);
          } //manage scrollbars handle length & offset - don't remove!


          if (hostSizeChanged || overflowAmount.c || heightAutoChanged || widthAutoChanged || resizeChanged || boxSizingChanged || paddingAbsoluteChanged || ignoreOverlayScrollbarHidingChanged || cssDirectionChanged) {
            refreshScrollbarHandleLength(true);
            refreshScrollbarHandleOffset(true);
            refreshScrollbarHandleLength(false);
            refreshScrollbarHandleOffset(false);
          } //manage interactivity


          if (scrollbarsClickScrollingChanged) refreshScrollbarsInteractive(true, scrollbarsClickScrolling);
          if (scrollbarsDragScrollingChanged) refreshScrollbarsInteractive(false, scrollbarsDragScrolling); //callbacks:

          dispatchCallback('onDirectionChanged', {
            isRTL: _isRTL,
            dir: cssDirection
          }, cssDirectionChanged);
          dispatchCallback('onHostSizeChanged', {
            width: _hostSizeCache.w,
            height: _hostSizeCache.h
          }, hostSizeChanged);
          dispatchCallback('onContentSizeChanged', {
            width: _contentScrollSizeCache.w,
            height: _contentScrollSizeCache.h
          }, contentSizeChanged);
          dispatchCallback('onOverflowChanged', {
            x: hasOverflow.x,
            y: hasOverflow.y,
            xScrollable: hideOverflow.xs,
            yScrollable: hideOverflow.ys,
            clipped: hideOverflow.x || hideOverflow.y
          }, hasOverflow.c || hideOverflow.c);
          dispatchCallback('onOverflowAmountChanged', {
            x: overflowAmount.x,
            y: overflowAmount.y
          }, overflowAmount.c);
        } //fix body min size


        if (_isBody && _bodyMinSizeCache && (_hasOverflowCache.c || _bodyMinSizeCache.c)) {
          //its possible that no min size was measured until now, because the content arrange element was just added now, in this case, measure now the min size.
          if (!_bodyMinSizeCache.f) bodyMinSizeChanged();
          if (_nativeScrollbarIsOverlaid.y && _hasOverflowCache.x) _contentElement.css(_strMinMinus + _strWidth, _bodyMinSizeCache.w + _overlayScrollbarDummySize.y);
          if (_nativeScrollbarIsOverlaid.x && _hasOverflowCache.y) _contentElement.css(_strMinMinus + _strHeight, _bodyMinSizeCache.h + _overlayScrollbarDummySize.x);
          _bodyMinSizeCache.c = false;
        }

        if (_initialized && changedOptions.updateOnLoad) {
          updateElementsOnLoad();
        } //freezeResizeObserver(_sizeObserverElement, false);
        //freezeResizeObserver(_sizeAutoObserverElement, false);


        dispatchCallback('onUpdated', {
          forced: force
        });
      }
      /**
       * Updates the found elements of which the load event shall be handled.
       */


      function updateElementsOnLoad() {
        if (!_isTextarea) {
          eachUpdateOnLoad(function (i, updateOnLoadSelector) {
            _contentElement.find(updateOnLoadSelector).each(function (i, el) {
              // if element doesn't have a updateOnLoadCallback applied
              if (COMPATIBILITY.inA(el, _updateOnLoadElms) < 0) {
                _updateOnLoadElms.push(el);

                FRAMEWORK(el).off(_updateOnLoadEventName, updateOnLoadCallback).on(_updateOnLoadEventName, updateOnLoadCallback);
              }
            });
          });
        }
      } //==== Options ====//

      /**
       * Sets new options but doesn't call the update method.
       * @param newOptions The object which contains the new options.
       * @returns {*} A object which contains the changed options.
       */


      function setOptions(newOptions) {
        var validatedOpts = _pluginsOptions._validate(newOptions, _pluginsOptions._template, true, _currentOptions);

        _currentOptions = extendDeep({}, _currentOptions, validatedOpts._default);
        _currentPreparedOptions = extendDeep({}, _currentPreparedOptions, validatedOpts._prepared);
        return validatedOpts._prepared;
      } //==== Structure ====//

      /**
       * Builds or destroys the wrapper and helper DOM elements.
       * @param destroy Indicates whether the DOM shall be build or destroyed.
       */

      /**
       * Builds or destroys the wrapper and helper DOM elements.
       * @param destroy Indicates whether the DOM shall be build or destroyed.
       */


      function setupStructureDOM(destroy) {
        var strParent = 'parent';
        var classNameResizeObserverHost = 'os-resize-observer-host';
        var classNameTextareaElementFull = _classNameTextareaElement + _strSpace + _classNameTextInherit;
        var textareaClass = _isTextarea ? _strSpace + _classNameTextInherit : _strEmpty;
        var adoptAttrs = _currentPreparedOptions.textarea.inheritedAttrs;
        var adoptAttrsMap = {};

        var applyAdoptedAttrs = function () {
          var applyAdoptedAttrsElm = destroy ? _targetElement : _hostElement;
          each(adoptAttrsMap, function (key, value) {
            if (type(value) == TYPES.s) {
              if (key == LEXICON.c) applyAdoptedAttrsElm.addClass(value);else applyAdoptedAttrsElm.attr(key, value);
            }
          });
        };

        var hostElementClassNames = [_classNameHostElement, _classNameHostElementForeign, _classNameHostTextareaElement, _classNameHostResizeDisabled, _classNameHostRTL, _classNameHostScrollbarHorizontalHidden, _classNameHostScrollbarVerticalHidden, _classNameHostTransition, _classNameHostScrolling, _classNameHostOverflow, _classNameHostOverflowX, _classNameHostOverflowY, _classNameThemeNone, _classNameTextareaElement, _classNameTextInherit, _classNameCache].join(_strSpace);
        var hostElementCSS = {}; //get host element as first element, because that's the most upper element and required for the other elements

        _hostElement = _hostElement || (_isTextarea ? _domExists ? _targetElement[strParent]()[strParent]()[strParent]()[strParent]() : FRAMEWORK(generateDiv(_classNameHostTextareaElement)) : _targetElement);
        _contentElement = _contentElement || selectOrGenerateDivByClass(_classNameContentElement + textareaClass);
        _viewportElement = _viewportElement || selectOrGenerateDivByClass(_classNameViewportElement + textareaClass);
        _paddingElement = _paddingElement || selectOrGenerateDivByClass(_classNamePaddingElement + textareaClass);
        _sizeObserverElement = _sizeObserverElement || selectOrGenerateDivByClass(classNameResizeObserverHost);
        _textareaCoverElement = _textareaCoverElement || (_isTextarea ? selectOrGenerateDivByClass(_classNameTextareaCoverElement) : undefined); //add this class to workaround class changing issues with UI frameworks especially Vue

        if (_domExists) addClass(_hostElement, _classNameHostElementForeign); //on destroy, remove all generated class names from the host element before collecting the adopted attributes 
        //to prevent adopting generated class names

        if (destroy) removeClass(_hostElement, hostElementClassNames); //collect all adopted attributes

        adoptAttrs = type(adoptAttrs) == TYPES.s ? adoptAttrs.split(_strSpace) : adoptAttrs;

        if (COMPATIBILITY.isA(adoptAttrs) && _isTextarea) {
          each(adoptAttrs, function (i, v) {
            if (type(v) == TYPES.s) {
              adoptAttrsMap[v] = destroy ? _hostElement.attr(v) : _targetElement.attr(v);
            }
          });
        }

        if (!destroy) {
          if (_isTextarea) {
            if (!_currentPreparedOptions.sizeAutoCapable) {
              hostElementCSS[_strWidth] = _targetElement.css(_strWidth);
              hostElementCSS[_strHeight] = _targetElement.css(_strHeight);
            }

            if (!_domExists) _targetElement.addClass(_classNameTextInherit).wrap(_hostElement); //jQuery clones elements in wrap functions, so we have to select them again

            _hostElement = _targetElement[strParent]().css(hostElementCSS);
          }

          if (!_domExists) {
            //add the correct class to the target element
            addClass(_targetElement, _isTextarea ? classNameTextareaElementFull : _classNameHostElement); //wrap the content into the generated elements to create the required DOM

            _hostElement.wrapInner(_contentElement).wrapInner(_viewportElement).wrapInner(_paddingElement).prepend(_sizeObserverElement); //jQuery clones elements in wrap functions, so we have to select them again


            _contentElement = findFirst(_hostElement, _strDot + _classNameContentElement);
            _viewportElement = findFirst(_hostElement, _strDot + _classNameViewportElement);
            _paddingElement = findFirst(_hostElement, _strDot + _classNamePaddingElement);

            if (_isTextarea) {
              _contentElement.prepend(_textareaCoverElement);

              applyAdoptedAttrs();
            }
          }

          if (_nativeScrollbarStyling) addClass(_viewportElement, _classNameViewportNativeScrollbarsInvisible);
          if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y) addClass(_viewportElement, _classNameViewportNativeScrollbarsOverlaid);
          if (_isBody) addClass(_htmlElement, _classNameHTMLElement);
          _sizeObserverElementNative = _sizeObserverElement[0];
          _hostElementNative = _hostElement[0];
          _paddingElementNative = _paddingElement[0];
          _viewportElementNative = _viewportElement[0];
          _contentElementNative = _contentElement[0];
          updateViewportAttrsFromTarget();
        } else {
          if (_domExists && _initialized) {
            //clear size observer
            _sizeObserverElement.children().remove(); //remove the style property and classes from already generated elements


            each([_paddingElement, _viewportElement, _contentElement, _textareaCoverElement], function (i, elm) {
              if (elm) {
                removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
              }
            }); //add classes to the host element which was removed previously to match the expected DOM

            addClass(_hostElement, _isTextarea ? _classNameHostTextareaElement : _classNameHostElement);
          } else {
            //remove size observer
            remove(_sizeObserverElement); //unwrap the content to restore DOM

            _contentElement.contents().unwrap().unwrap().unwrap();

            if (_isTextarea) {
              _targetElement.unwrap();

              remove(_hostElement);
              remove(_textareaCoverElement);
              applyAdoptedAttrs();
            }
          }

          if (_isTextarea) _targetElement.removeAttr(LEXICON.s);
          if (_isBody) removeClass(_htmlElement, _classNameHTMLElement);
        }
      }
      /**
       * Adds or removes all wrapper elements interactivity events.
       * @param destroy Indicates whether the Events shall be added or removed.
       */


      function setupStructureEvents() {
        var textareaKeyDownRestrictedKeyCodes = [112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 123, //F1 to F12
        33, 34, //page up, page down
        37, 38, 39, 40, //left, up, right, down arrows
        16, 17, 18, 19, 20, 144 //Shift, Ctrl, Alt, Pause, CapsLock, NumLock
        ];
        var textareaKeyDownKeyCodesList = [];
        var textareaUpdateIntervalID;
        var scrollStopTimeoutId;
        var scrollStopDelay = 175;
        var strFocus = 'focus';

        function updateTextarea(doClearInterval) {
          textareaUpdate();

          _base.update(_strAuto);

          if (doClearInterval && _autoUpdateRecommended) clearInterval(textareaUpdateIntervalID);
        }

        function textareaOnScroll(event) {
          _targetElement[_strScrollLeft](_rtlScrollBehavior.i && _normalizeRTLCache ? 9999999 : 0);

          _targetElement[_strScrollTop](0);

          COMPATIBILITY.prvD(event);
          COMPATIBILITY.stpP(event);
          return false;
        }

        function textareaOnDrop(event) {
          setTimeout(function () {
            if (!_destroyed) updateTextarea();
          }, 50);
        }

        function textareaOnFocus() {
          _textareaHasFocus = true;
          addClass(_hostElement, strFocus);
        }

        function textareaOnFocusout() {
          _textareaHasFocus = false;
          textareaKeyDownKeyCodesList = [];
          removeClass(_hostElement, strFocus);
          updateTextarea(true);
        }

        function textareaOnKeyDown(event) {
          var keyCode = event.keyCode;

          if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
            if (!textareaKeyDownKeyCodesList[LEXICON.l]) {
              updateTextarea();
              textareaUpdateIntervalID = setInterval(updateTextarea, 1000 / 60);
            }

            if (inArray(keyCode, textareaKeyDownKeyCodesList) < 0) textareaKeyDownKeyCodesList.push(keyCode);
          }
        }

        function textareaOnKeyUp(event) {
          var keyCode = event.keyCode;
          var index = inArray(keyCode, textareaKeyDownKeyCodesList);

          if (inArray(keyCode, textareaKeyDownRestrictedKeyCodes) < 0) {
            if (index > -1) textareaKeyDownKeyCodesList.splice(index, 1);
            if (!textareaKeyDownKeyCodesList[LEXICON.l]) updateTextarea(true);
          }
        }

        function contentOnTransitionEnd(event) {
          if (_autoUpdateCache === true) return;
          event = event.originalEvent || event;
          if (isSizeAffectingCSSProperty(event.propertyName)) _base.update(_strAuto);
        }

        function viewportOnScroll(event) {
          if (!_sleeping) {
            if (scrollStopTimeoutId !== undefined) clearTimeout(scrollStopTimeoutId);else {
              if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(true);
              if (!nativeOverlayScrollbarsAreActive()) addClass(_hostElement, _classNameHostScrolling);
              dispatchCallback('onScrollStart', event);
            } //if a scrollbars handle gets dragged, the mousemove event is responsible for refreshing the handle offset
            //because if CSS scroll-snap is used, the handle offset gets only refreshed on every snap point
            //this looks laggy & clunky, it looks much better if the offset refreshes with the mousemove

            if (!_scrollbarsHandlesDefineScrollPos) {
              refreshScrollbarHandleOffset(true);
              refreshScrollbarHandleOffset(false);
            }

            dispatchCallback('onScroll', event);
            scrollStopTimeoutId = setTimeout(function () {
              if (!_destroyed) {
                //OnScrollStop:
                clearTimeout(scrollStopTimeoutId);
                scrollStopTimeoutId = undefined;
                if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(false);
                if (!nativeOverlayScrollbarsAreActive()) removeClass(_hostElement, _classNameHostScrolling);
                dispatchCallback('onScrollStop', event);
              }
            }, scrollStopDelay);
          }
        }

        if (_isTextarea) {
          if (_msieVersion > 9 || !_autoUpdateRecommended) {
            addDestroyEventListener(_targetElement, 'input', updateTextarea);
          } else {
            addDestroyEventListener(_targetElement, [_strKeyDownEvent, _strKeyUpEvent], [textareaOnKeyDown, textareaOnKeyUp]);
          }

          addDestroyEventListener(_targetElement, [_strScroll, 'drop', strFocus, strFocus + 'out'], [textareaOnScroll, textareaOnDrop, textareaOnFocus, textareaOnFocusout]);
        } else {
          addDestroyEventListener(_contentElement, _strTransitionEndEvent, contentOnTransitionEnd);
        }

        addDestroyEventListener(_viewportElement, _strScroll, viewportOnScroll, true);
      } //==== Scrollbars ====//

      /**
       * Builds or destroys all scrollbar DOM elements (scrollbar, track, handle)
       * @param destroy Indicates whether the DOM shall be build or destroyed.
       */


      function setupScrollbarsDOM(destroy) {
        var selectOrGenerateScrollbarDOM = function (isHorizontal) {
          var scrollbarClassName = isHorizontal ? _classNameScrollbarHorizontal : _classNameScrollbarVertical;
          var scrollbar = selectOrGenerateDivByClass(_classNameScrollbar + _strSpace + scrollbarClassName, true);
          var track = selectOrGenerateDivByClass(_classNameScrollbarTrack, scrollbar);
          var handle = selectOrGenerateDivByClass(_classNameScrollbarHandle, scrollbar);

          if (!_domExists && !destroy) {
            scrollbar.append(track);
            track.append(handle);
          }

          return {
            _scrollbar: scrollbar,
            _track: track,
            _handle: handle
          };
        };

        function resetScrollbarDOM(isHorizontal) {
          var scrollbarVars = getScrollbarVars(isHorizontal);
          var scrollbar = scrollbarVars._scrollbar;
          var track = scrollbarVars._track;
          var handle = scrollbarVars._handle;

          if (_domExists && _initialized) {
            each([scrollbar, track, handle], function (i, elm) {
              removeClass(elm.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
            });
          } else {
            remove(scrollbar || selectOrGenerateScrollbarDOM(isHorizontal)._scrollbar);
          }
        }

        var horizontalElements;
        var verticalElements;

        if (!destroy) {
          horizontalElements = selectOrGenerateScrollbarDOM(true);
          verticalElements = selectOrGenerateScrollbarDOM();
          _scrollbarHorizontalElement = horizontalElements._scrollbar;
          _scrollbarHorizontalTrackElement = horizontalElements._track;
          _scrollbarHorizontalHandleElement = horizontalElements._handle;
          _scrollbarVerticalElement = verticalElements._scrollbar;
          _scrollbarVerticalTrackElement = verticalElements._track;
          _scrollbarVerticalHandleElement = verticalElements._handle;

          if (!_domExists) {
            _paddingElement.after(_scrollbarVerticalElement);

            _paddingElement.after(_scrollbarHorizontalElement);
          }
        } else {
          resetScrollbarDOM(true);
          resetScrollbarDOM();
        }
      }
      /**
       * Initializes all scrollbar interactivity events. (track and handle dragging, clicking, scrolling)
       * @param isHorizontal True if the target scrollbar is the horizontal scrollbar, false if the target scrollbar is the vertical scrollbar.
       */


      function setupScrollbarEvents(isHorizontal) {
        var scrollbarVars = getScrollbarVars(isHorizontal);
        var scrollbarVarsInfo = scrollbarVars._info;
        var insideIFrame = _windowElementNative.top !== _windowElementNative;
        var xy = scrollbarVars._x_y;
        var XY = scrollbarVars._X_Y;
        var scroll = _strScroll + scrollbarVars._Left_Top;
        var strActive = 'active';
        var strSnapHandle = 'snapHandle';
        var scrollDurationFactor = 1;
        var increaseDecreaseScrollAmountKeyCodes = [16, 17]; //shift, ctrl

        var trackTimeout;
        var mouseDownScroll;
        var mouseDownOffset;
        var mouseDownInvertedScale;

        function getPointerPosition(event) {
          return _msieVersion && insideIFrame ? event['screen' + XY] : COMPATIBILITY.page(event)[xy]; //use screen coordinates in EDGE & IE because the page values are incorrect in frames.
        }

        function getPreparedScrollbarsOption(name) {
          return _currentPreparedOptions.scrollbars[name];
        }

        function increaseTrackScrollAmount() {
          scrollDurationFactor = 0.5;
        }

        function decreaseTrackScrollAmount() {
          scrollDurationFactor = 1;
        }

        function documentKeyDown(event) {
          if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1) increaseTrackScrollAmount();
        }

        function documentKeyUp(event) {
          if (inArray(event.keyCode, increaseDecreaseScrollAmountKeyCodes) > -1) decreaseTrackScrollAmount();
        }

        function onMouseTouchDownContinue(event) {
          var originalEvent = event.originalEvent || event;
          var isTouchEvent = originalEvent.touches !== undefined;
          return _sleeping || _destroyed || nativeOverlayScrollbarsAreActive() || !_scrollbarsDragScrollingCache || isTouchEvent && !getPreparedScrollbarsOption('touchSupport') ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
        }

        function documentDragMove(event) {
          if (onMouseTouchDownContinue(event)) {
            var trackLength = scrollbarVarsInfo._trackLength;
            var handleLength = scrollbarVarsInfo._handleLength;
            var scrollRange = scrollbarVarsInfo._maxScroll;
            var scrollRaw = (getPointerPosition(event) - mouseDownOffset) * mouseDownInvertedScale;
            var scrollDeltaPercent = scrollRaw / (trackLength - handleLength);
            var scrollDelta = scrollRange * scrollDeltaPercent;
            scrollDelta = isFinite(scrollDelta) ? scrollDelta : 0;
            if (_isRTL && isHorizontal && !_rtlScrollBehavior.i) scrollDelta *= -1;

            _viewportElement[scroll](MATH.round(mouseDownScroll + scrollDelta));

            if (_scrollbarsHandlesDefineScrollPos) refreshScrollbarHandleOffset(isHorizontal, mouseDownScroll + scrollDelta);
            if (!_supportPassiveEvents) COMPATIBILITY.prvD(event);
          } else documentMouseTouchUp(event);
        }

        function documentMouseTouchUp(event) {
          event = event || event.originalEvent;
          setupResponsiveEventListener(_documentElement, [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent], [documentDragMove, documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart], true);
          if (_scrollbarsHandlesDefineScrollPos) refreshScrollbarHandleOffset(isHorizontal, true);
          _scrollbarsHandlesDefineScrollPos = false;
          removeClass(_bodyElement, _classNameDragging);
          removeClass(scrollbarVars._handle, strActive);
          removeClass(scrollbarVars._track, strActive);
          removeClass(scrollbarVars._scrollbar, strActive);
          mouseDownScroll = undefined;
          mouseDownOffset = undefined;
          mouseDownInvertedScale = 1;
          decreaseTrackScrollAmount();

          if (trackTimeout !== undefined) {
            _base.scrollStop();

            clearTimeout(trackTimeout);
            trackTimeout = undefined;
          }

          if (event) {
            var rect = _hostElementNative[LEXICON.bCR]();

            var mouseInsideHost = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom; //if mouse is outside host element

            if (!mouseInsideHost) hostOnMouseLeave();
            if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(false);
          }
        }

        function onHandleMouseTouchDown(event) {
          if (onMouseTouchDownContinue(event)) onHandleMouseTouchDownAction(event);
        }

        function onHandleMouseTouchDownAction(event) {
          mouseDownScroll = _viewportElement[scroll]();
          mouseDownScroll = isNaN(mouseDownScroll) ? 0 : mouseDownScroll;
          if (_isRTL && isHorizontal && !_rtlScrollBehavior.n || !_isRTL) mouseDownScroll = mouseDownScroll < 0 ? 0 : mouseDownScroll;
          mouseDownInvertedScale = getHostElementInvertedScale()[xy];
          mouseDownOffset = getPointerPosition(event);
          _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
          addClass(_bodyElement, _classNameDragging);
          addClass(scrollbarVars._handle, strActive);
          addClass(scrollbarVars._scrollbar, strActive);
          setupResponsiveEventListener(_documentElement, [_strMouseTouchMoveEvent, _strMouseTouchUpEvent, _strSelectStartEvent], [documentDragMove, documentMouseTouchUp, documentOnSelectStart]);
          if (_msieVersion || !_documentMixed) COMPATIBILITY.prvD(event);
          COMPATIBILITY.stpP(event);
        }

        function onTrackMouseTouchDown(event) {
          if (onMouseTouchDownContinue(event)) {
            var scrollDistance = MATH.round(_viewportSize[scrollbarVars._w_h]);

            var trackOffset = scrollbarVars._track.offset()[scrollbarVars._left_top];

            var ctrlKey = event.ctrlKey;
            var instantScroll = event.shiftKey;
            var instantScrollTransition = instantScroll && ctrlKey;
            var isFirstIteration = true;
            var easing = 'linear';
            var decreaseScroll;
            var finishedCondition;

            var scrollActionFinsished = function (transition) {
              if (_scrollbarsHandlesDefineScrollPos) refreshScrollbarHandleOffset(isHorizontal, transition);
            };

            var scrollActionInstantFinished = function () {
              scrollActionFinsished();
              onHandleMouseTouchDownAction(event);
            };

            var scrollAction = function () {
              if (!_destroyed) {
                var mouseOffset = (mouseDownOffset - trackOffset) * mouseDownInvertedScale;
                var handleOffset = scrollbarVarsInfo._handleOffset;
                var trackLength = scrollbarVarsInfo._trackLength;
                var handleLength = scrollbarVarsInfo._handleLength;
                var scrollRange = scrollbarVarsInfo._maxScroll;
                var currScroll = scrollbarVarsInfo._currentScroll;
                var scrollDuration = 270 * scrollDurationFactor;
                var timeoutDelay = isFirstIteration ? MATH.max(400, scrollDuration) : scrollDuration;
                var instantScrollPosition = scrollRange * ((mouseOffset - handleLength / 2) / (trackLength - handleLength)); // 100% * positionPercent

                var rtlIsNormal = _isRTL && isHorizontal && (!_rtlScrollBehavior.i && !_rtlScrollBehavior.n || _normalizeRTLCache);
                var decreaseScrollCondition = rtlIsNormal ? handleOffset < mouseOffset : handleOffset > mouseOffset;
                var scrollObj = {};
                var animationObj = {
                  easing: easing,
                  step: function (now) {
                    if (_scrollbarsHandlesDefineScrollPos) {
                      _viewportElement[scroll](now); //https://github.com/jquery/jquery/issues/4340


                      refreshScrollbarHandleOffset(isHorizontal, now);
                    }
                  }
                };
                instantScrollPosition = isFinite(instantScrollPosition) ? instantScrollPosition : 0;
                instantScrollPosition = _isRTL && isHorizontal && !_rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition; //_base.scrollStop();

                if (instantScroll) {
                  _viewportElement[scroll](instantScrollPosition); //scroll instantly to new position


                  if (instantScrollTransition) {
                    //get the scroll position after instant scroll (in case CSS Snap Points are used) to get the correct snapped scroll position
                    //and the animation stops at the correct point
                    instantScrollPosition = _viewportElement[scroll](); //scroll back to the position before instant scrolling so animation can be performed

                    _viewportElement[scroll](currScroll);

                    instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.i ? scrollRange - instantScrollPosition : instantScrollPosition;
                    instantScrollPosition = rtlIsNormal && _rtlScrollBehavior.n ? -instantScrollPosition : instantScrollPosition;
                    scrollObj[xy] = instantScrollPosition;

                    _base.scroll(scrollObj, extendDeep(animationObj, {
                      duration: 130,
                      complete: scrollActionInstantFinished
                    }));
                  } else scrollActionInstantFinished();
                } else {
                  decreaseScroll = isFirstIteration ? decreaseScrollCondition : decreaseScroll;
                  finishedCondition = rtlIsNormal ? decreaseScroll ? handleOffset + handleLength >= mouseOffset : handleOffset <= mouseOffset : decreaseScroll ? handleOffset <= mouseOffset : handleOffset + handleLength >= mouseOffset;

                  if (finishedCondition) {
                    clearTimeout(trackTimeout);

                    _base.scrollStop();

                    trackTimeout = undefined;
                    scrollActionFinsished(true);
                  } else {
                    trackTimeout = setTimeout(scrollAction, timeoutDelay);
                    scrollObj[xy] = (decreaseScroll ? '-=' : '+=') + scrollDistance;

                    _base.scroll(scrollObj, extendDeep(animationObj, {
                      duration: scrollDuration
                    }));
                  }

                  isFirstIteration = false;
                }
              }
            };

            if (ctrlKey) increaseTrackScrollAmount();
            mouseDownInvertedScale = getHostElementInvertedScale()[xy];
            mouseDownOffset = COMPATIBILITY.page(event)[xy];
            _scrollbarsHandlesDefineScrollPos = !getPreparedScrollbarsOption(strSnapHandle);
            addClass(_bodyElement, _classNameDragging);
            addClass(scrollbarVars._track, strActive);
            addClass(scrollbarVars._scrollbar, strActive);
            setupResponsiveEventListener(_documentElement, [_strMouseTouchUpEvent, _strKeyDownEvent, _strKeyUpEvent, _strSelectStartEvent], [documentMouseTouchUp, documentKeyDown, documentKeyUp, documentOnSelectStart]);
            scrollAction();
            COMPATIBILITY.prvD(event);
            COMPATIBILITY.stpP(event);
          }
        }

        function onTrackMouseTouchEnter(event) {
          //make sure both scrollbars will stay visible if one scrollbar is hovered if autoHide is "scroll" or "move".
          _scrollbarsHandleHovered = true;
          if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(true);
        }

        function onTrackMouseTouchLeave(event) {
          _scrollbarsHandleHovered = false;
          if (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove) refreshScrollbarsAutoHide(false);
        }

        function onScrollbarMouseTouchDown(event) {
          COMPATIBILITY.stpP(event);
        }

        addDestroyEventListener(scrollbarVars._handle, _strMouseTouchDownEvent, onHandleMouseTouchDown);
        addDestroyEventListener(scrollbarVars._track, [_strMouseTouchDownEvent, _strMouseEnter, _strMouseLeave], [onTrackMouseTouchDown, onTrackMouseTouchEnter, onTrackMouseTouchLeave]);
        addDestroyEventListener(scrollbarVars._scrollbar, _strMouseTouchDownEvent, onScrollbarMouseTouchDown);

        if (_supportTransition) {
          addDestroyEventListener(scrollbarVars._scrollbar, _strTransitionEndEvent, function (event) {
            if (event.target !== scrollbarVars._scrollbar[0]) return;
            refreshScrollbarHandleLength(isHorizontal);
            refreshScrollbarHandleOffset(isHorizontal);
          });
        }
      }
      /**
       * Shows or hides the given scrollbar and applied a class name which indicates if the scrollbar is scrollable or not.
       * @param isHorizontal True if the horizontal scrollbar is the target, false if the vertical scrollbar is the target.
       * @param shallBeVisible True if the scrollbar shall be shown, false if hidden.
       * @param canScroll True if the scrollbar is scrollable, false otherwise.
       */


      function refreshScrollbarAppearance(isHorizontal, shallBeVisible, canScroll) {
        var scrollbarHiddenClassName = isHorizontal ? _classNameHostScrollbarHorizontalHidden : _classNameHostScrollbarVerticalHidden;
        var scrollbarElement = isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement;
        addRemoveClass(_hostElement, scrollbarHiddenClassName, !shallBeVisible);
        addRemoveClass(scrollbarElement, _classNameScrollbarUnusable, !canScroll);
      }
      /**
       * Autoshows / autohides both scrollbars with.
       * @param shallBeVisible True if the scrollbars shall be autoshown (only the case if they are hidden by a autohide), false if the shall be auto hidden.
       * @param delayfree True if the scrollbars shall be hidden without a delay, false or undefined otherwise.
       */


      function refreshScrollbarsAutoHide(shallBeVisible, delayfree) {
        clearTimeout(_scrollbarsAutoHideTimeoutId);

        if (shallBeVisible) {
          //if(_hasOverflowCache.x && _hideOverflowCache.xs)
          removeClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden); //if(_hasOverflowCache.y && _hideOverflowCache.ys)

          removeClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
        } else {
          var anyActive;
          var strActive = 'active';

          var hide = function () {
            if (!_scrollbarsHandleHovered && !_destroyed) {
              anyActive = _scrollbarHorizontalHandleElement.hasClass(strActive) || _scrollbarVerticalHandleElement.hasClass(strActive);
              if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave)) addClass(_scrollbarHorizontalElement, _classNameScrollbarAutoHidden);
              if (!anyActive && (_scrollbarsAutoHideScroll || _scrollbarsAutoHideMove || _scrollbarsAutoHideLeave)) addClass(_scrollbarVerticalElement, _classNameScrollbarAutoHidden);
            }
          };

          if (_scrollbarsAutoHideDelay > 0 && delayfree !== true) _scrollbarsAutoHideTimeoutId = setTimeout(hide, _scrollbarsAutoHideDelay);else hide();
        }
      }
      /**
       * Refreshes the handle length of the given scrollbar.
       * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
       */


      function refreshScrollbarHandleLength(isHorizontal) {
        var handleCSS = {};
        var scrollbarVars = getScrollbarVars(isHorizontal);
        var scrollbarVarsInfo = scrollbarVars._info;
        var digit = 1000000; //get and apply intended handle length

        var handleRatio = MATH.min(1, (_hostSizeCache[scrollbarVars._w_h] - (_paddingAbsoluteCache ? isHorizontal ? _paddingX : _paddingY : 0)) / _contentScrollSizeCache[scrollbarVars._w_h]);
        handleCSS[scrollbarVars._width_height] = MATH.floor(handleRatio * 100 * digit) / digit + '%'; //the last * digit / digit is for flooring to the 4th digit

        if (!nativeOverlayScrollbarsAreActive()) scrollbarVars._handle.css(handleCSS); //measure the handle length to respect min & max length

        scrollbarVarsInfo._handleLength = scrollbarVars._handle[0]['offset' + scrollbarVars._Width_Height];
        scrollbarVarsInfo._handleLengthRatio = handleRatio;
      }
      /**
       * Refreshes the handle offset of the given scrollbar.
       * @param isHorizontal True if the horizontal scrollbar handle shall be refreshed, false if the vertical one shall be refreshed.
       * @param scrollOrTransition The scroll position of the given scrollbar axis to which the handle shall be moved or a boolean which indicates whether a transition shall be applied. If undefined or boolean if the current scroll-offset is taken. (if isHorizontal ? scrollLeft : scrollTop)
       */


      function refreshScrollbarHandleOffset(isHorizontal, scrollOrTransition) {
        var transition = type(scrollOrTransition) == TYPES.b;
        var transitionDuration = 250;
        var isRTLisHorizontal = _isRTL && isHorizontal;
        var scrollbarVars = getScrollbarVars(isHorizontal);
        var scrollbarVarsInfo = scrollbarVars._info;
        var strTranslateBrace = 'translate(';

        var strTransform = VENDORS._cssProperty('transform');

        var strTransition = VENDORS._cssProperty('transition');

        var nativeScroll = isHorizontal ? _viewportElement[_strScrollLeft]() : _viewportElement[_strScrollTop]();
        var currentScroll = scrollOrTransition === undefined || transition ? nativeScroll : scrollOrTransition; //measure the handle length to respect min & max length

        var handleLength = scrollbarVarsInfo._handleLength;
        var trackLength = scrollbarVars._track[0]['offset' + scrollbarVars._Width_Height];
        var handleTrackDiff = trackLength - handleLength;
        var handleCSS = {};
        var transformOffset;
        var translateValue; //DONT use the variable '_contentScrollSizeCache[scrollbarVars._w_h]' instead of '_viewportElement[0]['scroll' + scrollbarVars._Width_Height]'
        // because its a bit behind during the small delay when content size updates
        //(delay = mutationObserverContentLag, if its 0 then this var could be used)

        var maxScroll = (_viewportElementNative[_strScroll + scrollbarVars._Width_Height] - _viewportElementNative['client' + scrollbarVars._Width_Height]) * (_rtlScrollBehavior.n && isRTLisHorizontal ? -1 : 1); //* -1 if rtl scroll max is negative

        var getScrollRatio = function (base) {
          return isNaN(base / maxScroll) ? 0 : MATH.max(0, MATH.min(1, base / maxScroll));
        };

        var getHandleOffset = function (scrollRatio) {
          var offset = handleTrackDiff * scrollRatio;
          offset = isNaN(offset) ? 0 : offset;
          offset = isRTLisHorizontal && !_rtlScrollBehavior.i ? trackLength - handleLength - offset : offset;
          offset = MATH.max(0, offset);
          return offset;
        };

        var scrollRatio = getScrollRatio(nativeScroll);
        var unsnappedScrollRatio = getScrollRatio(currentScroll);
        var handleOffset = getHandleOffset(unsnappedScrollRatio);
        var snappedHandleOffset = getHandleOffset(scrollRatio);
        scrollbarVarsInfo._maxScroll = maxScroll;
        scrollbarVarsInfo._currentScroll = nativeScroll;
        scrollbarVarsInfo._currentScrollRatio = scrollRatio;

        if (_supportTransform) {
          transformOffset = isRTLisHorizontal ? -(trackLength - handleLength - handleOffset) : handleOffset; //in px
          //transformOffset = (transformOffset / trackLength * 100) * (trackLength / handleLength); //in %

          translateValue = isHorizontal ? strTranslateBrace + transformOffset + 'px, 0)' : strTranslateBrace + '0, ' + transformOffset + 'px)';
          handleCSS[strTransform] = translateValue; //apply or clear up transition

          if (_supportTransition) handleCSS[strTransition] = transition && MATH.abs(handleOffset - scrollbarVarsInfo._handleOffset) > 1 ? getCSSTransitionString(scrollbarVars._handle) + ', ' + (strTransform + _strSpace + transitionDuration + 'ms') : _strEmpty;
        } else handleCSS[scrollbarVars._left_top] = handleOffset; //only apply css if offset has changed and overflow exists.


        if (!nativeOverlayScrollbarsAreActive()) {
          scrollbarVars._handle.css(handleCSS); //clear up transition


          if (_supportTransform && _supportTransition && transition) {
            scrollbarVars._handle.one(_strTransitionEndEvent, function () {
              if (!_destroyed) scrollbarVars._handle.css(strTransition, _strEmpty);
            });
          }
        }

        scrollbarVarsInfo._handleOffset = handleOffset;
        scrollbarVarsInfo._snappedHandleOffset = snappedHandleOffset;
        scrollbarVarsInfo._trackLength = trackLength;
      }
      /**
       * Refreshes the interactivity of the given scrollbar element.
       * @param isTrack True if the track element is the target, false if the handle element is the target.
       * @param value True for interactivity false for no interactivity.
       */


      function refreshScrollbarsInteractive(isTrack, value) {
        var action = value ? 'removeClass' : 'addClass';
        var element1 = isTrack ? _scrollbarHorizontalTrackElement : _scrollbarHorizontalHandleElement;
        var element2 = isTrack ? _scrollbarVerticalTrackElement : _scrollbarVerticalHandleElement;
        var className = isTrack ? _classNameScrollbarTrackOff : _classNameScrollbarHandleOff;
        element1[action](className);
        element2[action](className);
      }
      /**
       * Returns a object which is used for fast access for specific variables.
       * @param isHorizontal True if the horizontal scrollbar vars shall be accessed, false if the vertical scrollbar vars shall be accessed.
       * @returns {{wh: string, WH: string, lt: string, _wh: string, _lt: string, t: *, h: *, c: {}, s: *}}
       */


      function getScrollbarVars(isHorizontal) {
        return {
          _width_height: isHorizontal ? _strWidth : _strHeight,
          _Width_Height: isHorizontal ? 'Width' : 'Height',
          _left_top: isHorizontal ? _strLeft : _strTop,
          _Left_Top: isHorizontal ? 'Left' : 'Top',
          _x_y: isHorizontal ? _strX : _strY,
          _X_Y: isHorizontal ? 'X' : 'Y',
          _w_h: isHorizontal ? 'w' : 'h',
          _l_t: isHorizontal ? 'l' : 't',
          _track: isHorizontal ? _scrollbarHorizontalTrackElement : _scrollbarVerticalTrackElement,
          _handle: isHorizontal ? _scrollbarHorizontalHandleElement : _scrollbarVerticalHandleElement,
          _scrollbar: isHorizontal ? _scrollbarHorizontalElement : _scrollbarVerticalElement,
          _info: isHorizontal ? _scrollHorizontalInfo : _scrollVerticalInfo
        };
      } //==== Scrollbar Corner ====//

      /**
       * Builds or destroys the scrollbar corner DOM element.
       * @param destroy Indicates whether the DOM shall be build or destroyed.
       */


      function setupScrollbarCornerDOM(destroy) {
        _scrollbarCornerElement = _scrollbarCornerElement || selectOrGenerateDivByClass(_classNameScrollbarCorner, true);

        if (!destroy) {
          if (!_domExists) {
            _hostElement.append(_scrollbarCornerElement);
          }
        } else {
          if (_domExists && _initialized) {
            removeClass(_scrollbarCornerElement.removeAttr(LEXICON.s), _classNamesDynamicDestroy);
          } else {
            remove(_scrollbarCornerElement);
          }
        }
      }
      /**
       * Initializes all scrollbar corner interactivity events.
       */


      function setupScrollbarCornerEvents() {
        var insideIFrame = _windowElementNative.top !== _windowElementNative;
        var mouseDownPosition = {};
        var mouseDownSize = {};
        var mouseDownInvertedScale = {};
        var reconnectMutationObserver;

        function documentDragMove(event) {
          if (onMouseTouchDownContinue(event)) {
            var pageOffset = getCoordinates(event);
            var hostElementCSS = {};
            if (_resizeHorizontal || _resizeBoth) hostElementCSS[_strWidth] = mouseDownSize.w + (pageOffset.x - mouseDownPosition.x) * mouseDownInvertedScale.x;
            if (_resizeVertical || _resizeBoth) hostElementCSS[_strHeight] = mouseDownSize.h + (pageOffset.y - mouseDownPosition.y) * mouseDownInvertedScale.y;

            _hostElement.css(hostElementCSS);

            COMPATIBILITY.stpP(event);
          } else {
            documentMouseTouchUp(event);
          }
        }

        function documentMouseTouchUp(event) {
          var eventIsTrusted = event !== undefined;
          setupResponsiveEventListener(_documentElement, [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent], [documentOnSelectStart, documentDragMove, documentMouseTouchUp], true);
          removeClass(_bodyElement, _classNameDragging);
          if (_scrollbarCornerElement.releaseCapture) _scrollbarCornerElement.releaseCapture();

          if (eventIsTrusted) {
            if (reconnectMutationObserver) connectMutationObservers();

            _base.update(_strAuto);
          }

          reconnectMutationObserver = false;
        }

        function onMouseTouchDownContinue(event) {
          var originalEvent = event.originalEvent || event;
          var isTouchEvent = originalEvent.touches !== undefined;
          return _sleeping || _destroyed ? false : COMPATIBILITY.mBtn(event) === 1 || isTouchEvent;
        }

        function getCoordinates(event) {
          return _msieVersion && insideIFrame ? {
            x: event.screenX,
            y: event.screenY
          } : COMPATIBILITY.page(event);
        }

        addDestroyEventListener(_scrollbarCornerElement, _strMouseTouchDownEvent, function (event) {
          if (onMouseTouchDownContinue(event) && !_resizeNone) {
            if (_mutationObserversConnected) {
              reconnectMutationObserver = true;
              disconnectMutationObservers();
            }

            mouseDownPosition = getCoordinates(event);
            mouseDownSize.w = _hostElementNative[LEXICON.oW] - (!_isBorderBox ? _paddingX : 0);
            mouseDownSize.h = _hostElementNative[LEXICON.oH] - (!_isBorderBox ? _paddingY : 0);
            mouseDownInvertedScale = getHostElementInvertedScale();
            setupResponsiveEventListener(_documentElement, [_strSelectStartEvent, _strMouseTouchMoveEvent, _strMouseTouchUpEvent], [documentOnSelectStart, documentDragMove, documentMouseTouchUp]);
            addClass(_bodyElement, _classNameDragging);
            if (_scrollbarCornerElement.setCapture) _scrollbarCornerElement.setCapture();
            COMPATIBILITY.prvD(event);
            COMPATIBILITY.stpP(event);
          }
        });
      } //==== Utils ====//

      /**
       * Calls the callback with the given name. The Context of this callback is always _base (this).
       * @param name The name of the target which shall be called.
       * @param args The args with which the callback shall be called.
       * @param dependent Boolean which decides whether the callback shall be fired, undefined is like a "true" value.
       */


      function dispatchCallback(name, args, dependent) {
        if (dependent === false) return;

        if (_initialized) {
          var callback = _currentPreparedOptions.callbacks[name];
          var extensionOnName = name;
          var ext;
          if (extensionOnName.substr(0, 2) === 'on') extensionOnName = extensionOnName.substr(2, 1).toLowerCase() + extensionOnName.substr(3);
          if (type(callback) == TYPES.f) callback.call(_base, args);
          each(_extensions, function () {
            ext = this;
            if (type(ext.on) == TYPES.f) ext.on(extensionOnName, args);
          });
        } else if (!_destroyed) _callbacksInitQeueue.push({
          n: name,
          a: args
        });
      }
      /**
       * Sets the "top, right, bottom, left" properties, with a given prefix, of the given css object.
       * @param targetCSSObject The css object to which the values shall be applied.
       * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
       * @param values A array of values which shall be applied to the "top, right, bottom, left" -properties. The array order is [top, right, bottom, left].
       * If this argument is undefined the value '' (empty string) will be applied to all properties.
       */


      function setTopRightBottomLeft(targetCSSObject, prefix, values) {
        prefix = prefix || _strEmpty;
        values = values || [_strEmpty, _strEmpty, _strEmpty, _strEmpty];
        targetCSSObject[prefix + _strTop] = values[0];
        targetCSSObject[prefix + _strRight] = values[1];
        targetCSSObject[prefix + _strBottom] = values[2];
        targetCSSObject[prefix + _strLeft] = values[3];
      }
      /**
       * Gets the "top, right, bottom, left" CSS properties of the CSS property with the given prefix from the host element.
       * @param prefix The prefix of the "top, right, bottom, left" css properties. (example: 'padding-' is a valid prefix)
       * @param suffix The suffix of the "top, right, bottom, left" css properties. (example: 'border-' is a valid prefix with '-width' is a valid suffix)
       * @param zeroX True if the x axis shall be 0.
       * @param zeroY True if the y axis shall be 0.
       * @returns {{}} The object which contains the numbers of the read CSS properties.
       */


      function getTopRightBottomLeftHost(prefix, suffix, zeroX, zeroY) {
        suffix = suffix || _strEmpty;
        prefix = prefix || _strEmpty;
        return {
          t: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strTop + suffix)),
          r: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strRight + suffix)),
          b: zeroY ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strBottom + suffix)),
          l: zeroX ? 0 : parseToZeroOrNumber(_hostElement.css(prefix + _strLeft + suffix))
        };
      }
      /**
       * Returns the computed CSS transition string from the given element.
       * @param element The element from which the transition string shall be returned.
       * @returns {string} The CSS transition string from the given element.
       */


      function getCSSTransitionString(element) {
        var transitionStr = VENDORS._cssProperty('transition');

        var assembledValue = element.css(transitionStr);
        if (assembledValue) return assembledValue;
        var regExpString = '\\s*(' + '([^,(]+(\\(.+?\\))?)+' + ')[\\s,]*';
        var regExpMain = new RegExp(regExpString);
        var regExpValidate = new RegExp('^(' + regExpString + ')+$');
        var properties = 'property duration timing-function delay'.split(' ');
        var result = [];
        var strResult;
        var valueArray;
        var i = 0;
        var j;

        var splitCssStyleByComma = function (str) {
          strResult = [];
          if (!str.match(regExpValidate)) return str;

          while (str.match(regExpMain)) {
            strResult.push(RegExp.$1);
            str = str.replace(regExpMain, _strEmpty);
          }

          return strResult;
        };

        for (; i < properties[LEXICON.l]; i++) {
          valueArray = splitCssStyleByComma(element.css(transitionStr + '-' + properties[i]));

          for (j = 0; j < valueArray[LEXICON.l]; j++) result[j] = (result[j] ? result[j] + _strSpace : _strEmpty) + valueArray[j];
        }

        return result.join(', ');
      }
      /**
       * Generates a Regular Expression which matches with a string which starts with 'os-host'.
       * @param {boolean} withCurrClassNameOption The Regular Expression also matches if the string is the current ClassName option (multiple values splitted by space possible).
       * @param {boolean} withOldClassNameOption The Regular Expression also matches if the string is the old ClassName option (multiple values splitted by space possible).
       */


      function createHostClassNameRegExp(withCurrClassNameOption, withOldClassNameOption) {
        var i;
        var split;
        var appendix;

        var appendClasses = function (classes, condition) {
          appendix = '';

          if (condition && typeof classes == TYPES.s) {
            split = classes.split(_strSpace);

            for (i = 0; i < split[LEXICON.l]; i++) appendix += '|' + split[i] + '$'; // split[i].replace(/[.*+?^${}()|[\]\\]/g, '\\$&') for escaping regex characters

          }

          return appendix;
        };

        return new RegExp('(^' + _classNameHostElement + '([-_].+|)$)' + appendClasses(_classNameCache, withCurrClassNameOption) + appendClasses(_oldClassName, withOldClassNameOption), 'g');
      }
      /**
       * Calculates the host-elements inverted scale. (invertedScale = 1 / scale)
       * @returns {{x: number, y: number}} The scale of the host-element.
       */


      function getHostElementInvertedScale() {
        var rect = _paddingElementNative[LEXICON.bCR]();

        return {
          x: _supportTransform ? 1 / (MATH.round(rect.width) / _paddingElementNative[LEXICON.oW]) || 1 : 1,
          y: _supportTransform ? 1 / (MATH.round(rect.height) / _paddingElementNative[LEXICON.oH]) || 1 : 1
        };
      }
      /**
       * Checks whether the given object is a HTMLElement.
       * @param o The object which shall be checked.
       * @returns {boolean} True the given object is a HTMLElement, false otherwise.
       */


      function isHTMLElement(o) {
        var strOwnerDocument = 'ownerDocument';
        var strHTMLElement = 'HTMLElement';
        var wnd = o && o[strOwnerDocument] ? o[strOwnerDocument].parentWindow || window : window;
        return typeof wnd[strHTMLElement] == TYPES.o ? o instanceof wnd[strHTMLElement] : //DOM2
        o && typeof o == TYPES.o && o !== null && o.nodeType === 1 && typeof o.nodeName == TYPES.s;
      }
      /**
       * Compares 2 arrays and returns the differences between them as a array.
       * @param a1 The first array which shall be compared.
       * @param a2 The second array which shall be compared.
       * @returns {Array} The differences between the two arrays.
       */


      function getArrayDifferences(a1, a2) {
        var a = [];
        var diff = [];
        var i;
        var k;

        for (i = 0; i < a1.length; i++) a[a1[i]] = true;

        for (i = 0; i < a2.length; i++) {
          if (a[a2[i]]) delete a[a2[i]];else a[a2[i]] = true;
        }

        for (k in a) diff.push(k);

        return diff;
      }
      /**
       * Returns Zero or the number to which the value can be parsed.
       * @param value The value which shall be parsed.
       * @param toFloat Indicates whether the number shall be parsed to a float.
       */


      function parseToZeroOrNumber(value, toFloat) {
        var num = toFloat ? parseFloat(value) : parseInt(value, 10);
        return isNaN(num) ? 0 : num;
      }
      /**
       * Gets several information of the textarea and returns them as a object or undefined if the browser doesn't support it.
       * @returns {{cursorRow: Number, cursorCol, rows: Number, cols: number, wRow: number, pos: number, max : number}} or undefined if not supported.
       */


      function getTextareaInfo() {
        //read needed values
        var textareaCursorPosition = _targetElementNative.selectionStart;
        if (textareaCursorPosition === undefined) return;

        var textareaValue = _targetElement.val();

        var textareaLength = textareaValue[LEXICON.l];
        var textareaRowSplit = textareaValue.split('\n');
        var textareaLastRow = textareaRowSplit[LEXICON.l];
        var textareaCurrentCursorRowSplit = textareaValue.substr(0, textareaCursorPosition).split('\n');
        var widestRow = 0;
        var textareaLastCol = 0;
        var cursorRow = textareaCurrentCursorRowSplit[LEXICON.l];
        var cursorCol = textareaCurrentCursorRowSplit[textareaCurrentCursorRowSplit[LEXICON.l] - 1][LEXICON.l];
        var rowCols;
        var i; //get widest Row and the last column of the textarea

        for (i = 0; i < textareaRowSplit[LEXICON.l]; i++) {
          rowCols = textareaRowSplit[i][LEXICON.l];

          if (rowCols > textareaLastCol) {
            widestRow = i + 1;
            textareaLastCol = rowCols;
          }
        }

        return {
          _cursorRow: cursorRow,
          //cursorRow
          _cursorColumn: cursorCol,
          //cursorCol
          _rows: textareaLastRow,
          //rows
          _columns: textareaLastCol,
          //cols
          _widestRow: widestRow,
          //wRow
          _cursorPosition: textareaCursorPosition,
          //pos
          _cursorMax: textareaLength //max

        };
      }
      /**
       * Determines whether native overlay scrollbars are active.
       * @returns {boolean} True if native overlay scrollbars are active, false otherwise.
       */


      function nativeOverlayScrollbarsAreActive() {
        return _ignoreOverlayScrollbarHidingCache && _nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y;
      }
      /**
       * Gets the element which is used to measure the content size.
       * @returns {*} TextareaCover if target element is textarea else the ContentElement.
       */


      function getContentMeasureElement() {
        return _isTextarea ? _textareaCoverElement[0] : _contentElementNative;
      }
      /**
       * Generates a string which represents a HTML div with the given classes or attributes.
       * @param classesOrAttrs The class of the div as string or a object which represents the attributes of the div. (The class attribute can also be written as "className".)
       * @param content The content of the div as string.
       * @returns {string} The concated string which represents a HTML div and its content.
       */


      function generateDiv(classesOrAttrs, content) {
        return '<div ' + (classesOrAttrs ? type(classesOrAttrs) == TYPES.s ? 'class="' + classesOrAttrs + '"' : function () {
          var key;
          var attrs = _strEmpty;

          if (FRAMEWORK.isPlainObject(classesOrAttrs)) {
            for (key in classesOrAttrs) attrs += (key === 'c' ? 'class' : key) + '="' + classesOrAttrs[key] + '" ';
          }

          return attrs;
        }() : _strEmpty) + '>' + (content || _strEmpty) + '</div>';
      }
      /**
       * Selects or generates a div with the given class attribute.
       * @param className The class names (divided by spaces) of the div which shall be selected or generated.
       * @param selectParentOrOnlyChildren The parent element from which of the element shall be selected. (if undefined or boolean its hostElement)
       * If its a boolean it decides whether only the children of the host element shall be selected.
       * @returns {*} The generated or selected element.
       */


      function selectOrGenerateDivByClass(className, selectParentOrOnlyChildren) {
        var onlyChildren = type(selectParentOrOnlyChildren) == TYPES.b;
        var selectParent = onlyChildren ? _hostElement : selectParentOrOnlyChildren || _hostElement;
        return _domExists && !selectParent[LEXICON.l] ? null : _domExists ? selectParent[onlyChildren ? 'children' : 'find'](_strDot + className.replace(/\s/g, _strDot)).eq(0) : FRAMEWORK(generateDiv(className));
      }
      /**
       * Gets the value of the given property from the given object.
       * @param obj The object from which the property value shall be got.
       * @param path The property of which the value shall be got.
       * @returns {*} Returns the value of the searched property or undefined of the property wasn't found.
       */


      function getObjectPropVal(obj, path) {
        var splits = path.split(_strDot);
        var i = 0;
        var val;

        for (; i < splits.length; i++) {
          if (!obj[LEXICON.hOP](splits[i])) return;
          val = obj[splits[i]];
          if (i < splits.length && type(val) == TYPES.o) obj = val;
        }

        return val;
      }
      /**
       * Sets the value of the given property from the given object.
       * @param obj The object from which the property value shall be set.
       * @param path The property of which the value shall be set.
       * @param val The value of the property which shall be set.
       */


      function setObjectPropVal(obj, path, val) {
        var splits = path.split(_strDot);
        var splitsLength = splits.length;
        var i = 0;
        var extendObj = {};
        var extendObjRoot = extendObj;

        for (; i < splitsLength; i++) extendObj = extendObj[splits[i]] = i + 1 < splitsLength ? {} : val;

        FRAMEWORK.extend(obj, extendObjRoot, true);
      }
      /**	
       * Runs a action for each selector inside the updateOnLoad option.	
       * @param {Function} action The action for each updateOnLoad selector, the arguments the function takes is the index and the value (the selector).	
       */


      function eachUpdateOnLoad(action) {
        var updateOnLoad = _currentPreparedOptions.updateOnLoad;
        updateOnLoad = type(updateOnLoad) == TYPES.s ? updateOnLoad.split(_strSpace) : updateOnLoad;

        if (COMPATIBILITY.isA(updateOnLoad) && !_destroyed) {
          each(updateOnLoad, action);
        }
      } //==== Utils Cache ====//

      /**
       * Compares two values or objects and returns true if they aren't equal.
       * @param current The first value or object which shall be compared.
       * @param cache The second value or object which shall be compared.
       * @param force If true the returned value is always true.
       * @returns {boolean} True if both values or objects aren't equal or force is true, false otherwise.
       */


      function checkCache(current, cache, force) {
        if (force) return force;

        if (type(current) == TYPES.o && type(cache) == TYPES.o) {
          for (var prop in current) {
            if (prop !== 'c') {
              if (current[LEXICON.hOP](prop) && cache[LEXICON.hOP](prop)) {
                if (checkCache(current[prop], cache[prop])) return true;
              } else {
                return true;
              }
            }
          }
        } else {
          return current !== cache;
        }

        return false;
      } //==== Shortcuts ====//

      /**
       * jQuery extend method shortcut with a appended "true" as first argument.
       */


      function extendDeep() {
        return FRAMEWORK.extend.apply(this, [true].concat([].slice.call(arguments)));
      }
      /**
       * jQuery addClass method shortcut.
       */


      function addClass(el, classes) {
        return _frameworkProto.addClass.call(el, classes);
      }
      /**
       * jQuery removeClass method shortcut.
       */


      function removeClass(el, classes) {
        return _frameworkProto.removeClass.call(el, classes);
      }
      /**
       * Adds or removes the given classes dependent on the boolean value. True for add, false for remove.
       */


      function addRemoveClass(el, classes, doAdd) {
        return doAdd ? addClass(el, classes) : removeClass(el, classes);
      }
      /**
       * jQuery remove method shortcut.
       */


      function remove(el) {
        return _frameworkProto.remove.call(el);
      }
      /**
       * Finds the first child element with the given selector of the given element.
       * @param el The root element from which the selector shall be valid.
       * @param selector The selector of the searched element.
       * @returns {*} The first element which is a child of the given element and matches the givens selector.
       */


      function findFirst(el, selector) {
        return _frameworkProto.find.call(el, selector).eq(0);
      } //==== API ====//

      /**
       * Puts the instance to sleep. It wont respond to any changes in the DOM and won't update. Scrollbar Interactivity is also disabled as well as the resize handle.
       * This behavior can be reset by calling the update method.
       */


      _base.sleep = function () {
        _sleeping = true;
      };
      /**
       * Updates the plugin and DOM to the current options.
       * This method should only be called if a update is 100% required.
       * @param force True if every property shall be updated and the cache shall be ignored.
       * !INTERNAL USAGE! : force can be a string "auto", "sync" or "zoom" too
       * if "auto" then before a real update the content size and host element attributes gets checked, and if they changed only then the update method will be called.
       * if "sync" then the async update process (MutationObserver or UpdateLoop) gets synchronized and a corresponding update takes place if one was needed due to pending changes.
       * if "zoom" then a update takes place where it's assumed that content and host size changed
       * @returns {boolean|undefined} 
       * If force is "sync" then a boolean is returned which indicates whether a update was needed due to pending changes.
       * If force is "auto" then a boolean is returned whether a update was needed due to attribute or size changes.
       * undefined otherwise.
       */


      _base.update = function (force) {
        if (_destroyed) return;
        var attrsChanged;
        var contentSizeC;
        var isString = type(force) == TYPES.s;
        var doUpdateAuto;
        var mutHost;
        var mutContent;

        if (isString) {
          if (force === _strAuto) {
            attrsChanged = meaningfulAttrsChanged();
            contentSizeC = updateAutoContentSizeChanged();
            doUpdateAuto = attrsChanged || contentSizeC;

            if (doUpdateAuto) {
              update({
                _contentSizeChanged: contentSizeC,
                _changedOptions: _initialized ? undefined : _currentPreparedOptions
              });
            }
          } else if (force === _strSync) {
            if (_mutationObserversConnected) {
              mutHost = _mutationObserverHostCallback(_mutationObserverHost.takeRecords());
              mutContent = _mutationObserverContentCallback(_mutationObserverContent.takeRecords());
            } else {
              mutHost = _base.update(_strAuto);
            }
          } else if (force === 'zoom') {
            update({
              _hostSizeChanged: true,
              _contentSizeChanged: true
            });
          }
        } else {
          force = _sleeping || force;
          _sleeping = false;
          if (!_base.update(_strSync) || force) update({
            _force: force
          });
        }

        updateElementsOnLoad();
        return doUpdateAuto || mutHost || mutContent;
      };
      /**
       Gets or sets the current options. The update method will be called automatically if new options were set.
       * @param newOptions If new options are given, then the new options will be set, if new options aren't given (undefined or a not a plain object) then the current options will be returned.
       * @param value If new options is a property path string, then this value will be used to set the option to which the property path string leads.
       * @returns {*}
       */


      _base.options = function (newOptions, value) {
        var option = {};
        var changedOps; //return current options if newOptions are undefined or empty

        if (FRAMEWORK.isEmptyObject(newOptions) || !FRAMEWORK.isPlainObject(newOptions)) {
          if (type(newOptions) == TYPES.s) {
            if (arguments.length > 1) {
              setObjectPropVal(option, newOptions, value);
              changedOps = setOptions(option);
            } else return getObjectPropVal(_currentOptions, newOptions);
          } else return _currentOptions;
        } else {
          changedOps = setOptions(newOptions);
        }

        if (!FRAMEWORK.isEmptyObject(changedOps)) {
          update({
            _changedOptions: changedOps
          });
        }
      };
      /**
       * Restore the DOM, disconnects all observers, remove all resize observers and put the instance to sleep.
       */


      _base.destroy = function () {
        if (_destroyed) return; //remove this instance from auto update loop

        autoUpdateLoop.remove(_base); //disconnect all mutation observers

        disconnectMutationObservers(); //remove all resize observers

        setupResizeObserver(_sizeObserverElement);
        setupResizeObserver(_sizeAutoObserverElement); //remove all extensions

        for (var extName in _extensions) _base.removeExt(extName); //remove all 'destroy' events


        while (_destroyEvents[LEXICON.l] > 0) _destroyEvents.pop()(); //remove all events from host element


        setupHostMouseTouchEvents(true); //remove all helper / detection elements

        if (_contentGlueElement) remove(_contentGlueElement);
        if (_contentArrangeElement) remove(_contentArrangeElement);
        if (_sizeAutoObserverAdded) remove(_sizeAutoObserverElement); //remove all generated DOM

        setupScrollbarsDOM(true);
        setupScrollbarCornerDOM(true);
        setupStructureDOM(true); //remove all generated image load events

        for (var i = 0; i < _updateOnLoadElms[LEXICON.l]; i++) FRAMEWORK(_updateOnLoadElms[i]).off(_updateOnLoadEventName, updateOnLoadCallback);

        _updateOnLoadElms = undefined;
        _destroyed = true;
        _sleeping = true; //remove this instance from the instances list

        INSTANCES(pluginTargetElement, 0);
        dispatchCallback('onDestroyed'); //remove all properties and methods
        //for (var property in _base)
        //    delete _base[property];
        //_base = undefined;
      };
      /**
       * Scrolls to a given position or element.
       * @param coordinates
       * 1. Can be "coordinates" which looks like:
       *    { x : ?, y : ? } OR          Object with x and y properties
       *    { left : ?, top : ? } OR     Object with left and top properties
       *    { l : ?, t : ? } OR          Object with l and t properties
       *    [ ?, ? ] OR                  Array where the first two element are the coordinates (first is x, second is y)
       *    ?                            A single value which stays for both axis
       *    A value can be a number, a string or a calculation.
       *
       *    Operators:
       *    [NONE]  The current scroll will be overwritten by the value.
       *    '+='    The value will be added to the current scroll offset
       *    '-='    The value will be subtracted from the current scroll offset
       *    '*='    The current scroll wil be multiplicated by the value.
       *    '/='    The current scroll wil be divided by the value.
       *
       *    Units:
       *    [NONE]  The value is the final scroll amount.                   final = (value * 1)
       *    'px'    Same as none
       *    '%'     The value is dependent on the current scroll value.     final = ((currentScrollValue / 100) * value)
       *    'vw'    The value is multiplicated by the viewport width.       final = (value * viewportWidth)
       *    'vh'    The value is multiplicated by the viewport height.      final = (value * viewportHeight)
       *
       *    example final values:
       *    200, '200px', '50%', '1vw', '1vh', '+=200', '/=1vw', '*=2px', '-=5vh', '+=33%', '+= 50% - 2px', '-= 1vw - 50%'
       *
       * 2. Can be a HTML or jQuery element:
       *    The final scroll offset is the offset (without margin) of the given HTML / jQuery element.
       *
       * 3. Can be a object with a HTML or jQuery element with additional settings:
       *    {
       *      el : [HTMLElement, jQuery element],             MUST be specified, else this object isn't valid.
       *      scroll : [string, array, object],               Default value is 'always'.
       *      block : [string, array, object],                Default value is 'begin'.
       *      margin : [number, boolean, array, object]       Default value is false.
       *    }
       *
       *    Possible scroll settings are:
       *    'always'      Scrolls always.
       *    'ifneeded'    Scrolls only if the element isnt fully in view.
       *    'never'       Scrolls never.
       *
       *    Possible block settings are:
       *    'begin'   Both axis shall be docked to the "begin" edge. - The element will be docked to the top and left edge of the viewport.
       *    'end'     Both axis shall be docked to the "end" edge. - The element will be docked to the bottom and right edge of the viewport. (If direction is RTL to the bottom and left edge.)
       *    'center'  Both axis shall be docked to "center". - The element will be centered in the viewport.
       *    'nearest' The element will be docked to the nearest edge(s).
       *
       *    Possible margin settings are: -- The actual margin of the element wont be affect, this option affects only the final scroll offset.
       *    [BOOLEAN]                                         If true the css margin of the element will be used, if false no margin will be used.
       *    [NUMBER]                                          The margin will be used for all edges.
       *
       * @param duration The duration of the scroll animation, OR a jQuery animation configuration object.
       * @param easing The animation easing.
       * @param complete The animation complete callback.
       * @returns {{
       *   position: {x: number, y: number},
       *   ratio: {x: number, y: number},
       *   max: {x: number, y: number},
       *   handleOffset: {x: number, y: number},
       *   handleLength: {x: number, y: number},
       *   handleLengthRatio: {x: number, y: number}, t
       *   rackLength: {x: number, y: number},
       *   isRTL: boolean,
       *   isRTLNormalized: boolean
       *  }}
       */


      _base.scroll = function (coordinates, duration, easing, complete) {
        if (arguments.length === 0 || coordinates === undefined) {
          var infoX = _scrollHorizontalInfo;
          var infoY = _scrollVerticalInfo;
          var normalizeInvert = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.i;
          var normalizeNegate = _normalizeRTLCache && _isRTL && _rtlScrollBehavior.n;
          var scrollX = infoX._currentScroll;
          var scrollXRatio = infoX._currentScrollRatio;
          var maxScrollX = infoX._maxScroll;
          scrollXRatio = normalizeInvert ? 1 - scrollXRatio : scrollXRatio;
          scrollX = normalizeInvert ? maxScrollX - scrollX : scrollX;
          scrollX *= normalizeNegate ? -1 : 1;
          maxScrollX *= normalizeNegate ? -1 : 1;
          return {
            position: {
              x: scrollX,
              y: infoY._currentScroll
            },
            ratio: {
              x: scrollXRatio,
              y: infoY._currentScrollRatio
            },
            max: {
              x: maxScrollX,
              y: infoY._maxScroll
            },
            handleOffset: {
              x: infoX._handleOffset,
              y: infoY._handleOffset
            },
            handleLength: {
              x: infoX._handleLength,
              y: infoY._handleLength
            },
            handleLengthRatio: {
              x: infoX._handleLengthRatio,
              y: infoY._handleLengthRatio
            },
            trackLength: {
              x: infoX._trackLength,
              y: infoY._trackLength
            },
            snappedHandleOffset: {
              x: infoX._snappedHandleOffset,
              y: infoY._snappedHandleOffset
            },
            isRTL: _isRTL,
            isRTLNormalized: _normalizeRTLCache
          };
        }

        _base.update(_strSync);

        var normalizeRTL = _normalizeRTLCache;
        var coordinatesXAxisProps = [_strX, _strLeft, 'l'];
        var coordinatesYAxisProps = [_strY, _strTop, 't'];
        var coordinatesOperators = ['+=', '-=', '*=', '/='];
        var durationIsObject = type(duration) == TYPES.o;
        var completeCallback = durationIsObject ? duration.complete : complete;
        var i;
        var finalScroll = {};
        var specialEasing = {};
        var doScrollLeft;
        var doScrollTop;
        var animationOptions;
        var strEnd = 'end';
        var strBegin = 'begin';
        var strCenter = 'center';
        var strNearest = 'nearest';
        var strAlways = 'always';
        var strNever = 'never';
        var strIfNeeded = 'ifneeded';
        var strLength = LEXICON.l;
        var settingsAxis;
        var settingsScroll;
        var settingsBlock;
        var settingsMargin;
        var finalElement;
        var elementObjSettingsAxisValues = [_strX, _strY, 'xy', 'yx'];
        var elementObjSettingsBlockValues = [strBegin, strEnd, strCenter, strNearest];
        var elementObjSettingsScrollValues = [strAlways, strNever, strIfNeeded];
        var coordinatesIsElementObj = coordinates[LEXICON.hOP]('el');
        var possibleElement = coordinatesIsElementObj ? coordinates.el : coordinates;
        var possibleElementIsJQuery = possibleElement instanceof FRAMEWORK || JQUERY ? possibleElement instanceof JQUERY : false;
        var possibleElementIsHTMLElement = possibleElementIsJQuery ? false : isHTMLElement(possibleElement);

        var updateScrollbarInfos = function () {
          if (doScrollLeft) refreshScrollbarHandleOffset(true);
          if (doScrollTop) refreshScrollbarHandleOffset(false);
        };

        var proxyCompleteCallback = type(completeCallback) != TYPES.f ? undefined : function () {
          updateScrollbarInfos();
          completeCallback();
        };

        function checkSettingsStringValue(currValue, allowedValues) {
          for (i = 0; i < allowedValues[strLength]; i++) {
            if (currValue === allowedValues[i]) return true;
          }

          return false;
        }

        function getRawScroll(isX, coordinates) {
          var coordinateProps = isX ? coordinatesXAxisProps : coordinatesYAxisProps;
          coordinates = type(coordinates) == TYPES.s || type(coordinates) == TYPES.n ? [coordinates, coordinates] : coordinates;
          if (COMPATIBILITY.isA(coordinates)) return isX ? coordinates[0] : coordinates[1];else if (type(coordinates) == TYPES.o) {
            //decides RTL normalization "hack" with .n
            //normalizeRTL = type(coordinates.n) == TYPES.b ? coordinates.n : normalizeRTL; 
            for (i = 0; i < coordinateProps[strLength]; i++) if (coordinateProps[i] in coordinates) return coordinates[coordinateProps[i]];
          }
        }

        function getFinalScroll(isX, rawScroll) {
          var isString = type(rawScroll) == TYPES.s;
          var operator;
          var amount;
          var scrollInfo = isX ? _scrollHorizontalInfo : _scrollVerticalInfo;
          var currScroll = scrollInfo._currentScroll;
          var maxScroll = scrollInfo._maxScroll;
          var mult = ' * ';
          var finalValue;
          var isRTLisX = _isRTL && isX;
          var normalizeShortcuts = isRTLisX && _rtlScrollBehavior.n && !normalizeRTL;
          var strReplace = 'replace';
          var evalFunc = eval;
          var possibleOperator;

          if (isString) {
            //check operator
            if (rawScroll[strLength] > 2) {
              possibleOperator = rawScroll.substr(0, 2);
              if (inArray(possibleOperator, coordinatesOperators) > -1) operator = possibleOperator;
            } //calculate units and shortcuts


            rawScroll = operator ? rawScroll.substr(2) : rawScroll;
            rawScroll = rawScroll[strReplace](/min/g, 0) //'min' = 0%
            [strReplace](/</g, 0) //'<'   = 0%
            [strReplace](/max/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent) //'max' = 100%
            [strReplace](/>/g, (normalizeShortcuts ? '-' : _strEmpty) + _strHundredPercent) //'>'   = 100%
            [strReplace](/px/g, _strEmpty)[strReplace](/%/g, mult + maxScroll * (isRTLisX && _rtlScrollBehavior.n ? -1 : 1) / 100.0)[strReplace](/vw/g, mult + _viewportSize.w)[strReplace](/vh/g, mult + _viewportSize.h);
            amount = parseToZeroOrNumber(isNaN(rawScroll) ? parseToZeroOrNumber(evalFunc(rawScroll), true).toFixed() : rawScroll);
          } else {
            amount = rawScroll;
          }

          if (amount !== undefined && !isNaN(amount) && type(amount) == TYPES.n) {
            var normalizeIsRTLisX = normalizeRTL && isRTLisX;
            var operatorCurrScroll = currScroll * (normalizeIsRTLisX && _rtlScrollBehavior.n ? -1 : 1);
            var invert = normalizeIsRTLisX && _rtlScrollBehavior.i;
            var negate = normalizeIsRTLisX && _rtlScrollBehavior.n;
            operatorCurrScroll = invert ? maxScroll - operatorCurrScroll : operatorCurrScroll;

            switch (operator) {
              case '+=':
                finalValue = operatorCurrScroll + amount;
                break;

              case '-=':
                finalValue = operatorCurrScroll - amount;
                break;

              case '*=':
                finalValue = operatorCurrScroll * amount;
                break;

              case '/=':
                finalValue = operatorCurrScroll / amount;
                break;

              default:
                finalValue = amount;
                break;
            }

            finalValue = invert ? maxScroll - finalValue : finalValue;
            finalValue *= negate ? -1 : 1;
            finalValue = isRTLisX && _rtlScrollBehavior.n ? MATH.min(0, MATH.max(maxScroll, finalValue)) : MATH.max(0, MATH.min(maxScroll, finalValue));
          }

          return finalValue === currScroll ? undefined : finalValue;
        }

        function getPerAxisValue(value, valueInternalType, defaultValue, allowedValues) {
          var resultDefault = [defaultValue, defaultValue];
          var valueType = type(value);
          var valueArrLength;
          var valueArrItem; //value can be [ string, or array of two strings ]

          if (valueType == valueInternalType) {
            value = [value, value];
          } else if (valueType == TYPES.a) {
            valueArrLength = value[strLength];
            if (valueArrLength > 2 || valueArrLength < 1) value = resultDefault;else {
              if (valueArrLength === 1) value[1] = defaultValue;

              for (i = 0; i < valueArrLength; i++) {
                valueArrItem = value[i];

                if (type(valueArrItem) != valueInternalType || !checkSettingsStringValue(valueArrItem, allowedValues)) {
                  value = resultDefault;
                  break;
                }
              }
            }
          } else if (valueType == TYPES.o) value = [value[_strX] || defaultValue, value[_strY] || defaultValue];else value = resultDefault;

          return {
            x: value[0],
            y: value[1]
          };
        }

        function generateMargin(marginTopRightBottomLeftArray) {
          var result = [];
          var currValue;
          var currValueType;
          var valueDirections = [_strTop, _strRight, _strBottom, _strLeft];

          for (i = 0; i < marginTopRightBottomLeftArray[strLength]; i++) {
            if (i === valueDirections[strLength]) break;
            currValue = marginTopRightBottomLeftArray[i];
            currValueType = type(currValue);
            if (currValueType == TYPES.b) result.push(currValue ? parseToZeroOrNumber(finalElement.css(_strMarginMinus + valueDirections[i])) : 0);else result.push(currValueType == TYPES.n ? currValue : 0);
          }

          return result;
        }

        if (possibleElementIsJQuery || possibleElementIsHTMLElement) {
          //get settings
          var margin = coordinatesIsElementObj ? coordinates.margin : 0;
          var axis = coordinatesIsElementObj ? coordinates.axis : 0;
          var scroll = coordinatesIsElementObj ? coordinates.scroll : 0;
          var block = coordinatesIsElementObj ? coordinates.block : 0;
          var marginDefault = [0, 0, 0, 0];
          var marginType = type(margin);
          var marginLength;
          finalElement = possibleElementIsJQuery ? possibleElement : FRAMEWORK(possibleElement);

          if (finalElement[strLength] > 0) {
            //margin can be [ boolean, number, array of 2, array of 4, object ]
            if (marginType == TYPES.n || marginType == TYPES.b) margin = generateMargin([margin, margin, margin, margin]);else if (marginType == TYPES.a) {
              marginLength = margin[strLength];
              if (marginLength === 2) margin = generateMargin([margin[0], margin[1], margin[0], margin[1]]);else if (marginLength >= 4) margin = generateMargin(margin);else margin = marginDefault;
            } else if (marginType == TYPES.o) margin = generateMargin([margin[_strTop], margin[_strRight], margin[_strBottom], margin[_strLeft]]);else margin = marginDefault; //block = type(block) === TYPES.b ? block ? [ strNearest, strBegin ] : [ strNearest, strEnd ] : block;

            settingsAxis = checkSettingsStringValue(axis, elementObjSettingsAxisValues) ? axis : 'xy';
            settingsScroll = getPerAxisValue(scroll, TYPES.s, strAlways, elementObjSettingsScrollValues);
            settingsBlock = getPerAxisValue(block, TYPES.s, strBegin, elementObjSettingsBlockValues);
            settingsMargin = margin;
            var viewportScroll = {
              l: _scrollHorizontalInfo._currentScroll,
              t: _scrollVerticalInfo._currentScroll
            }; // use padding element instead of viewport element because padding element has never padding, margin or position applied.

            var viewportOffset = _paddingElement.offset(); //get coordinates


            var elementOffset = finalElement.offset();
            var doNotScroll = {
              x: settingsScroll.x == strNever || settingsAxis == _strY,
              y: settingsScroll.y == strNever || settingsAxis == _strX
            };
            elementOffset[_strTop] -= settingsMargin[0];
            elementOffset[_strLeft] -= settingsMargin[3];
            var elementScrollCoordinates = {
              x: MATH.round(elementOffset[_strLeft] - viewportOffset[_strLeft] + viewportScroll.l),
              y: MATH.round(elementOffset[_strTop] - viewportOffset[_strTop] + viewportScroll.t)
            };

            if (_isRTL) {
              if (!_rtlScrollBehavior.n && !_rtlScrollBehavior.i) elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + viewportScroll.l);
              if (_rtlScrollBehavior.n && normalizeRTL) elementScrollCoordinates.x *= -1;
              if (_rtlScrollBehavior.i && normalizeRTL) elementScrollCoordinates.x = MATH.round(viewportOffset[_strLeft] - elementOffset[_strLeft] + (_scrollHorizontalInfo._maxScroll - viewportScroll.l));
            } //measuring is required


            if (settingsBlock.x != strBegin || settingsBlock.y != strBegin || settingsScroll.x == strIfNeeded || settingsScroll.y == strIfNeeded || _isRTL) {
              var measuringElm = finalElement[0];
              var rawElementSize = _supportTransform ? measuringElm[LEXICON.bCR]() : {
                width: measuringElm[LEXICON.oW],
                height: measuringElm[LEXICON.oH]
              };
              var elementSize = {
                w: rawElementSize[_strWidth] + settingsMargin[3] + settingsMargin[1],
                h: rawElementSize[_strHeight] + settingsMargin[0] + settingsMargin[2]
              };

              var finalizeBlock = function (isX) {
                var vars = getScrollbarVars(isX);
                var wh = vars._w_h;
                var lt = vars._left_top;
                var xy = vars._x_y;
                var blockIsEnd = settingsBlock[xy] == (isX ? _isRTL ? strBegin : strEnd : strEnd);
                var blockIsCenter = settingsBlock[xy] == strCenter;
                var blockIsNearest = settingsBlock[xy] == strNearest;
                var scrollNever = settingsScroll[xy] == strNever;
                var scrollIfNeeded = settingsScroll[xy] == strIfNeeded;
                var vpSize = _viewportSize[wh];
                var vpOffset = viewportOffset[lt];
                var elSize = elementSize[wh];
                var elOffset = elementOffset[lt];
                var divide = blockIsCenter ? 2 : 1;
                var elementCenterOffset = elOffset + elSize / 2;
                var viewportCenterOffset = vpOffset + vpSize / 2;
                var isInView = elSize <= vpSize && elOffset >= vpOffset && elOffset + elSize <= vpOffset + vpSize;
                if (scrollNever) doNotScroll[xy] = true;else if (!doNotScroll[xy]) {
                  if (blockIsNearest || scrollIfNeeded) {
                    doNotScroll[xy] = scrollIfNeeded ? isInView : false;
                    blockIsEnd = elSize < vpSize ? elementCenterOffset > viewportCenterOffset : elementCenterOffset < viewportCenterOffset;
                  }

                  elementScrollCoordinates[xy] -= blockIsEnd || blockIsCenter ? (vpSize / divide - elSize / divide) * (isX && _isRTL && normalizeRTL ? -1 : 1) : 0;
                }
              };

              finalizeBlock(true);
              finalizeBlock(false);
            }

            if (doNotScroll.y) delete elementScrollCoordinates.y;
            if (doNotScroll.x) delete elementScrollCoordinates.x;
            coordinates = elementScrollCoordinates;
          }
        }

        finalScroll[_strScrollLeft] = getFinalScroll(true, getRawScroll(true, coordinates));
        finalScroll[_strScrollTop] = getFinalScroll(false, getRawScroll(false, coordinates));
        doScrollLeft = finalScroll[_strScrollLeft] !== undefined;
        doScrollTop = finalScroll[_strScrollTop] !== undefined;

        if ((doScrollLeft || doScrollTop) && (duration > 0 || durationIsObject)) {
          if (durationIsObject) {
            duration.complete = proxyCompleteCallback;

            _viewportElement.animate(finalScroll, duration);
          } else {
            animationOptions = {
              duration: duration,
              complete: proxyCompleteCallback
            };

            if (COMPATIBILITY.isA(easing) || FRAMEWORK.isPlainObject(easing)) {
              specialEasing[_strScrollLeft] = easing[0] || easing.x;
              specialEasing[_strScrollTop] = easing[1] || easing.y;
              animationOptions.specialEasing = specialEasing;
            } else {
              animationOptions.easing = easing;
            }

            _viewportElement.animate(finalScroll, animationOptions);
          }
        } else {
          if (doScrollLeft) _viewportElement[_strScrollLeft](finalScroll[_strScrollLeft]);
          if (doScrollTop) _viewportElement[_strScrollTop](finalScroll[_strScrollTop]);
          updateScrollbarInfos();
        }
      };
      /**
       * Stops all scroll animations.
       * @returns {*} The current OverlayScrollbars instance (for chaining).
       */


      _base.scrollStop = function (param1, param2, param3) {
        _viewportElement.stop(param1, param2, param3);

        return _base;
      };
      /**
       * Returns all relevant elements.
       * @param elementName The name of the element which shall be returned.
       * @returns {{target: *, host: *, padding: *, viewport: *, content: *, scrollbarHorizontal: {scrollbar: *, track: *, handle: *}, scrollbarVertical: {scrollbar: *, track: *, handle: *}, scrollbarCorner: *} | *}
       */


      _base.getElements = function (elementName) {
        var obj = {
          target: _targetElementNative,
          host: _hostElementNative,
          padding: _paddingElementNative,
          viewport: _viewportElementNative,
          content: _contentElementNative,
          scrollbarHorizontal: {
            scrollbar: _scrollbarHorizontalElement[0],
            track: _scrollbarHorizontalTrackElement[0],
            handle: _scrollbarHorizontalHandleElement[0]
          },
          scrollbarVertical: {
            scrollbar: _scrollbarVerticalElement[0],
            track: _scrollbarVerticalTrackElement[0],
            handle: _scrollbarVerticalHandleElement[0]
          },
          scrollbarCorner: _scrollbarCornerElement[0]
        };
        return type(elementName) == TYPES.s ? getObjectPropVal(obj, elementName) : obj;
      };
      /**
       * Returns a object which describes the current state of this instance.
       * @param stateProperty A specific property from the state object which shall be returned.
       * @returns {{widthAuto, heightAuto, overflowAmount, hideOverflow, hasOverflow, contentScrollSize, viewportSize, hostSize, autoUpdate} | *}
       */


      _base.getState = function (stateProperty) {
        function prepare(obj) {
          if (!FRAMEWORK.isPlainObject(obj)) return obj;
          var extended = extendDeep({}, obj);

          var changePropertyName = function (from, to) {
            if (extended[LEXICON.hOP](from)) {
              extended[to] = extended[from];
              delete extended[from];
            }
          };

          changePropertyName('w', _strWidth); //change w to width

          changePropertyName('h', _strHeight); //change h to height

          delete extended.c; //delete c (the 'changed' prop)

          return extended;
        }

        ;
        var obj = {
          destroyed: !!prepare(_destroyed),
          sleeping: !!prepare(_sleeping),
          autoUpdate: prepare(!_mutationObserversConnected),
          widthAuto: prepare(_widthAutoCache),
          heightAuto: prepare(_heightAutoCache),
          padding: prepare(_cssPaddingCache),
          overflowAmount: prepare(_overflowAmountCache),
          hideOverflow: prepare(_hideOverflowCache),
          hasOverflow: prepare(_hasOverflowCache),
          contentScrollSize: prepare(_contentScrollSizeCache),
          viewportSize: prepare(_viewportSize),
          hostSize: prepare(_hostSizeCache),
          documentMixed: prepare(_documentMixed)
        };
        return type(stateProperty) == TYPES.s ? getObjectPropVal(obj, stateProperty) : obj;
      };
      /**
       * Gets all or specific extension instance.
       * @param extName The name of the extension from which the instance shall be got.
       * @returns {{}} The instance of the extension with the given name or undefined if the instance couldn't be found.
       */


      _base.ext = function (extName) {
        var result;

        var privateMethods = _extensionsPrivateMethods.split(' ');

        var i = 0;

        if (type(extName) == TYPES.s) {
          if (_extensions[LEXICON.hOP](extName)) {
            result = extendDeep({}, _extensions[extName]);

            for (; i < privateMethods.length; i++) delete result[privateMethods[i]];
          }
        } else {
          result = {};

          for (i in _extensions) result[i] = extendDeep({}, _base.ext(i));
        }

        return result;
      };
      /**
       * Adds a extension to this instance.
       * @param extName The name of the extension which shall be added.
       * @param extensionOptions The extension options which shall be used.
       * @returns {{}} The instance of the added extension or undefined if the extension couldn't be added properly.
       */


      _base.addExt = function (extName, extensionOptions) {
        var registeredExtensionObj = _plugin.extension(extName);

        var instance;
        var instanceAdded;
        var instanceContract;
        var contractResult;
        var contractFulfilled = true;

        if (registeredExtensionObj) {
          if (!_extensions[LEXICON.hOP](extName)) {
            instance = registeredExtensionObj.extensionFactory.call(_base, extendDeep({}, registeredExtensionObj.defaultOptions), FRAMEWORK, COMPATIBILITY);

            if (instance) {
              instanceContract = instance.contract;

              if (type(instanceContract) == TYPES.f) {
                contractResult = instanceContract(window);
                contractFulfilled = type(contractResult) == TYPES.b ? contractResult : contractFulfilled;
              }

              if (contractFulfilled) {
                _extensions[extName] = instance;
                instanceAdded = instance.added;
                if (type(instanceAdded) == TYPES.f) instanceAdded(extensionOptions);
                return _base.ext(extName);
              }
            }
          } else return _base.ext(extName);
        } else console.warn("A extension with the name \"" + extName + "\" isn't registered.");
      };
      /**
       * Removes a extension from this instance.
       * @param extName The name of the extension which shall be removed.
       * @returns {boolean} True if the extension was removed, false otherwise e.g. if the extension wasn't added before.
       */


      _base.removeExt = function (extName) {
        var instance = _extensions[extName];
        var instanceRemoved;

        if (instance) {
          delete _extensions[extName];
          instanceRemoved = instance.removed;
          if (type(instanceRemoved) == TYPES.f) instanceRemoved();
          return true;
        }

        return false;
      };
      /**
       * Constructs the plugin.
       * @param targetElement The element to which the plugin shall be applied.
       * @param options The initial options of the plugin.
       * @param extensions The extension(s) which shall be added right after the initialization.
       * @returns {boolean} True if the plugin was successfully initialized, false otherwise.
       */


      function construct(targetElement, options, extensions) {
        _defaultOptions = globals.defaultOptions;
        _nativeScrollbarStyling = globals.nativeScrollbarStyling;
        _nativeScrollbarSize = extendDeep({}, globals.nativeScrollbarSize);
        _nativeScrollbarIsOverlaid = extendDeep({}, globals.nativeScrollbarIsOverlaid);
        _overlayScrollbarDummySize = extendDeep({}, globals.overlayScrollbarDummySize);
        _rtlScrollBehavior = extendDeep({}, globals.rtlScrollBehavior); //parse & set options but don't update

        setOptions(extendDeep({}, _defaultOptions, options));
        _cssCalc = globals.cssCalc;
        _msieVersion = globals.msie;
        _autoUpdateRecommended = globals.autoUpdateRecommended;
        _supportTransition = globals.supportTransition;
        _supportTransform = globals.supportTransform;
        _supportPassiveEvents = globals.supportPassiveEvents;
        _supportResizeObserver = globals.supportResizeObserver;
        _supportMutationObserver = globals.supportMutationObserver;
        _restrictedMeasuring = globals.restrictedMeasuring;
        _documentElement = FRAMEWORK(targetElement.ownerDocument);
        _documentElementNative = _documentElement[0];
        _windowElement = FRAMEWORK(_documentElementNative.defaultView || _documentElementNative.parentWindow);
        _windowElementNative = _windowElement[0];
        _htmlElement = findFirst(_documentElement, 'html');
        _bodyElement = findFirst(_htmlElement, 'body');
        _targetElement = FRAMEWORK(targetElement);
        _targetElementNative = _targetElement[0];
        _isTextarea = _targetElement.is('textarea');
        _isBody = _targetElement.is('body');
        _documentMixed = _documentElementNative !== document;
        /* On a div Element The if checks only whether:
         * - the targetElement has the class "os-host"
         * - the targetElement has a a child with the class "os-padding"
         * 
         * If that's the case, its assumed the DOM has already the following structure:
         * (The ".os-host" element is the targetElement)
         *
         *  <div class="os-host">
         *      <div class="os-resize-observer-host"></div>
         *      <div class="os-padding">
         *          <div class="os-viewport">
         *              <div class="os-content"></div>
         *          </div>
         *      </div>
         *      <div class="os-scrollbar os-scrollbar-horizontal ">
         *          <div class="os-scrollbar-track">
         *              <div class="os-scrollbar-handle"></div>
         *          </div>
         *      </div>
         *      <div class="os-scrollbar os-scrollbar-vertical">
         *          <div class="os-scrollbar-track">
         *              <div class="os-scrollbar-handle"></div>
         *          </div>
         *      </div>
         *      <div class="os-scrollbar-corner"></div>
         *  </div>
         *
         * =====================================================================================
         * 
         * On a Textarea Element The if checks only whether:
         * - the targetElement has the class "os-textarea" 
         * - the targetElement is inside a element with the class "os-content" 
         * 
         * If that's the case, its assumed the DOM has already the following structure:
         * (The ".os-textarea" (textarea) element is the targetElement)
         *
         *  <div class="os-host-textarea">
         *      <div class="os-resize-observer-host"></div>
         *      <div class="os-padding os-text-inherit">
         *          <div class="os-viewport os-text-inherit">
         *              <div class="os-content os-text-inherit">
         *                  <div class="os-textarea-cover"></div>
         *                  <textarea class="os-textarea os-text-inherit"></textarea>
         *              </div>
         *          </div>
         *      </div>
         *      <div class="os-scrollbar os-scrollbar-horizontal ">
         *          <div class="os-scrollbar-track">
         *              <div class="os-scrollbar-handle"></div>
         *          </div>
         *      </div>
         *      <div class="os-scrollbar os-scrollbar-vertical">
         *          <div class="os-scrollbar-track">
         *              <div class="os-scrollbar-handle"></div>
         *          </div>
         *      </div>
         *      <div class="os-scrollbar-corner"></div>
         *  </div>
         */

        _domExists = _isTextarea ? _targetElement.hasClass(_classNameTextareaElement) && _targetElement.parent().hasClass(_classNameContentElement) : _targetElement.hasClass(_classNameHostElement) && _targetElement.children(_strDot + _classNamePaddingElement)[LEXICON.l];
        var initBodyScroll;
        var bodyMouseTouchDownListener; //check if the plugin hasn't to be initialized

        if (_nativeScrollbarIsOverlaid.x && _nativeScrollbarIsOverlaid.y && !_currentPreparedOptions.nativeScrollbarsOverlaid.initialize) {
          dispatchCallback('onInitializationWithdrawn');

          if (_domExists) {
            setupStructureDOM(true);
            setupScrollbarsDOM(true);
            setupScrollbarCornerDOM(true);
          }

          _destroyed = true;
          _sleeping = true;
          return _base;
        }

        if (_isBody) {
          initBodyScroll = {};
          initBodyScroll.l = MATH.max(_targetElement[_strScrollLeft](), _htmlElement[_strScrollLeft](), _windowElement[_strScrollLeft]());
          initBodyScroll.t = MATH.max(_targetElement[_strScrollTop](), _htmlElement[_strScrollTop](), _windowElement[_strScrollTop]());

          bodyMouseTouchDownListener = function () {
            _viewportElement.removeAttr(LEXICON.ti);

            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, true, true);
          };
        } //build OverlayScrollbars DOM


        setupStructureDOM();
        setupScrollbarsDOM();
        setupScrollbarCornerDOM(); //create OverlayScrollbars events

        setupStructureEvents();
        setupScrollbarEvents(true);
        setupScrollbarEvents(false);
        setupScrollbarCornerEvents(); //create mutation observers

        createMutationObservers(); //build resize observer for the host element

        setupResizeObserver(_sizeObserverElement, hostOnResized);

        if (_isBody) {
          //apply the body scroll to handle it right in the update method
          _viewportElement[_strScrollLeft](initBodyScroll.l)[_strScrollTop](initBodyScroll.t); //set the focus on the viewport element so you dont have to click on the page to use keyboard keys (up / down / space) for scrolling


          if (document.activeElement == targetElement && _viewportElementNative.focus) {
            //set a tabindex to make the viewportElement focusable
            _viewportElement.attr(LEXICON.ti, '-1');

            _viewportElementNative.focus();
            /* the tabindex has to be removed due to;
             * If you set the tabindex attribute on an <div>, then its child content cannot be scrolled with the arrow keys unless you set tabindex on the content, too
             * https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes/tabindex
             */


            setupResponsiveEventListener(_viewportElement, _strMouseTouchDownEvent, bodyMouseTouchDownListener, false, true);
          }
        } //update for the first time & initialize cache


        _base.update(_strAuto); //the plugin is initialized now!


        _initialized = true;
        dispatchCallback('onInitialized'); //call all callbacks which would fire before the initialized was complete

        each(_callbacksInitQeueue, function (index, value) {
          dispatchCallback(value.n, value.a);
        });
        _callbacksInitQeueue = []; //add extensions

        if (type(extensions) == TYPES.s) extensions = [extensions];
        if (COMPATIBILITY.isA(extensions)) each(extensions, function (index, value) {
          _base.addExt(value);
        });else if (FRAMEWORK.isPlainObject(extensions)) each(extensions, function (key, value) {
          _base.addExt(key, value);
        }); //add the transition class for transitions AFTER the first update & AFTER the applied extensions (for preventing unwanted transitions)

        setTimeout(function () {
          if (_supportTransition && !_destroyed) addClass(_hostElement, _classNameHostTransition);
        }, 333);
        return _base;
      }

      if (_plugin.valid(construct(pluginTargetElement, options, extensions))) {
        INSTANCES(pluginTargetElement, _base);
      }

      return _base;
    }
    /**
     * Initializes a new OverlayScrollbarsInstance object or changes options if already initialized or returns the current instance.
     * @param pluginTargetElements The elements to which the Plugin shall be initialized.
     * @param options The custom options with which the plugin shall be initialized.
     * @param extensions The extension(s) which shall be added right after initialization.
     * @returns {*}
     */


    _plugin = window[PLUGINNAME] = function (pluginTargetElements, options, extensions) {
      if (arguments[LEXICON.l] === 0) return this;
      var arr = [];
      var optsIsPlainObj = FRAMEWORK.isPlainObject(options);
      var inst;
      var result; //pluginTargetElements is null or undefined

      if (!pluginTargetElements) return optsIsPlainObj || !options ? result : arr;
      /*
         pluginTargetElements will be converted to:
         1. A jQueryElement Array
         2. A HTMLElement Array
         3. A Array with a single HTML Element
         so pluginTargetElements is always a array.
      */

      pluginTargetElements = pluginTargetElements[LEXICON.l] != undefined ? pluginTargetElements : [pluginTargetElements[0] || pluginTargetElements];
      initOverlayScrollbarsStatics();

      if (pluginTargetElements[LEXICON.l] > 0) {
        if (optsIsPlainObj) {
          FRAMEWORK.each(pluginTargetElements, function (i, v) {
            inst = v;
            if (inst !== undefined) arr.push(OverlayScrollbarsInstance(inst, options, extensions, _pluginsGlobals, _pluginsAutoUpdateLoop));
          });
        } else {
          FRAMEWORK.each(pluginTargetElements, function (i, v) {
            inst = INSTANCES(v);
            if (options === '!' && _plugin.valid(inst) || COMPATIBILITY.type(options) == TYPES.f && options(v, inst)) arr.push(inst);else if (options === undefined) arr.push(inst);
          });
        }

        result = arr[LEXICON.l] === 1 ? arr[0] : arr;
      }

      return result;
    };
    /**
     * Returns a object which contains global information about the plugin and each instance of it.
     * The returned object is just a copy, that means that changes to the returned object won't have any effect to the original object.
     */


    _plugin.globals = function () {
      initOverlayScrollbarsStatics();
      var globals = FRAMEWORK.extend(true, {}, _pluginsGlobals);
      delete globals['msie'];
      return globals;
    };
    /**
     * Gets or Sets the default options for each new plugin initialization.
     * @param newDefaultOptions The object with which the default options shall be extended.
     */


    _plugin.defaultOptions = function (newDefaultOptions) {
      initOverlayScrollbarsStatics();
      var currDefaultOptions = _pluginsGlobals.defaultOptions;
      if (newDefaultOptions === undefined) return FRAMEWORK.extend(true, {}, currDefaultOptions); //set the new default options

      _pluginsGlobals.defaultOptions = FRAMEWORK.extend(true, {}, currDefaultOptions, _pluginsOptions._validate(newDefaultOptions, _pluginsOptions._template, true, currDefaultOptions)._default);
    };
    /**
     * Checks whether the passed instance is a non-destroyed OverlayScrollbars instance.
     * @param osInstance The potential OverlayScrollbars instance which shall be checked.
     * @returns {boolean} True if the passed value is a non-destroyed OverlayScrollbars instance, false otherwise.
     */


    _plugin.valid = function (osInstance) {
      return osInstance instanceof _plugin && !osInstance.getState().destroyed;
    };
    /**
     * Registers, Unregisters or returns a extension.
     * Register: Pass the name and the extension. (defaultOptions is optional)
     * Unregister: Pass the name and anything except a function as extension parameter.
     * Get extension: Pass the name of the extension which shall be got.
     * Get all extensions: Pass no arguments.
     * @param extensionName The name of the extension which shall be registered, unregistered or returned.
     * @param extension A function which generates the instance of the extension or anything other to remove a already registered extension.
     * @param defaultOptions The default options which shall be used for the registered extension.
     */


    _plugin.extension = function (extensionName, extension, defaultOptions) {
      var extNameTypeString = COMPATIBILITY.type(extensionName) == TYPES.s;
      var argLen = arguments[LEXICON.l];
      var i = 0;

      if (argLen < 1 || !extNameTypeString) {
        //return a copy of all extension objects
        return FRAMEWORK.extend(true, {
          length: _pluginsExtensions[LEXICON.l]
        }, _pluginsExtensions);
      } else if (extNameTypeString) {
        if (COMPATIBILITY.type(extension) == TYPES.f) {
          //register extension
          _pluginsExtensions.push({
            name: extensionName,
            extensionFactory: extension,
            defaultOptions: defaultOptions
          });
        } else {
          for (; i < _pluginsExtensions[LEXICON.l]; i++) {
            if (_pluginsExtensions[i].name === extensionName) {
              if (argLen > 1) _pluginsExtensions.splice(i, 1); //remove extension
              else return FRAMEWORK.extend(true, {}, _pluginsExtensions[i]); //return extension with the given name
            }
          }
        }
      }
    };

    return _plugin;
  }();

  if (JQUERY && JQUERY.fn) {
    /**
     * The jQuery initialization interface.
     * @param options The initial options for the construction of the plugin. To initialize the plugin, this option has to be a object! If it isn't a object, the instance(s) are returned and the plugin wont be initialized.
     * @param extensions The extension(s) which shall be added right after initialization.
     * @returns {*} After initialization it returns the jQuery element array, else it returns the instance(s) of the elements which are selected.
     */
    JQUERY.fn.overlayScrollbars = function (options, extensions) {
      var _elements = this;

      if (JQUERY.isPlainObject(options)) {
        JQUERY.each(_elements, function () {
          PLUGIN(this, options, extensions);
        });
        return _elements;
      } else return PLUGIN(_elements, options);
    };
  }

  return PLUGIN;
});
/*!
 * smooth-scroll v16.1.3
 * Animate scrolling to anchor links
 * (c) 2020 Chris Ferdinandi
 * MIT License
 * http://github.com/cferdinandi/smooth-scroll
 */
(function (root, factory) {
  if (typeof define === 'function' && define.amd) {
    define([], function () {
      return factory(root);
    });
  } else if (typeof exports === 'object') {
    module.exports = factory(root);
  } else {
    root.SmoothScroll = factory(root);
  }
})(typeof global !== 'undefined' ? global : typeof window !== 'undefined' ? window : this, function (window) {
  'use strict'; //
  // Default settings
  //

  var defaults = {
    // Selectors
    ignore: '[data-scroll-ignore]',
    header: null,
    topOnEmptyHash: true,
    // Speed & Duration
    speed: 500,
    speedAsDuration: false,
    durationMax: null,
    durationMin: null,
    clip: true,
    offset: 0,
    // Easing
    easing: 'easeInOutCubic',
    customEasing: null,
    // History
    updateURL: true,
    popstate: true,
    // Custom Events
    emitEvents: true
  }; //
  // Utility Methods
  //

  /**
   * Check if browser supports required methods
   * @return {Boolean} Returns true if all required methods are supported
   */

  var supports = function () {
    return 'querySelector' in document && 'addEventListener' in window && 'requestAnimationFrame' in window && 'closest' in window.Element.prototype;
  };
  /**
   * Merge two or more objects together.
   * @param   {Object}   objects  The objects to merge together
   * @returns {Object}            Merged values of defaults and options
   */


  var extend = function () {
    var merged = {};
    Array.prototype.forEach.call(arguments, function (obj) {
      for (var key in obj) {
        if (!obj.hasOwnProperty(key)) return;
        merged[key] = obj[key];
      }
    });
    return merged;
  };
  /**
   * Check to see if user prefers reduced motion
   * @param  {Object} settings Script settings
   */


  var reduceMotion = function () {
    if ('matchMedia' in window && window.matchMedia('(prefers-reduced-motion)').matches) {
      return true;
    }

    return false;
  };
  /**
   * Get the height of an element.
   * @param  {Node} elem The element to get the height of
   * @return {Number}    The element's height in pixels
   */


  var getHeight = function (elem) {
    return parseInt(window.getComputedStyle(elem).height, 10);
  };
  /**
   * Escape special characters for use with querySelector
   * @author Mathias Bynens
   * @link https://github.com/mathiasbynens/CSS.escape
   * @param {String} id The anchor ID to escape
   */


  var escapeCharacters = function (id) {
    // Remove leading hash
    if (id.charAt(0) === '#') {
      id = id.substr(1);
    }

    var string = String(id);
    var length = string.length;
    var index = -1;
    var codeUnit;
    var result = '';
    var firstCodeUnit = string.charCodeAt(0);

    while (++index < length) {
      codeUnit = string.charCodeAt(index); // Note: there’s no need to special-case astral symbols, surrogate
      // pairs, or lone surrogates.
      // If the character is NULL (U+0000), then throw an
      // `InvalidCharacterError` exception and terminate these steps.

      if (codeUnit === 0x0000) {
        throw new InvalidCharacterError('Invalid character: the input contains U+0000.');
      }

      if ( // If the character is in the range [\1-\1F] (U+0001 to U+001F) or is
      // U+007F, […]
      codeUnit >= 0x0001 && codeUnit <= 0x001F || codeUnit == 0x007F || // If the character is the first character and is in the range [0-9]
      // (U+0030 to U+0039), […]
      index === 0 && codeUnit >= 0x0030 && codeUnit <= 0x0039 || // If the character is the second character and is in the range [0-9]
      // (U+0030 to U+0039) and the first character is a `-` (U+002D), […]
      index === 1 && codeUnit >= 0x0030 && codeUnit <= 0x0039 && firstCodeUnit === 0x002D) {
        // http://dev.w3.org/csswg/cssom/#escape-a-character-as-code-point
        result += '\\' + codeUnit.toString(16) + ' ';
        continue;
      } // If the character is not handled by one of the above rules and is
      // greater than or equal to U+0080, is `-` (U+002D) or `_` (U+005F), or
      // is in one of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to
      // U+005A), or [a-z] (U+0061 to U+007A), […]


      if (codeUnit >= 0x0080 || codeUnit === 0x002D || codeUnit === 0x005F || codeUnit >= 0x0030 && codeUnit <= 0x0039 || codeUnit >= 0x0041 && codeUnit <= 0x005A || codeUnit >= 0x0061 && codeUnit <= 0x007A) {
        // the character itself
        result += string.charAt(index);
        continue;
      } // Otherwise, the escaped character.
      // http://dev.w3.org/csswg/cssom/#escape-a-character


      result += '\\' + string.charAt(index);
    } // Return sanitized hash


    return '#' + result;
  };
  /**
   * Calculate the easing pattern
   * @link https://gist.github.com/gre/1650294
   * @param {String} type Easing pattern
   * @param {Number} time Time animation should take to complete
   * @returns {Number}
   */


  var easingPattern = function (settings, time) {
    var pattern; // Default Easing Patterns

    if (settings.easing === 'easeInQuad') pattern = time * time; // accelerating from zero velocity

    if (settings.easing === 'easeOutQuad') pattern = time * (2 - time); // decelerating to zero velocity

    if (settings.easing === 'easeInOutQuad') pattern = time < 0.5 ? 2 * time * time : -1 + (4 - 2 * time) * time; // acceleration until halfway, then deceleration

    if (settings.easing === 'easeInCubic') pattern = time * time * time; // accelerating from zero velocity

    if (settings.easing === 'easeOutCubic') pattern = --time * time * time + 1; // decelerating to zero velocity

    if (settings.easing === 'easeInOutCubic') pattern = time < 0.5 ? 4 * time * time * time : (time - 1) * (2 * time - 2) * (2 * time - 2) + 1; // acceleration until halfway, then deceleration

    if (settings.easing === 'easeInQuart') pattern = time * time * time * time; // accelerating from zero velocity

    if (settings.easing === 'easeOutQuart') pattern = 1 - --time * time * time * time; // decelerating to zero velocity

    if (settings.easing === 'easeInOutQuart') pattern = time < 0.5 ? 8 * time * time * time * time : 1 - 8 * --time * time * time * time; // acceleration until halfway, then deceleration

    if (settings.easing === 'easeInQuint') pattern = time * time * time * time * time; // accelerating from zero velocity

    if (settings.easing === 'easeOutQuint') pattern = 1 + --time * time * time * time * time; // decelerating to zero velocity

    if (settings.easing === 'easeInOutQuint') pattern = time < 0.5 ? 16 * time * time * time * time * time : 1 + 16 * --time * time * time * time * time; // acceleration until halfway, then deceleration
    // Custom Easing Patterns

    if (!!settings.customEasing) pattern = settings.customEasing(time);
    return pattern || time; // no easing, no acceleration
  };
  /**
   * Determine the document's height
   * @returns {Number}
   */


  var getDocumentHeight = function () {
    return Math.max(document.body.scrollHeight, document.documentElement.scrollHeight, document.body.offsetHeight, document.documentElement.offsetHeight, document.body.clientHeight, document.documentElement.clientHeight);
  };
  /**
   * Calculate how far to scroll
   * Clip support added by robjtede - https://github.com/cferdinandi/smooth-scroll/issues/405
   * @param {Element} anchor       The anchor element to scroll to
   * @param {Number}  headerHeight Height of a fixed header, if any
   * @param {Number}  offset       Number of pixels by which to offset scroll
   * @param {Boolean} clip         If true, adjust scroll distance to prevent abrupt stops near the bottom of the page
   * @returns {Number}
   */


  var getEndLocation = function (anchor, headerHeight, offset, clip) {
    var location = 0;

    if (anchor.offsetParent) {
      do {
        location += anchor.offsetTop;
        anchor = anchor.offsetParent;
      } while (anchor);
    }

    location = Math.max(location - headerHeight - offset, 0);

    if (clip) {
      location = Math.min(location, getDocumentHeight() - window.innerHeight);
    }

    return location;
  };
  /**
   * Get the height of the fixed header
   * @param  {Node}   header The header
   * @return {Number}        The height of the header
   */


  var getHeaderHeight = function (header) {
    return !header ? 0 : getHeight(header) + header.offsetTop;
  };
  /**
   * Calculate the speed to use for the animation
   * @param  {Number} distance The distance to travel
   * @param  {Object} settings The plugin settings
   * @return {Number}          How fast to animate
   */


  var getSpeed = function (distance, settings) {
    var speed = settings.speedAsDuration ? settings.speed : Math.abs(distance / 1000 * settings.speed);
    if (settings.durationMax && speed > settings.durationMax) return settings.durationMax;
    if (settings.durationMin && speed < settings.durationMin) return settings.durationMin;
    return parseInt(speed, 10);
  };

  var setHistory = function (options) {
    // Make sure this should run
    if (!history.replaceState || !options.updateURL || history.state) return; // Get the hash to use

    var hash = window.location.hash;
    hash = hash ? hash : ''; // Set a default history

    history.replaceState({
      smoothScroll: JSON.stringify(options),
      anchor: hash ? hash : window.pageYOffset
    }, document.title, hash ? hash : window.location.href);
  };
  /**
   * Update the URL
   * @param  {Node}    anchor  The anchor that was scrolled to
   * @param  {Boolean} isNum   If true, anchor is a number
   * @param  {Object}  options Settings for Smooth Scroll
   */


  var updateURL = function (anchor, isNum, options) {
    // Bail if the anchor is a number
    if (isNum) return; // Verify that pushState is supported and the updateURL option is enabled

    if (!history.pushState || !options.updateURL) return; // Update URL

    history.pushState({
      smoothScroll: JSON.stringify(options),
      anchor: anchor.id
    }, document.title, anchor === document.documentElement ? '#top' : '#' + anchor.id);
  };
  /**
   * Bring the anchored element into focus
   * @param {Node}     anchor      The anchor element
   * @param {Number}   endLocation The end location to scroll to
   * @param {Boolean}  isNum       If true, scroll is to a position rather than an element
   */


  var adjustFocus = function (anchor, endLocation, isNum) {
    // Is scrolling to top of page, blur
    if (anchor === 0) {
      document.body.focus();
    } // Don't run if scrolling to a number on the page


    if (isNum) return; // Otherwise, bring anchor element into focus

    anchor.focus();

    if (document.activeElement !== anchor) {
      anchor.setAttribute('tabindex', '-1');
      anchor.focus();
      anchor.style.outline = 'none';
    }

    window.scrollTo(0, endLocation);
  };
  /**
   * Emit a custom event
   * @param  {String} type    The event type
   * @param  {Object} options The settings object
   * @param  {Node}   anchor  The anchor element
   * @param  {Node}   toggle  The toggle element
   */


  var emitEvent = function (type, options, anchor, toggle) {
    if (!options.emitEvents || typeof window.CustomEvent !== 'function') return;
    var event = new CustomEvent(type, {
      bubbles: true,
      detail: {
        anchor: anchor,
        toggle: toggle
      }
    });
    document.dispatchEvent(event);
  }; //
  // SmoothScroll Constructor
  //


  var SmoothScroll = function (selector, options) {
    //
    // Variables
    //
    var smoothScroll = {}; // Object for public APIs

    var settings, anchor, toggle, fixedHeader, eventTimeout, animationInterval; //
    // Methods
    //

    /**
     * Cancel a scroll-in-progress
     */

    smoothScroll.cancelScroll = function (noEvent) {
      cancelAnimationFrame(animationInterval);
      animationInterval = null;
      if (noEvent) return;
      emitEvent('scrollCancel', settings);
    };
    /**
     * Start/stop the scrolling animation
     * @param {Node|Number} anchor  The element or position to scroll to
     * @param {Element}     toggle  The element that toggled the scroll event
     * @param {Object}      options
     */


    smoothScroll.animateScroll = function (anchor, toggle, options) {
      // Cancel any in progress scrolls
      smoothScroll.cancelScroll(); // Local settings

      var _settings = extend(settings || defaults, options || {}); // Merge user options with defaults
      // Selectors and variables


      var isNum = Object.prototype.toString.call(anchor) === '[object Number]' ? true : false;
      var anchorElem = isNum || !anchor.tagName ? null : anchor;
      if (!isNum && !anchorElem) return;
      var startLocation = window.pageYOffset; // Current location on the page

      if (_settings.header && !fixedHeader) {
        // Get the fixed header if not already set
        fixedHeader = document.querySelector(_settings.header);
      }

      var headerHeight = getHeaderHeight(fixedHeader);
      var endLocation = isNum ? anchor : getEndLocation(anchorElem, headerHeight, parseInt(typeof _settings.offset === 'function' ? _settings.offset(anchor, toggle) : _settings.offset, 10), _settings.clip); // Location to scroll to

      var distance = endLocation - startLocation; // distance to travel

      var documentHeight = getDocumentHeight();
      var timeLapsed = 0;
      var speed = getSpeed(distance, _settings);
      var start, percentage, position;
      /**
       * Stop the scroll animation when it reaches its target (or the bottom/top of page)
       * @param {Number} position Current position on the page
       * @param {Number} endLocation Scroll to location
       * @param {Number} animationInterval How much to scroll on this loop
       */

      var stopAnimateScroll = function (position, endLocation) {
        // Get the current location
        var currentLocation = window.pageYOffset; // Check if the end location has been reached yet (or we've hit the end of the document)

        if (position == endLocation || currentLocation == endLocation || (startLocation < endLocation && window.innerHeight + currentLocation) >= documentHeight) {
          // Clear the animation timer
          smoothScroll.cancelScroll(true); // Bring the anchored element into focus

          adjustFocus(anchor, endLocation, isNum); // Emit a custom event

          emitEvent('scrollStop', _settings, anchor, toggle); // Reset start

          start = null;
          animationInterval = null;
          return true;
        }
      };
      /**
       * Loop scrolling animation
       */


      var loopAnimateScroll = function (timestamp) {
        if (!start) {
          start = timestamp;
        }

        timeLapsed += timestamp - start;
        percentage = speed === 0 ? 0 : timeLapsed / speed;
        percentage = percentage > 1 ? 1 : percentage;
        position = startLocation + distance * easingPattern(_settings, percentage);
        window.scrollTo(0, Math.floor(position));

        if (!stopAnimateScroll(position, endLocation)) {
          animationInterval = window.requestAnimationFrame(loopAnimateScroll);
          start = timestamp;
        }
      };
      /**
       * Reset position to fix weird iOS bug
       * @link https://github.com/cferdinandi/smooth-scroll/issues/45
       */


      if (window.pageYOffset === 0) {
        window.scrollTo(0, 0);
      } // Update the URL


      updateURL(anchor, isNum, _settings); // If the user prefers reduced motion, jump to location

      if (reduceMotion()) {
        adjustFocus(anchor, Math.floor(endLocation), false);
        return;
      } // Emit a custom event


      emitEvent('scrollStart', _settings, anchor, toggle); // Start scrolling animation

      smoothScroll.cancelScroll(true);
      window.requestAnimationFrame(loopAnimateScroll);
    };
    /**
     * If smooth scroll element clicked, animate scroll
     */


    var clickHandler = function (event) {
      // Don't run if event was canceled but still bubbled up
      // By @mgreter - https://github.com/cferdinandi/smooth-scroll/pull/462/
      if (event.defaultPrevented) return; // Don't run if right-click or command/control + click or shift + click

      if (event.button !== 0 || event.metaKey || event.ctrlKey || event.shiftKey) return; // Check if event.target has closest() method
      // By @totegi - https://github.com/cferdinandi/smooth-scroll/pull/401/

      if (!('closest' in event.target)) return; // Check if a smooth scroll link was clicked

      toggle = event.target.closest(selector);
      if (!toggle || toggle.tagName.toLowerCase() !== 'a' || event.target.closest(settings.ignore)) return; // Only run if link is an anchor and points to the current page

      if (toggle.hostname !== window.location.hostname || toggle.pathname !== window.location.pathname || !/#/.test(toggle.href)) return; // Get an escaped version of the hash

      var hash;

      try {
        hash = escapeCharacters(decodeURIComponent(toggle.hash));
      } catch (e) {
        hash = escapeCharacters(toggle.hash);
      } // Get the anchored element


      var anchor;

      if (hash === '#') {
        if (!settings.topOnEmptyHash) return;
        anchor = document.documentElement;
      } else {
        anchor = document.querySelector(hash);
      }

      anchor = !anchor && hash === '#top' ? document.documentElement : anchor; // If anchored element exists, scroll to it

      if (!anchor) return;
      event.preventDefault();
      setHistory(settings);
      smoothScroll.animateScroll(anchor, toggle);
    };
    /**
     * Animate scroll on popstate events
     */


    var popstateHandler = function (event) {
      // Stop if history.state doesn't exist (ex. if clicking on a broken anchor link).
      // fixes `Cannot read property 'smoothScroll' of null` error getting thrown.
      if (history.state === null) return; // Only run if state is a popstate record for this instantiation

      if (!history.state.smoothScroll || history.state.smoothScroll !== JSON.stringify(settings)) return; // Only run if state includes an anchor
      // if (!history.state.anchor && history.state.anchor !== 0) return;
      // Get the anchor

      var anchor = history.state.anchor;

      if (typeof anchor === 'string' && anchor) {
        anchor = document.querySelector(escapeCharacters(history.state.anchor));
        if (!anchor) return;
      } // Animate scroll to anchor link


      smoothScroll.animateScroll(anchor, null, {
        updateURL: false
      });
    };
    /**
     * Destroy the current initialization.
     */


    smoothScroll.destroy = function () {
      // If plugin isn't already initialized, stop
      if (!settings) return; // Remove event listeners

      document.removeEventListener('click', clickHandler, false);
      window.removeEventListener('popstate', popstateHandler, false); // Cancel any scrolls-in-progress

      smoothScroll.cancelScroll(); // Reset variables

      settings = null;
      anchor = null;
      toggle = null;
      fixedHeader = null;
      eventTimeout = null;
      animationInterval = null;
    };
    /**
     * Initialize Smooth Scroll
     * @param {Object} options User settings
     */


    var init = function () {
      // feature test
      if (!supports()) throw 'Smooth Scroll: This browser does not support the required JavaScript methods and browser APIs.'; // Destroy any existing initializations

      smoothScroll.destroy(); // Selectors and variables

      settings = extend(defaults, options || {}); // Merge user options with defaults

      fixedHeader = settings.header ? document.querySelector(settings.header) : null; // Get the fixed header
      // When a toggle is clicked, run the click handler

      document.addEventListener('click', clickHandler, false); // If updateURL and popState are enabled, listen for pop events

      if (settings.updateURL && settings.popstate) {
        window.addEventListener('popstate', popstateHandler, false);
      }
    }; //
    // Initialize plugin
    //


    init(); //
    // Public APIs
    //

    return smoothScroll;
  };

  return SmoothScroll;
});
'use strict';
/**
* @version 1.3.2
* @author Marius Hansen <marius.o.hansen@gmail.com>
* @license MIT
* @description Easy parallax plugin using pure javascript. Cross browser support, including mobile platforms. Based on goodparallax
* @copyright © Marius Hansen 2019
*/

var windowHeight = window.innerHeight,
    windowHeightExtra = 0;
var safari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent),
    mobile = /Mobi/.test(navigator.userAgent); // check if safari - extend height

if (safari && !mobile) {
  windowHeightExtra = window.outerHeight - window.innerHeight;
}

if (mobile) {
  windowHeight = window.screen.availHeight; // stops from jumping

  windowHeightExtra = (window.screen.availHeight - window.innerHeight) / 2; // prevents white spaces
} // position parallax


var positionParallax = function positionParallax(container, speed, parallax, elem) {
  var bgScroll = container.top / speed - windowHeightExtra;
  parallax[elem].style.top = bgScroll + 'px';
}; // animate parallax


var animateParallax = function animateParallax(parallax, speed) {
  for (var i = 0; parallax.length > i; i++) {
    var container = parallax[i].parentElement.parentElement.getBoundingClientRect(); // only animate if on screen

    if (container.top + container.height >= 0 && container.top <= windowHeight) {
      positionParallax(container, speed, parallax, i);
    }
  }
}; // determine height


var calculateHeight = function calculateHeight(parallax, speed) {
  for (var i = 0; parallax.length > i; i++) {
    var container = parallax[i].parentElement.parentElement.getBoundingClientRect();
    var containerTop = parallax[i].parentElement.parentElement.offsetTop;
    var elemOffsetTop = (windowHeight - container.height) / 2; // set bgHeight & check if it needs to stretch beyond container bottom

    var bgHeight = windowHeight > container.height + containerTop ? container.height + containerTop - containerTop / speed : container.height + (elemOffsetTop - elemOffsetTop / speed) * 2;
    parallax[i].style.height = bgHeight + windowHeightExtra * 2 + 'px';
    positionParallax(container, speed, parallax, i);
  }
};

var universalParallax = function universalParallax() {
  var up = function up(parallax, speed) {
    // check that speed is not a negative number
    if (speed < 1) {
      speed = 1;
    } // set height on elements


    calculateHeight(parallax, speed); // recalculate height on resize

    if (!mobile) {
      window.addEventListener('resize', function () {
        windowHeight = window.innerHeight;
        calculateHeight(parallax, speed);
      });
    } // Add scroll event listener


    window.addEventListener('scroll', function () {
      animateParallax(parallax, speed);
    });
  }; // Ready all elements


  this.init = function (param) {
    if (typeof param === 'undefined') {
      param = {};
    }

    param = {
      speed: typeof param.speed !== 'undefined' ? param.speed : 1.5,
      className: typeof param.className !== 'undefined' ? param.className : 'parallax'
    };
    var parallax = document.getElementsByClassName(param.className);

    for (var i = 0; parallax.length > i; i++) {
      // make container div
      var wrapper = document.createElement('div');
      parallax[i].parentNode.insertBefore(wrapper, parallax[i]);
      wrapper.appendChild(parallax[i]);
      var parallaxContainer = parallax[i].parentElement;
      parallaxContainer.className += 'parallax__container'; // parent elem need position: relative for effect to work - if not already defined, add it

      if (window.getComputedStyle(parallaxContainer.parentElement, null).getPropertyValue('position') !== 'relative') {
        parallaxContainer.parentElement.style.position = 'relative';
      }

      var imgData = parallax[i].dataset.parallaxImage; // add image to div if none is specified

      if (typeof imgData !== 'undefined') {
        parallax[i].style.backgroundImage = 'url(' + imgData + ')'; // if no other class than .parallax is specified, add CSS

        if (parallax[i].classList.length === 1 && parallax[i].classList[0] === 'parallax') {
          parallax[i].style.backgroundRepeat = 'no-repeat';
          parallax[i].style.backgroundPosition = 'center';
          parallax[i].style.backgroundSize = 'cover';
        }
      }
    }

    ; // when page is loaded && init completed -> run function

    document.addEventListener('readystatechange', function (event) {
      if (event.target.readyState === 'complete') {
        up(parallax, param.speed);
      }
    });
  };
};
/**
 * Swiper 5.3.7
 * Most modern mobile touch slider and framework with hardware accelerated transitions
 * http://swiperjs.com
 *
 * Copyright 2014-2020 Vladimir Kharlampidi
 *
 * Released under the MIT License
 *
 * Released on: April 10, 2020
 */
(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = global || self, global.Swiper = factory());
})(this, function () {
  'use strict';
  /**
   * SSR Window 1.0.1
   * Better handling for window object in SSR environment
   * https://github.com/nolimits4web/ssr-window
   *
   * Copyright 2018, Vladimir Kharlampidi
   *
   * Licensed under MIT
   *
   * Released on: July 18, 2018
   */

  var doc = typeof document === 'undefined' ? {
    body: {},
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    activeElement: {
      blur: function blur() {},
      nodeName: ''
    },
    querySelector: function querySelector() {
      return null;
    },
    querySelectorAll: function querySelectorAll() {
      return [];
    },
    getElementById: function getElementById() {
      return null;
    },
    createEvent: function createEvent() {
      return {
        initEvent: function initEvent() {}
      };
    },
    createElement: function createElement() {
      return {
        children: [],
        childNodes: [],
        style: {},
        setAttribute: function setAttribute() {},
        getElementsByTagName: function getElementsByTagName() {
          return [];
        }
      };
    },
    location: {
      hash: ''
    }
  } : document; // eslint-disable-line

  var win = typeof window === 'undefined' ? {
    document: doc,
    navigator: {
      userAgent: ''
    },
    location: {},
    history: {},
    CustomEvent: function CustomEvent() {
      return this;
    },
    addEventListener: function addEventListener() {},
    removeEventListener: function removeEventListener() {},
    getComputedStyle: function getComputedStyle() {
      return {
        getPropertyValue: function getPropertyValue() {
          return '';
        }
      };
    },
    Image: function Image() {},
    Date: function Date() {},
    screen: {},
    setTimeout: function setTimeout() {},
    clearTimeout: function clearTimeout() {}
  } : window; // eslint-disable-line

  /**
   * Dom7 2.1.3
   * Minimalistic JavaScript library for DOM manipulation, with a jQuery-compatible API
   * http://framework7.io/docs/dom.html
   *
   * Copyright 2019, Vladimir Kharlampidi
   * The iDangero.us
   * http://www.idangero.us/
   *
   * Licensed under MIT
   *
   * Released on: February 11, 2019
   */

  var Dom7 = function Dom7(arr) {
    var self = this; // Create array-like object

    for (var i = 0; i < arr.length; i += 1) {
      self[i] = arr[i];
    }

    self.length = arr.length; // Return collection with methods

    return this;
  };

  function $(selector, context) {
    var arr = [];
    var i = 0;

    if (selector && !context) {
      if (selector instanceof Dom7) {
        return selector;
      }
    }

    if (selector) {
      // String
      if (typeof selector === 'string') {
        var els;
        var tempParent;
        var html = selector.trim();

        if (html.indexOf('<') >= 0 && html.indexOf('>') >= 0) {
          var toCreate = 'div';

          if (html.indexOf('<li') === 0) {
            toCreate = 'ul';
          }

          if (html.indexOf('<tr') === 0) {
            toCreate = 'tbody';
          }

          if (html.indexOf('<td') === 0 || html.indexOf('<th') === 0) {
            toCreate = 'tr';
          }

          if (html.indexOf('<tbody') === 0) {
            toCreate = 'table';
          }

          if (html.indexOf('<option') === 0) {
            toCreate = 'select';
          }

          tempParent = doc.createElement(toCreate);
          tempParent.innerHTML = html;

          for (i = 0; i < tempParent.childNodes.length; i += 1) {
            arr.push(tempParent.childNodes[i]);
          }
        } else {
          if (!context && selector[0] === '#' && !selector.match(/[ .<>:~]/)) {
            // Pure ID selector
            els = [doc.getElementById(selector.trim().split('#')[1])];
          } else {
            // Other selectors
            els = (context || doc).querySelectorAll(selector.trim());
          }

          for (i = 0; i < els.length; i += 1) {
            if (els[i]) {
              arr.push(els[i]);
            }
          }
        }
      } else if (selector.nodeType || selector === win || selector === doc) {
        // Node/element
        arr.push(selector);
      } else if (selector.length > 0 && selector[0].nodeType) {
        // Array of elements or instance of Dom
        for (i = 0; i < selector.length; i += 1) {
          arr.push(selector[i]);
        }
      }
    }

    return new Dom7(arr);
  }

  $.fn = Dom7.prototype;
  $.Class = Dom7;
  $.Dom7 = Dom7;

  function unique(arr) {
    var uniqueArray = [];

    for (var i = 0; i < arr.length; i += 1) {
      if (uniqueArray.indexOf(arr[i]) === -1) {
        uniqueArray.push(arr[i]);
      }
    }

    return uniqueArray;
  } // Classes and attributes


  function addClass(className) {
    if (typeof className === 'undefined') {
      return this;
    }

    var classes = className.split(' ');

    for (var i = 0; i < classes.length; i += 1) {
      for (var j = 0; j < this.length; j += 1) {
        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') {
          this[j].classList.add(classes[i]);
        }
      }
    }

    return this;
  }

  function removeClass(className) {
    var classes = className.split(' ');

    for (var i = 0; i < classes.length; i += 1) {
      for (var j = 0; j < this.length; j += 1) {
        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') {
          this[j].classList.remove(classes[i]);
        }
      }
    }

    return this;
  }

  function hasClass(className) {
    if (!this[0]) {
      return false;
    }

    return this[0].classList.contains(className);
  }

  function toggleClass(className) {
    var classes = className.split(' ');

    for (var i = 0; i < classes.length; i += 1) {
      for (var j = 0; j < this.length; j += 1) {
        if (typeof this[j] !== 'undefined' && typeof this[j].classList !== 'undefined') {
          this[j].classList.toggle(classes[i]);
        }
      }
    }

    return this;
  }

  function attr(attrs, value) {
    var arguments$1 = arguments;

    if (arguments.length === 1 && typeof attrs === 'string') {
      // Get attr
      if (this[0]) {
        return this[0].getAttribute(attrs);
      }

      return undefined;
    } // Set attrs


    for (var i = 0; i < this.length; i += 1) {
      if (arguments$1.length === 2) {
        // String
        this[i].setAttribute(attrs, value);
      } else {
        // Object
        // eslint-disable-next-line
        for (var attrName in attrs) {
          this[i][attrName] = attrs[attrName];
          this[i].setAttribute(attrName, attrs[attrName]);
        }
      }
    }

    return this;
  } // eslint-disable-next-line


  function removeAttr(attr) {
    for (var i = 0; i < this.length; i += 1) {
      this[i].removeAttribute(attr);
    }

    return this;
  }

  function data(key, value) {
    var el;

    if (typeof value === 'undefined') {
      el = this[0]; // Get value

      if (el) {
        if (el.dom7ElementDataStorage && key in el.dom7ElementDataStorage) {
          return el.dom7ElementDataStorage[key];
        }

        var dataKey = el.getAttribute("data-" + key);

        if (dataKey) {
          return dataKey;
        }

        return undefined;
      }

      return undefined;
    } // Set value


    for (var i = 0; i < this.length; i += 1) {
      el = this[i];

      if (!el.dom7ElementDataStorage) {
        el.dom7ElementDataStorage = {};
      }

      el.dom7ElementDataStorage[key] = value;
    }

    return this;
  } // Transforms
  // eslint-disable-next-line


  function transform(transform) {
    for (var i = 0; i < this.length; i += 1) {
      var elStyle = this[i].style;
      elStyle.webkitTransform = transform;
      elStyle.transform = transform;
    }

    return this;
  }

  function transition(duration) {
    if (typeof duration !== 'string') {
      duration = duration + "ms"; // eslint-disable-line
    }

    for (var i = 0; i < this.length; i += 1) {
      var elStyle = this[i].style;
      elStyle.webkitTransitionDuration = duration;
      elStyle.transitionDuration = duration;
    }

    return this;
  } // Events


  function on() {
    var assign;
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var eventType = args[0];
    var targetSelector = args[1];
    var listener = args[2];
    var capture = args[3];

    if (typeof args[1] === 'function') {
      assign = args, eventType = assign[0], listener = assign[1], capture = assign[2];
      targetSelector = undefined;
    }

    if (!capture) {
      capture = false;
    }

    function handleLiveEvent(e) {
      var target = e.target;

      if (!target) {
        return;
      }

      var eventData = e.target.dom7EventData || [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      if ($(target).is(targetSelector)) {
        listener.apply(target, eventData);
      } else {
        var parents = $(target).parents(); // eslint-disable-line

        for (var k = 0; k < parents.length; k += 1) {
          if ($(parents[k]).is(targetSelector)) {
            listener.apply(parents[k], eventData);
          }
        }
      }
    }

    function handleEvent(e) {
      var eventData = e && e.target ? e.target.dom7EventData || [] : [];

      if (eventData.indexOf(e) < 0) {
        eventData.unshift(e);
      }

      listener.apply(this, eventData);
    }

    var events = eventType.split(' ');
    var j;

    for (var i = 0; i < this.length; i += 1) {
      var el = this[i];

      if (!targetSelector) {
        for (j = 0; j < events.length; j += 1) {
          var event = events[j];

          if (!el.dom7Listeners) {
            el.dom7Listeners = {};
          }

          if (!el.dom7Listeners[event]) {
            el.dom7Listeners[event] = [];
          }

          el.dom7Listeners[event].push({
            listener: listener,
            proxyListener: handleEvent
          });
          el.addEventListener(event, handleEvent, capture);
        }
      } else {
        // Live events
        for (j = 0; j < events.length; j += 1) {
          var event$1 = events[j];

          if (!el.dom7LiveListeners) {
            el.dom7LiveListeners = {};
          }

          if (!el.dom7LiveListeners[event$1]) {
            el.dom7LiveListeners[event$1] = [];
          }

          el.dom7LiveListeners[event$1].push({
            listener: listener,
            proxyListener: handleLiveEvent
          });
          el.addEventListener(event$1, handleLiveEvent, capture);
        }
      }
    }

    return this;
  }

  function off() {
    var assign;
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var eventType = args[0];
    var targetSelector = args[1];
    var listener = args[2];
    var capture = args[3];

    if (typeof args[1] === 'function') {
      assign = args, eventType = assign[0], listener = assign[1], capture = assign[2];
      targetSelector = undefined;
    }

    if (!capture) {
      capture = false;
    }

    var events = eventType.split(' ');

    for (var i = 0; i < events.length; i += 1) {
      var event = events[i];

      for (var j = 0; j < this.length; j += 1) {
        var el = this[j];
        var handlers = void 0;

        if (!targetSelector && el.dom7Listeners) {
          handlers = el.dom7Listeners[event];
        } else if (targetSelector && el.dom7LiveListeners) {
          handlers = el.dom7LiveListeners[event];
        }

        if (handlers && handlers.length) {
          for (var k = handlers.length - 1; k >= 0; k -= 1) {
            var handler = handlers[k];

            if (listener && handler.listener === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (listener && handler.listener && handler.listener.dom7proxy && handler.listener.dom7proxy === listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            } else if (!listener) {
              el.removeEventListener(event, handler.proxyListener, capture);
              handlers.splice(k, 1);
            }
          }
        }
      }
    }

    return this;
  }

  function trigger() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var events = args[0].split(' ');
    var eventData = args[1];

    for (var i = 0; i < events.length; i += 1) {
      var event = events[i];

      for (var j = 0; j < this.length; j += 1) {
        var el = this[j];
        var evt = void 0;

        try {
          evt = new win.CustomEvent(event, {
            detail: eventData,
            bubbles: true,
            cancelable: true
          });
        } catch (e) {
          evt = doc.createEvent('Event');
          evt.initEvent(event, true, true);
          evt.detail = eventData;
        } // eslint-disable-next-line


        el.dom7EventData = args.filter(function (data, dataIndex) {
          return dataIndex > 0;
        });
        el.dispatchEvent(evt);
        el.dom7EventData = [];
        delete el.dom7EventData;
      }
    }

    return this;
  }

  function transitionEnd(callback) {
    var events = ['webkitTransitionEnd', 'transitionend'];
    var dom = this;
    var i;

    function fireCallBack(e) {
      /* jshint validthis:true */
      if (e.target !== this) {
        return;
      }

      callback.call(this, e);

      for (i = 0; i < events.length; i += 1) {
        dom.off(events[i], fireCallBack);
      }
    }

    if (callback) {
      for (i = 0; i < events.length; i += 1) {
        dom.on(events[i], fireCallBack);
      }
    }

    return this;
  }

  function outerWidth(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        // eslint-disable-next-line
        var styles = this.styles();
        return this[0].offsetWidth + parseFloat(styles.getPropertyValue('margin-right')) + parseFloat(styles.getPropertyValue('margin-left'));
      }

      return this[0].offsetWidth;
    }

    return null;
  }

  function outerHeight(includeMargins) {
    if (this.length > 0) {
      if (includeMargins) {
        // eslint-disable-next-line
        var styles = this.styles();
        return this[0].offsetHeight + parseFloat(styles.getPropertyValue('margin-top')) + parseFloat(styles.getPropertyValue('margin-bottom'));
      }

      return this[0].offsetHeight;
    }

    return null;
  }

  function offset() {
    if (this.length > 0) {
      var el = this[0];
      var box = el.getBoundingClientRect();
      var body = doc.body;
      var clientTop = el.clientTop || body.clientTop || 0;
      var clientLeft = el.clientLeft || body.clientLeft || 0;
      var scrollTop = el === win ? win.scrollY : el.scrollTop;
      var scrollLeft = el === win ? win.scrollX : el.scrollLeft;
      return {
        top: box.top + scrollTop - clientTop,
        left: box.left + scrollLeft - clientLeft
      };
    }

    return null;
  }

  function styles() {
    if (this[0]) {
      return win.getComputedStyle(this[0], null);
    }

    return {};
  }

  function css(props, value) {
    var i;

    if (arguments.length === 1) {
      if (typeof props === 'string') {
        if (this[0]) {
          return win.getComputedStyle(this[0], null).getPropertyValue(props);
        }
      } else {
        for (i = 0; i < this.length; i += 1) {
          // eslint-disable-next-line
          for (var prop in props) {
            this[i].style[prop] = props[prop];
          }
        }

        return this;
      }
    }

    if (arguments.length === 2 && typeof props === 'string') {
      for (i = 0; i < this.length; i += 1) {
        this[i].style[props] = value;
      }

      return this;
    }

    return this;
  } // Iterate over the collection passing elements to `callback`


  function each(callback) {
    // Don't bother continuing without a callback
    if (!callback) {
      return this;
    } // Iterate over the current collection


    for (var i = 0; i < this.length; i += 1) {
      // If the callback returns false
      if (callback.call(this[i], i, this[i]) === false) {
        // End the loop early
        return this;
      }
    } // Return `this` to allow chained DOM operations


    return this;
  }

  function filter(callback) {
    var matchedItems = [];
    var dom = this;

    for (var i = 0; i < dom.length; i += 1) {
      if (callback.call(dom[i], i, dom[i])) {
        matchedItems.push(dom[i]);
      }
    }

    return new Dom7(matchedItems);
  } // eslint-disable-next-line


  function html(html) {
    if (typeof html === 'undefined') {
      return this[0] ? this[0].innerHTML : undefined;
    }

    for (var i = 0; i < this.length; i += 1) {
      this[i].innerHTML = html;
    }

    return this;
  } // eslint-disable-next-line


  function text(text) {
    if (typeof text === 'undefined') {
      if (this[0]) {
        return this[0].textContent.trim();
      }

      return null;
    }

    for (var i = 0; i < this.length; i += 1) {
      this[i].textContent = text;
    }

    return this;
  }

  function is(selector) {
    var el = this[0];
    var compareWith;
    var i;

    if (!el || typeof selector === 'undefined') {
      return false;
    }

    if (typeof selector === 'string') {
      if (el.matches) {
        return el.matches(selector);
      } else if (el.webkitMatchesSelector) {
        return el.webkitMatchesSelector(selector);
      } else if (el.msMatchesSelector) {
        return el.msMatchesSelector(selector);
      }

      compareWith = $(selector);

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) {
          return true;
        }
      }

      return false;
    } else if (selector === doc) {
      return el === doc;
    } else if (selector === win) {
      return el === win;
    }

    if (selector.nodeType || selector instanceof Dom7) {
      compareWith = selector.nodeType ? [selector] : selector;

      for (i = 0; i < compareWith.length; i += 1) {
        if (compareWith[i] === el) {
          return true;
        }
      }

      return false;
    }

    return false;
  }

  function index() {
    var child = this[0];
    var i;

    if (child) {
      i = 0; // eslint-disable-next-line

      while ((child = child.previousSibling) !== null) {
        if (child.nodeType === 1) {
          i += 1;
        }
      }

      return i;
    }

    return undefined;
  } // eslint-disable-next-line


  function eq(index) {
    if (typeof index === 'undefined') {
      return this;
    }

    var length = this.length;
    var returnIndex;

    if (index > length - 1) {
      return new Dom7([]);
    }

    if (index < 0) {
      returnIndex = length + index;

      if (returnIndex < 0) {
        return new Dom7([]);
      }

      return new Dom7([this[returnIndex]]);
    }

    return new Dom7([this[index]]);
  }

  function append() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var newChild;

    for (var k = 0; k < args.length; k += 1) {
      newChild = args[k];

      for (var i = 0; i < this.length; i += 1) {
        if (typeof newChild === 'string') {
          var tempDiv = doc.createElement('div');
          tempDiv.innerHTML = newChild;

          while (tempDiv.firstChild) {
            this[i].appendChild(tempDiv.firstChild);
          }
        } else if (newChild instanceof Dom7) {
          for (var j = 0; j < newChild.length; j += 1) {
            this[i].appendChild(newChild[j]);
          }
        } else {
          this[i].appendChild(newChild);
        }
      }
    }

    return this;
  }

  function prepend(newChild) {
    var i;
    var j;

    for (i = 0; i < this.length; i += 1) {
      if (typeof newChild === 'string') {
        var tempDiv = doc.createElement('div');
        tempDiv.innerHTML = newChild;

        for (j = tempDiv.childNodes.length - 1; j >= 0; j -= 1) {
          this[i].insertBefore(tempDiv.childNodes[j], this[i].childNodes[0]);
        }
      } else if (newChild instanceof Dom7) {
        for (j = 0; j < newChild.length; j += 1) {
          this[i].insertBefore(newChild[j], this[i].childNodes[0]);
        }
      } else {
        this[i].insertBefore(newChild, this[i].childNodes[0]);
      }
    }

    return this;
  }

  function next(selector) {
    if (this.length > 0) {
      if (selector) {
        if (this[0].nextElementSibling && $(this[0].nextElementSibling).is(selector)) {
          return new Dom7([this[0].nextElementSibling]);
        }

        return new Dom7([]);
      }

      if (this[0].nextElementSibling) {
        return new Dom7([this[0].nextElementSibling]);
      }

      return new Dom7([]);
    }

    return new Dom7([]);
  }

  function nextAll(selector) {
    var nextEls = [];
    var el = this[0];

    if (!el) {
      return new Dom7([]);
    }

    while (el.nextElementSibling) {
      var next = el.nextElementSibling; // eslint-disable-line

      if (selector) {
        if ($(next).is(selector)) {
          nextEls.push(next);
        }
      } else {
        nextEls.push(next);
      }

      el = next;
    }

    return new Dom7(nextEls);
  }

  function prev(selector) {
    if (this.length > 0) {
      var el = this[0];

      if (selector) {
        if (el.previousElementSibling && $(el.previousElementSibling).is(selector)) {
          return new Dom7([el.previousElementSibling]);
        }

        return new Dom7([]);
      }

      if (el.previousElementSibling) {
        return new Dom7([el.previousElementSibling]);
      }

      return new Dom7([]);
    }

    return new Dom7([]);
  }

  function prevAll(selector) {
    var prevEls = [];
    var el = this[0];

    if (!el) {
      return new Dom7([]);
    }

    while (el.previousElementSibling) {
      var prev = el.previousElementSibling; // eslint-disable-line

      if (selector) {
        if ($(prev).is(selector)) {
          prevEls.push(prev);
        }
      } else {
        prevEls.push(prev);
      }

      el = prev;
    }

    return new Dom7(prevEls);
  }

  function parent(selector) {
    var parents = []; // eslint-disable-line

    for (var i = 0; i < this.length; i += 1) {
      if (this[i].parentNode !== null) {
        if (selector) {
          if ($(this[i].parentNode).is(selector)) {
            parents.push(this[i].parentNode);
          }
        } else {
          parents.push(this[i].parentNode);
        }
      }
    }

    return $(unique(parents));
  }

  function parents(selector) {
    var parents = []; // eslint-disable-line

    for (var i = 0; i < this.length; i += 1) {
      var parent = this[i].parentNode; // eslint-disable-line

      while (parent) {
        if (selector) {
          if ($(parent).is(selector)) {
            parents.push(parent);
          }
        } else {
          parents.push(parent);
        }

        parent = parent.parentNode;
      }
    }

    return $(unique(parents));
  }

  function closest(selector) {
    var closest = this; // eslint-disable-line

    if (typeof selector === 'undefined') {
      return new Dom7([]);
    }

    if (!closest.is(selector)) {
      closest = closest.parents(selector).eq(0);
    }

    return closest;
  }

  function find(selector) {
    var foundElements = [];

    for (var i = 0; i < this.length; i += 1) {
      var found = this[i].querySelectorAll(selector);

      for (var j = 0; j < found.length; j += 1) {
        foundElements.push(found[j]);
      }
    }

    return new Dom7(foundElements);
  }

  function children(selector) {
    var children = []; // eslint-disable-line

    for (var i = 0; i < this.length; i += 1) {
      var childNodes = this[i].childNodes;

      for (var j = 0; j < childNodes.length; j += 1) {
        if (!selector) {
          if (childNodes[j].nodeType === 1) {
            children.push(childNodes[j]);
          }
        } else if (childNodes[j].nodeType === 1 && $(childNodes[j]).is(selector)) {
          children.push(childNodes[j]);
        }
      }
    }

    return new Dom7(unique(children));
  }

  function remove() {
    for (var i = 0; i < this.length; i += 1) {
      if (this[i].parentNode) {
        this[i].parentNode.removeChild(this[i]);
      }
    }

    return this;
  }

  function add() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var dom = this;
    var i;
    var j;

    for (i = 0; i < args.length; i += 1) {
      var toAdd = $(args[i]);

      for (j = 0; j < toAdd.length; j += 1) {
        dom[dom.length] = toAdd[j];
        dom.length += 1;
      }
    }

    return dom;
  }

  var Methods = {
    addClass: addClass,
    removeClass: removeClass,
    hasClass: hasClass,
    toggleClass: toggleClass,
    attr: attr,
    removeAttr: removeAttr,
    data: data,
    transform: transform,
    transition: transition,
    on: on,
    off: off,
    trigger: trigger,
    transitionEnd: transitionEnd,
    outerWidth: outerWidth,
    outerHeight: outerHeight,
    offset: offset,
    css: css,
    each: each,
    html: html,
    text: text,
    is: is,
    index: index,
    eq: eq,
    append: append,
    prepend: prepend,
    next: next,
    nextAll: nextAll,
    prev: prev,
    prevAll: prevAll,
    parent: parent,
    parents: parents,
    closest: closest,
    find: find,
    children: children,
    filter: filter,
    remove: remove,
    add: add,
    styles: styles
  };
  Object.keys(Methods).forEach(function (methodName) {
    $.fn[methodName] = $.fn[methodName] || Methods[methodName];
  });
  var Utils = {
    deleteProps: function deleteProps(obj) {
      var object = obj;
      Object.keys(object).forEach(function (key) {
        try {
          object[key] = null;
        } catch (e) {// no getter for object
        }

        try {
          delete object[key];
        } catch (e) {// something got wrong
        }
      });
    },
    nextTick: function nextTick(callback, delay) {
      if (delay === void 0) delay = 0;
      return setTimeout(callback, delay);
    },
    now: function now() {
      return Date.now();
    },
    getTranslate: function getTranslate(el, axis) {
      if (axis === void 0) axis = 'x';
      var matrix;
      var curTransform;
      var transformMatrix;
      var curStyle = win.getComputedStyle(el, null);

      if (win.WebKitCSSMatrix) {
        curTransform = curStyle.transform || curStyle.webkitTransform;

        if (curTransform.split(',').length > 6) {
          curTransform = curTransform.split(', ').map(function (a) {
            return a.replace(',', '.');
          }).join(', ');
        } // Some old versions of Webkit choke when 'none' is passed; pass
        // empty string instead in this case


        transformMatrix = new win.WebKitCSSMatrix(curTransform === 'none' ? '' : curTransform);
      } else {
        transformMatrix = curStyle.MozTransform || curStyle.OTransform || curStyle.MsTransform || curStyle.msTransform || curStyle.transform || curStyle.getPropertyValue('transform').replace('translate(', 'matrix(1, 0, 0, 1,');
        matrix = transformMatrix.toString().split(',');
      }

      if (axis === 'x') {
        // Latest Chrome and webkits Fix
        if (win.WebKitCSSMatrix) {
          curTransform = transformMatrix.m41;
        } // Crazy IE10 Matrix
        else if (matrix.length === 16) {
            curTransform = parseFloat(matrix[12]);
          } // Normal Browsers
          else {
              curTransform = parseFloat(matrix[4]);
            }
      }

      if (axis === 'y') {
        // Latest Chrome and webkits Fix
        if (win.WebKitCSSMatrix) {
          curTransform = transformMatrix.m42;
        } // Crazy IE10 Matrix
        else if (matrix.length === 16) {
            curTransform = parseFloat(matrix[13]);
          } // Normal Browsers
          else {
              curTransform = parseFloat(matrix[5]);
            }
      }

      return curTransform || 0;
    },
    parseUrlQuery: function parseUrlQuery(url) {
      var query = {};
      var urlToParse = url || win.location.href;
      var i;
      var params;
      var param;
      var length;

      if (typeof urlToParse === 'string' && urlToParse.length) {
        urlToParse = urlToParse.indexOf('?') > -1 ? urlToParse.replace(/\S*\?/, '') : '';
        params = urlToParse.split('&').filter(function (paramsPart) {
          return paramsPart !== '';
        });
        length = params.length;

        for (i = 0; i < length; i += 1) {
          param = params[i].replace(/#\S+/g, '').split('=');
          query[decodeURIComponent(param[0])] = typeof param[1] === 'undefined' ? undefined : decodeURIComponent(param[1]) || '';
        }
      }

      return query;
    },
    isObject: function isObject(o) {
      return typeof o === 'object' && o !== null && o.constructor && o.constructor === Object;
    },
    extend: function extend() {
      var args = [],
          len$1 = arguments.length;

      while (len$1--) args[len$1] = arguments[len$1];

      var to = Object(args[0]);

      for (var i = 1; i < args.length; i += 1) {
        var nextSource = args[i];

        if (nextSource !== undefined && nextSource !== null) {
          var keysArray = Object.keys(Object(nextSource));

          for (var nextIndex = 0, len = keysArray.length; nextIndex < len; nextIndex += 1) {
            var nextKey = keysArray[nextIndex];
            var desc = Object.getOwnPropertyDescriptor(nextSource, nextKey);

            if (desc !== undefined && desc.enumerable) {
              if (Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                Utils.extend(to[nextKey], nextSource[nextKey]);
              } else if (!Utils.isObject(to[nextKey]) && Utils.isObject(nextSource[nextKey])) {
                to[nextKey] = {};
                Utils.extend(to[nextKey], nextSource[nextKey]);
              } else {
                to[nextKey] = nextSource[nextKey];
              }
            }
          }
        }
      }

      return to;
    }
  };

  var Support = function Support() {
    return {
      touch: win.Modernizr && win.Modernizr.touch === true || function checkTouch() {
        return !!(win.navigator.maxTouchPoints > 0 || 'ontouchstart' in win || win.DocumentTouch && doc instanceof win.DocumentTouch);
      }(),
      pointerEvents: !!win.PointerEvent && 'maxTouchPoints' in win.navigator && win.navigator.maxTouchPoints > 0,
      observer: function checkObserver() {
        return 'MutationObserver' in win || 'WebkitMutationObserver' in win;
      }(),
      passiveListener: function checkPassiveListener() {
        var supportsPassive = false;

        try {
          var opts = Object.defineProperty({}, 'passive', {
            // eslint-disable-next-line
            get: function get() {
              supportsPassive = true;
            }
          });
          win.addEventListener('testPassiveListener', null, opts);
        } catch (e) {// No support
        }

        return supportsPassive;
      }(),
      gestures: function checkGestures() {
        return 'ongesturestart' in win;
      }()
    };
  }();

  var SwiperClass = function SwiperClass(params) {
    if (params === void 0) params = {};
    var self = this;
    self.params = params; // Events

    self.eventsListeners = {};

    if (self.params && self.params.on) {
      Object.keys(self.params.on).forEach(function (eventName) {
        self.on(eventName, self.params.on[eventName]);
      });
    }
  };

  var staticAccessors = {
    components: {
      configurable: true
    }
  };

  SwiperClass.prototype.on = function on(events, handler, priority) {
    var self = this;

    if (typeof handler !== 'function') {
      return self;
    }

    var method = priority ? 'unshift' : 'push';
    events.split(' ').forEach(function (event) {
      if (!self.eventsListeners[event]) {
        self.eventsListeners[event] = [];
      }

      self.eventsListeners[event][method](handler);
    });
    return self;
  };

  SwiperClass.prototype.once = function once(events, handler, priority) {
    var self = this;

    if (typeof handler !== 'function') {
      return self;
    }

    function onceHandler() {
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      self.off(events, onceHandler);

      if (onceHandler.f7proxy) {
        delete onceHandler.f7proxy;
      }

      handler.apply(self, args);
    }

    onceHandler.f7proxy = handler;
    return self.on(events, onceHandler, priority);
  };

  SwiperClass.prototype.off = function off(events, handler) {
    var self = this;

    if (!self.eventsListeners) {
      return self;
    }

    events.split(' ').forEach(function (event) {
      if (typeof handler === 'undefined') {
        self.eventsListeners[event] = [];
      } else if (self.eventsListeners[event] && self.eventsListeners[event].length) {
        self.eventsListeners[event].forEach(function (eventHandler, index) {
          if (eventHandler === handler || eventHandler.f7proxy && eventHandler.f7proxy === handler) {
            self.eventsListeners[event].splice(index, 1);
          }
        });
      }
    });
    return self;
  };

  SwiperClass.prototype.emit = function emit() {
    var args = [],
        len = arguments.length;

    while (len--) args[len] = arguments[len];

    var self = this;

    if (!self.eventsListeners) {
      return self;
    }

    var events;
    var data;
    var context;

    if (typeof args[0] === 'string' || Array.isArray(args[0])) {
      events = args[0];
      data = args.slice(1, args.length);
      context = self;
    } else {
      events = args[0].events;
      data = args[0].data;
      context = args[0].context || self;
    }

    var eventsArray = Array.isArray(events) ? events : events.split(' ');
    eventsArray.forEach(function (event) {
      if (self.eventsListeners && self.eventsListeners[event]) {
        var handlers = [];
        self.eventsListeners[event].forEach(function (eventHandler) {
          handlers.push(eventHandler);
        });
        handlers.forEach(function (eventHandler) {
          eventHandler.apply(context, data);
        });
      }
    });
    return self;
  };

  SwiperClass.prototype.useModulesParams = function useModulesParams(instanceParams) {
    var instance = this;

    if (!instance.modules) {
      return;
    }

    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName]; // Extend params

      if (module.params) {
        Utils.extend(instanceParams, module.params);
      }
    });
  };

  SwiperClass.prototype.useModules = function useModules(modulesParams) {
    if (modulesParams === void 0) modulesParams = {};
    var instance = this;

    if (!instance.modules) {
      return;
    }

    Object.keys(instance.modules).forEach(function (moduleName) {
      var module = instance.modules[moduleName];
      var moduleParams = modulesParams[moduleName] || {}; // Extend instance methods and props

      if (module.instance) {
        Object.keys(module.instance).forEach(function (modulePropName) {
          var moduleProp = module.instance[modulePropName];

          if (typeof moduleProp === 'function') {
            instance[modulePropName] = moduleProp.bind(instance);
          } else {
            instance[modulePropName] = moduleProp;
          }
        });
      } // Add event listeners


      if (module.on && instance.on) {
        Object.keys(module.on).forEach(function (moduleEventName) {
          instance.on(moduleEventName, module.on[moduleEventName]);
        });
      } // Module create callback


      if (module.create) {
        module.create.bind(instance)(moduleParams);
      }
    });
  };

  staticAccessors.components.set = function (components) {
    var Class = this;

    if (!Class.use) {
      return;
    }

    Class.use(components);
  };

  SwiperClass.installModule = function installModule(module) {
    var params = [],
        len = arguments.length - 1;

    while (len-- > 0) params[len] = arguments[len + 1];

    var Class = this;

    if (!Class.prototype.modules) {
      Class.prototype.modules = {};
    }

    var name = module.name || Object.keys(Class.prototype.modules).length + "_" + Utils.now();
    Class.prototype.modules[name] = module; // Prototype

    if (module.proto) {
      Object.keys(module.proto).forEach(function (key) {
        Class.prototype[key] = module.proto[key];
      });
    } // Class


    if (module.static) {
      Object.keys(module.static).forEach(function (key) {
        Class[key] = module.static[key];
      });
    } // Callback


    if (module.install) {
      module.install.apply(Class, params);
    }

    return Class;
  };

  SwiperClass.use = function use(module) {
    var params = [],
        len = arguments.length - 1;

    while (len-- > 0) params[len] = arguments[len + 1];

    var Class = this;

    if (Array.isArray(module)) {
      module.forEach(function (m) {
        return Class.installModule(m);
      });
      return Class;
    }

    return Class.installModule.apply(Class, [module].concat(params));
  };

  Object.defineProperties(SwiperClass, staticAccessors);

  function updateSize() {
    var swiper = this;
    var width;
    var height;
    var $el = swiper.$el;

    if (typeof swiper.params.width !== 'undefined') {
      width = swiper.params.width;
    } else {
      width = $el[0].clientWidth;
    }

    if (typeof swiper.params.height !== 'undefined') {
      height = swiper.params.height;
    } else {
      height = $el[0].clientHeight;
    }

    if (width === 0 && swiper.isHorizontal() || height === 0 && swiper.isVertical()) {
      return;
    } // Subtract paddings


    width = width - parseInt($el.css('padding-left'), 10) - parseInt($el.css('padding-right'), 10);
    height = height - parseInt($el.css('padding-top'), 10) - parseInt($el.css('padding-bottom'), 10);
    Utils.extend(swiper, {
      width: width,
      height: height,
      size: swiper.isHorizontal() ? width : height
    });
  }

  function updateSlides() {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var swiperSize = swiper.size;
    var rtl = swiper.rtlTranslate;
    var wrongRTL = swiper.wrongRTL;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    var previousSlidesLength = isVirtual ? swiper.virtual.slides.length : swiper.slides.length;
    var slides = $wrapperEl.children("." + swiper.params.slideClass);
    var slidesLength = isVirtual ? swiper.virtual.slides.length : slides.length;
    var snapGrid = [];
    var slidesGrid = [];
    var slidesSizesGrid = [];

    function slidesForMargin(slideIndex) {
      if (!params.cssMode) {
        return true;
      }

      if (slideIndex === slides.length - 1) {
        return false;
      }

      return true;
    }

    var offsetBefore = params.slidesOffsetBefore;

    if (typeof offsetBefore === 'function') {
      offsetBefore = params.slidesOffsetBefore.call(swiper);
    }

    var offsetAfter = params.slidesOffsetAfter;

    if (typeof offsetAfter === 'function') {
      offsetAfter = params.slidesOffsetAfter.call(swiper);
    }

    var previousSnapGridLength = swiper.snapGrid.length;
    var previousSlidesGridLength = swiper.snapGrid.length;
    var spaceBetween = params.spaceBetween;
    var slidePosition = -offsetBefore;
    var prevSlideSize = 0;
    var index = 0;

    if (typeof swiperSize === 'undefined') {
      return;
    }

    if (typeof spaceBetween === 'string' && spaceBetween.indexOf('%') >= 0) {
      spaceBetween = parseFloat(spaceBetween.replace('%', '')) / 100 * swiperSize;
    }

    swiper.virtualSize = -spaceBetween; // reset margins

    if (rtl) {
      slides.css({
        marginLeft: '',
        marginTop: ''
      });
    } else {
      slides.css({
        marginRight: '',
        marginBottom: ''
      });
    }

    var slidesNumberEvenToRows;

    if (params.slidesPerColumn > 1) {
      if (Math.floor(slidesLength / params.slidesPerColumn) === slidesLength / swiper.params.slidesPerColumn) {
        slidesNumberEvenToRows = slidesLength;
      } else {
        slidesNumberEvenToRows = Math.ceil(slidesLength / params.slidesPerColumn) * params.slidesPerColumn;
      }

      if (params.slidesPerView !== 'auto' && params.slidesPerColumnFill === 'row') {
        slidesNumberEvenToRows = Math.max(slidesNumberEvenToRows, params.slidesPerView * params.slidesPerColumn);
      }
    } // Calc slides


    var slideSize;
    var slidesPerColumn = params.slidesPerColumn;
    var slidesPerRow = slidesNumberEvenToRows / slidesPerColumn;
    var numFullColumns = Math.floor(slidesLength / params.slidesPerColumn);

    for (var i = 0; i < slidesLength; i += 1) {
      slideSize = 0;
      var slide = slides.eq(i);

      if (params.slidesPerColumn > 1) {
        // Set slides order
        var newSlideOrderIndex = void 0;
        var column = void 0;
        var row = void 0;

        if (params.slidesPerColumnFill === 'row' && params.slidesPerGroup > 1) {
          var groupIndex = Math.floor(i / (params.slidesPerGroup * params.slidesPerColumn));
          var slideIndexInGroup = i - params.slidesPerColumn * params.slidesPerGroup * groupIndex;
          var columnsInGroup = groupIndex === 0 ? params.slidesPerGroup : Math.min(Math.ceil((slidesLength - groupIndex * slidesPerColumn * params.slidesPerGroup) / slidesPerColumn), params.slidesPerGroup);
          row = Math.floor(slideIndexInGroup / columnsInGroup);
          column = slideIndexInGroup - row * columnsInGroup + groupIndex * params.slidesPerGroup;
          newSlideOrderIndex = column + row * slidesNumberEvenToRows / slidesPerColumn;
          slide.css({
            '-webkit-box-ordinal-group': newSlideOrderIndex,
            '-moz-box-ordinal-group': newSlideOrderIndex,
            '-ms-flex-order': newSlideOrderIndex,
            '-webkit-order': newSlideOrderIndex,
            order: newSlideOrderIndex
          });
        } else if (params.slidesPerColumnFill === 'column') {
          column = Math.floor(i / slidesPerColumn);
          row = i - column * slidesPerColumn;

          if (column > numFullColumns || column === numFullColumns && row === slidesPerColumn - 1) {
            row += 1;

            if (row >= slidesPerColumn) {
              row = 0;
              column += 1;
            }
          }
        } else {
          row = Math.floor(i / slidesPerRow);
          column = i - row * slidesPerRow;
        }

        slide.css("margin-" + (swiper.isHorizontal() ? 'top' : 'left'), row !== 0 && params.spaceBetween && params.spaceBetween + "px");
      }

      if (slide.css('display') === 'none') {
        continue;
      } // eslint-disable-line


      if (params.slidesPerView === 'auto') {
        var slideStyles = win.getComputedStyle(slide[0], null);
        var currentTransform = slide[0].style.transform;
        var currentWebKitTransform = slide[0].style.webkitTransform;

        if (currentTransform) {
          slide[0].style.transform = 'none';
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = 'none';
        }

        if (params.roundLengths) {
          slideSize = swiper.isHorizontal() ? slide.outerWidth(true) : slide.outerHeight(true);
        } else {
          // eslint-disable-next-line
          if (swiper.isHorizontal()) {
            var width = parseFloat(slideStyles.getPropertyValue('width'));
            var paddingLeft = parseFloat(slideStyles.getPropertyValue('padding-left'));
            var paddingRight = parseFloat(slideStyles.getPropertyValue('padding-right'));
            var marginLeft = parseFloat(slideStyles.getPropertyValue('margin-left'));
            var marginRight = parseFloat(slideStyles.getPropertyValue('margin-right'));
            var boxSizing = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing && boxSizing === 'border-box') {
              slideSize = width + marginLeft + marginRight;
            } else {
              slideSize = width + paddingLeft + paddingRight + marginLeft + marginRight;
            }
          } else {
            var height = parseFloat(slideStyles.getPropertyValue('height'));
            var paddingTop = parseFloat(slideStyles.getPropertyValue('padding-top'));
            var paddingBottom = parseFloat(slideStyles.getPropertyValue('padding-bottom'));
            var marginTop = parseFloat(slideStyles.getPropertyValue('margin-top'));
            var marginBottom = parseFloat(slideStyles.getPropertyValue('margin-bottom'));
            var boxSizing$1 = slideStyles.getPropertyValue('box-sizing');

            if (boxSizing$1 && boxSizing$1 === 'border-box') {
              slideSize = height + marginTop + marginBottom;
            } else {
              slideSize = height + paddingTop + paddingBottom + marginTop + marginBottom;
            }
          }
        }

        if (currentTransform) {
          slide[0].style.transform = currentTransform;
        }

        if (currentWebKitTransform) {
          slide[0].style.webkitTransform = currentWebKitTransform;
        }

        if (params.roundLengths) {
          slideSize = Math.floor(slideSize);
        }
      } else {
        slideSize = (swiperSize - (params.slidesPerView - 1) * spaceBetween) / params.slidesPerView;

        if (params.roundLengths) {
          slideSize = Math.floor(slideSize);
        }

        if (slides[i]) {
          if (swiper.isHorizontal()) {
            slides[i].style.width = slideSize + "px";
          } else {
            slides[i].style.height = slideSize + "px";
          }
        }
      }

      if (slides[i]) {
        slides[i].swiperSlideSize = slideSize;
      }

      slidesSizesGrid.push(slideSize);

      if (params.centeredSlides) {
        slidePosition = slidePosition + slideSize / 2 + prevSlideSize / 2 + spaceBetween;

        if (prevSlideSize === 0 && i !== 0) {
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        }

        if (i === 0) {
          slidePosition = slidePosition - swiperSize / 2 - spaceBetween;
        }

        if (Math.abs(slidePosition) < 1 / 1000) {
          slidePosition = 0;
        }

        if (params.roundLengths) {
          slidePosition = Math.floor(slidePosition);
        }

        if (index % params.slidesPerGroup === 0) {
          snapGrid.push(slidePosition);
        }

        slidesGrid.push(slidePosition);
      } else {
        if (params.roundLengths) {
          slidePosition = Math.floor(slidePosition);
        }

        if ((index - Math.min(swiper.params.slidesPerGroupSkip, index)) % swiper.params.slidesPerGroup === 0) {
          snapGrid.push(slidePosition);
        }

        slidesGrid.push(slidePosition);
        slidePosition = slidePosition + slideSize + spaceBetween;
      }

      swiper.virtualSize += slideSize + spaceBetween;
      prevSlideSize = slideSize;
      index += 1;
    }

    swiper.virtualSize = Math.max(swiper.virtualSize, swiperSize) + offsetAfter;
    var newSlidesGrid;

    if (rtl && wrongRTL && (params.effect === 'slide' || params.effect === 'coverflow')) {
      $wrapperEl.css({
        width: swiper.virtualSize + params.spaceBetween + "px"
      });
    }

    if (params.setWrapperSize) {
      if (swiper.isHorizontal()) {
        $wrapperEl.css({
          width: swiper.virtualSize + params.spaceBetween + "px"
        });
      } else {
        $wrapperEl.css({
          height: swiper.virtualSize + params.spaceBetween + "px"
        });
      }
    }

    if (params.slidesPerColumn > 1) {
      swiper.virtualSize = (slideSize + params.spaceBetween) * slidesNumberEvenToRows;
      swiper.virtualSize = Math.ceil(swiper.virtualSize / params.slidesPerColumn) - params.spaceBetween;

      if (swiper.isHorizontal()) {
        $wrapperEl.css({
          width: swiper.virtualSize + params.spaceBetween + "px"
        });
      } else {
        $wrapperEl.css({
          height: swiper.virtualSize + params.spaceBetween + "px"
        });
      }

      if (params.centeredSlides) {
        newSlidesGrid = [];

        for (var i$1 = 0; i$1 < snapGrid.length; i$1 += 1) {
          var slidesGridItem = snapGrid[i$1];

          if (params.roundLengths) {
            slidesGridItem = Math.floor(slidesGridItem);
          }

          if (snapGrid[i$1] < swiper.virtualSize + snapGrid[0]) {
            newSlidesGrid.push(slidesGridItem);
          }
        }

        snapGrid = newSlidesGrid;
      }
    } // Remove last grid elements depending on width


    if (!params.centeredSlides) {
      newSlidesGrid = [];

      for (var i$2 = 0; i$2 < snapGrid.length; i$2 += 1) {
        var slidesGridItem$1 = snapGrid[i$2];

        if (params.roundLengths) {
          slidesGridItem$1 = Math.floor(slidesGridItem$1);
        }

        if (snapGrid[i$2] <= swiper.virtualSize - swiperSize) {
          newSlidesGrid.push(slidesGridItem$1);
        }
      }

      snapGrid = newSlidesGrid;

      if (Math.floor(swiper.virtualSize - swiperSize) - Math.floor(snapGrid[snapGrid.length - 1]) > 1) {
        snapGrid.push(swiper.virtualSize - swiperSize);
      }
    }

    if (snapGrid.length === 0) {
      snapGrid = [0];
    }

    if (params.spaceBetween !== 0) {
      if (swiper.isHorizontal()) {
        if (rtl) {
          slides.filter(slidesForMargin).css({
            marginLeft: spaceBetween + "px"
          });
        } else {
          slides.filter(slidesForMargin).css({
            marginRight: spaceBetween + "px"
          });
        }
      } else {
        slides.filter(slidesForMargin).css({
          marginBottom: spaceBetween + "px"
        });
      }
    }

    if (params.centeredSlides && params.centeredSlidesBounds) {
      var allSlidesSize = 0;
      slidesSizesGrid.forEach(function (slideSizeValue) {
        allSlidesSize += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize -= params.spaceBetween;
      var maxSnap = allSlidesSize - swiperSize;
      snapGrid = snapGrid.map(function (snap) {
        if (snap < 0) {
          return -offsetBefore;
        }

        if (snap > maxSnap) {
          return maxSnap + offsetAfter;
        }

        return snap;
      });
    }

    if (params.centerInsufficientSlides) {
      var allSlidesSize$1 = 0;
      slidesSizesGrid.forEach(function (slideSizeValue) {
        allSlidesSize$1 += slideSizeValue + (params.spaceBetween ? params.spaceBetween : 0);
      });
      allSlidesSize$1 -= params.spaceBetween;

      if (allSlidesSize$1 < swiperSize) {
        var allSlidesOffset = (swiperSize - allSlidesSize$1) / 2;
        snapGrid.forEach(function (snap, snapIndex) {
          snapGrid[snapIndex] = snap - allSlidesOffset;
        });
        slidesGrid.forEach(function (snap, snapIndex) {
          slidesGrid[snapIndex] = snap + allSlidesOffset;
        });
      }
    }

    Utils.extend(swiper, {
      slides: slides,
      snapGrid: snapGrid,
      slidesGrid: slidesGrid,
      slidesSizesGrid: slidesSizesGrid
    });

    if (slidesLength !== previousSlidesLength) {
      swiper.emit('slidesLengthChange');
    }

    if (snapGrid.length !== previousSnapGridLength) {
      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      }

      swiper.emit('snapGridLengthChange');
    }

    if (slidesGrid.length !== previousSlidesGridLength) {
      swiper.emit('slidesGridLengthChange');
    }

    if (params.watchSlidesProgress || params.watchSlidesVisibility) {
      swiper.updateSlidesOffset();
    }
  }

  function updateAutoHeight(speed) {
    var swiper = this;
    var activeSlides = [];
    var newHeight = 0;
    var i;

    if (typeof speed === 'number') {
      swiper.setTransition(speed);
    } else if (speed === true) {
      swiper.setTransition(swiper.params.speed);
    } // Find slides currently in view


    if (swiper.params.slidesPerView !== 'auto' && swiper.params.slidesPerView > 1) {
      if (swiper.params.centeredSlides) {
        swiper.visibleSlides.each(function (index, slide) {
          activeSlides.push(slide);
        });
      } else {
        for (i = 0; i < Math.ceil(swiper.params.slidesPerView); i += 1) {
          var index = swiper.activeIndex + i;

          if (index > swiper.slides.length) {
            break;
          }

          activeSlides.push(swiper.slides.eq(index)[0]);
        }
      }
    } else {
      activeSlides.push(swiper.slides.eq(swiper.activeIndex)[0]);
    } // Find new height from highest slide in view


    for (i = 0; i < activeSlides.length; i += 1) {
      if (typeof activeSlides[i] !== 'undefined') {
        var height = activeSlides[i].offsetHeight;
        newHeight = height > newHeight ? height : newHeight;
      }
    } // Update Height


    if (newHeight) {
      swiper.$wrapperEl.css('height', newHeight + "px");
    }
  }

  function updateSlidesOffset() {
    var swiper = this;
    var slides = swiper.slides;

    for (var i = 0; i < slides.length; i += 1) {
      slides[i].swiperSlideOffset = swiper.isHorizontal() ? slides[i].offsetLeft : slides[i].offsetTop;
    }
  }

  function updateSlidesProgress(translate) {
    if (translate === void 0) translate = this && this.translate || 0;
    var swiper = this;
    var params = swiper.params;
    var slides = swiper.slides;
    var rtl = swiper.rtlTranslate;

    if (slides.length === 0) {
      return;
    }

    if (typeof slides[0].swiperSlideOffset === 'undefined') {
      swiper.updateSlidesOffset();
    }

    var offsetCenter = -translate;

    if (rtl) {
      offsetCenter = translate;
    } // Visible Slides


    slides.removeClass(params.slideVisibleClass);
    swiper.visibleSlidesIndexes = [];
    swiper.visibleSlides = [];

    for (var i = 0; i < slides.length; i += 1) {
      var slide = slides[i];
      var slideProgress = (offsetCenter + (params.centeredSlides ? swiper.minTranslate() : 0) - slide.swiperSlideOffset) / (slide.swiperSlideSize + params.spaceBetween);

      if (params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
        var slideBefore = -(offsetCenter - slide.swiperSlideOffset);
        var slideAfter = slideBefore + swiper.slidesSizesGrid[i];
        var isVisible = slideBefore >= 0 && slideBefore < swiper.size - 1 || slideAfter > 1 && slideAfter <= swiper.size || slideBefore <= 0 && slideAfter >= swiper.size;

        if (isVisible) {
          swiper.visibleSlides.push(slide);
          swiper.visibleSlidesIndexes.push(i);
          slides.eq(i).addClass(params.slideVisibleClass);
        }
      }

      slide.progress = rtl ? -slideProgress : slideProgress;
    }

    swiper.visibleSlides = $(swiper.visibleSlides);
  }

  function updateProgress(translate) {
    var swiper = this;

    if (typeof translate === 'undefined') {
      var multiplier = swiper.rtlTranslate ? -1 : 1; // eslint-disable-next-line

      translate = swiper && swiper.translate && swiper.translate * multiplier || 0;
    }

    var params = swiper.params;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();
    var progress = swiper.progress;
    var isBeginning = swiper.isBeginning;
    var isEnd = swiper.isEnd;
    var wasBeginning = isBeginning;
    var wasEnd = isEnd;

    if (translatesDiff === 0) {
      progress = 0;
      isBeginning = true;
      isEnd = true;
    } else {
      progress = (translate - swiper.minTranslate()) / translatesDiff;
      isBeginning = progress <= 0;
      isEnd = progress >= 1;
    }

    Utils.extend(swiper, {
      progress: progress,
      isBeginning: isBeginning,
      isEnd: isEnd
    });

    if (params.watchSlidesProgress || params.watchSlidesVisibility || params.centeredSlides && params.autoHeight) {
      swiper.updateSlidesProgress(translate);
    }

    if (isBeginning && !wasBeginning) {
      swiper.emit('reachBeginning toEdge');
    }

    if (isEnd && !wasEnd) {
      swiper.emit('reachEnd toEdge');
    }

    if (wasBeginning && !isBeginning || wasEnd && !isEnd) {
      swiper.emit('fromEdge');
    }

    swiper.emit('progress', progress);
  }

  function updateSlidesClasses() {
    var swiper = this;
    var slides = swiper.slides;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var activeIndex = swiper.activeIndex;
    var realIndex = swiper.realIndex;
    var isVirtual = swiper.virtual && params.virtual.enabled;
    slides.removeClass(params.slideActiveClass + " " + params.slideNextClass + " " + params.slidePrevClass + " " + params.slideDuplicateActiveClass + " " + params.slideDuplicateNextClass + " " + params.slideDuplicatePrevClass);
    var activeSlide;

    if (isVirtual) {
      activeSlide = swiper.$wrapperEl.find("." + params.slideClass + "[data-swiper-slide-index=\"" + activeIndex + "\"]");
    } else {
      activeSlide = slides.eq(activeIndex);
    } // Active classes


    activeSlide.addClass(params.slideActiveClass);

    if (params.loop) {
      // Duplicate to all looped slides
      if (activeSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
      } else {
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + realIndex + "\"]").addClass(params.slideDuplicateActiveClass);
      }
    } // Next Slide


    var nextSlide = activeSlide.nextAll("." + params.slideClass).eq(0).addClass(params.slideNextClass);

    if (params.loop && nextSlide.length === 0) {
      nextSlide = slides.eq(0);
      nextSlide.addClass(params.slideNextClass);
    } // Prev Slide


    var prevSlide = activeSlide.prevAll("." + params.slideClass).eq(0).addClass(params.slidePrevClass);

    if (params.loop && prevSlide.length === 0) {
      prevSlide = slides.eq(-1);
      prevSlide.addClass(params.slidePrevClass);
    }

    if (params.loop) {
      // Duplicate to all looped slides
      if (nextSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
      } else {
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + nextSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicateNextClass);
      }

      if (prevSlide.hasClass(params.slideDuplicateClass)) {
        $wrapperEl.children("." + params.slideClass + ":not(." + params.slideDuplicateClass + ")[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
      } else {
        $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + "[data-swiper-slide-index=\"" + prevSlide.attr('data-swiper-slide-index') + "\"]").addClass(params.slideDuplicatePrevClass);
      }
    }
  }

  function updateActiveIndex(newActiveIndex) {
    var swiper = this;
    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;
    var slidesGrid = swiper.slidesGrid;
    var snapGrid = swiper.snapGrid;
    var params = swiper.params;
    var previousIndex = swiper.activeIndex;
    var previousRealIndex = swiper.realIndex;
    var previousSnapIndex = swiper.snapIndex;
    var activeIndex = newActiveIndex;
    var snapIndex;

    if (typeof activeIndex === 'undefined') {
      for (var i = 0; i < slidesGrid.length; i += 1) {
        if (typeof slidesGrid[i + 1] !== 'undefined') {
          if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1] - (slidesGrid[i + 1] - slidesGrid[i]) / 2) {
            activeIndex = i;
          } else if (translate >= slidesGrid[i] && translate < slidesGrid[i + 1]) {
            activeIndex = i + 1;
          }
        } else if (translate >= slidesGrid[i]) {
          activeIndex = i;
        }
      } // Normalize slideIndex


      if (params.normalizeSlideIndex) {
        if (activeIndex < 0 || typeof activeIndex === 'undefined') {
          activeIndex = 0;
        }
      }
    }

    if (snapGrid.indexOf(translate) >= 0) {
      snapIndex = snapGrid.indexOf(translate);
    } else {
      var skip = Math.min(params.slidesPerGroupSkip, activeIndex);
      snapIndex = skip + Math.floor((activeIndex - skip) / params.slidesPerGroup);
    }

    if (snapIndex >= snapGrid.length) {
      snapIndex = snapGrid.length - 1;
    }

    if (activeIndex === previousIndex) {
      if (snapIndex !== previousSnapIndex) {
        swiper.snapIndex = snapIndex;
        swiper.emit('snapIndexChange');
      }

      return;
    } // Get real index


    var realIndex = parseInt(swiper.slides.eq(activeIndex).attr('data-swiper-slide-index') || activeIndex, 10);
    Utils.extend(swiper, {
      snapIndex: snapIndex,
      realIndex: realIndex,
      previousIndex: previousIndex,
      activeIndex: activeIndex
    });
    swiper.emit('activeIndexChange');
    swiper.emit('snapIndexChange');

    if (previousRealIndex !== realIndex) {
      swiper.emit('realIndexChange');
    }

    if (swiper.initialized || swiper.params.runCallbacksOnInit) {
      swiper.emit('slideChange');
    }
  }

  function updateClickedSlide(e) {
    var swiper = this;
    var params = swiper.params;
    var slide = $(e.target).closest("." + params.slideClass)[0];
    var slideFound = false;

    if (slide) {
      for (var i = 0; i < swiper.slides.length; i += 1) {
        if (swiper.slides[i] === slide) {
          slideFound = true;
        }
      }
    }

    if (slide && slideFound) {
      swiper.clickedSlide = slide;

      if (swiper.virtual && swiper.params.virtual.enabled) {
        swiper.clickedIndex = parseInt($(slide).attr('data-swiper-slide-index'), 10);
      } else {
        swiper.clickedIndex = $(slide).index();
      }
    } else {
      swiper.clickedSlide = undefined;
      swiper.clickedIndex = undefined;
      return;
    }

    if (params.slideToClickedSlide && swiper.clickedIndex !== undefined && swiper.clickedIndex !== swiper.activeIndex) {
      swiper.slideToClickedSlide();
    }
  }

  var update = {
    updateSize: updateSize,
    updateSlides: updateSlides,
    updateAutoHeight: updateAutoHeight,
    updateSlidesOffset: updateSlidesOffset,
    updateSlidesProgress: updateSlidesProgress,
    updateProgress: updateProgress,
    updateSlidesClasses: updateSlidesClasses,
    updateActiveIndex: updateActiveIndex,
    updateClickedSlide: updateClickedSlide
  };

  function getTranslate(axis) {
    if (axis === void 0) axis = this.isHorizontal() ? 'x' : 'y';
    var swiper = this;
    var params = swiper.params;
    var rtl = swiper.rtlTranslate;
    var translate = swiper.translate;
    var $wrapperEl = swiper.$wrapperEl;

    if (params.virtualTranslate) {
      return rtl ? -translate : translate;
    }

    if (params.cssMode) {
      return translate;
    }

    var currentTranslate = Utils.getTranslate($wrapperEl[0], axis);

    if (rtl) {
      currentTranslate = -currentTranslate;
    }

    return currentTranslate || 0;
  }

  function setTranslate(translate, byController) {
    var swiper = this;
    var rtl = swiper.rtlTranslate;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var wrapperEl = swiper.wrapperEl;
    var progress = swiper.progress;
    var x = 0;
    var y = 0;
    var z = 0;

    if (swiper.isHorizontal()) {
      x = rtl ? -translate : translate;
    } else {
      y = translate;
    }

    if (params.roundLengths) {
      x = Math.floor(x);
      y = Math.floor(y);
    }

    if (params.cssMode) {
      wrapperEl[swiper.isHorizontal() ? 'scrollLeft' : 'scrollTop'] = swiper.isHorizontal() ? -x : -y;
    } else if (!params.virtualTranslate) {
      $wrapperEl.transform("translate3d(" + x + "px, " + y + "px, " + z + "px)");
    }

    swiper.previousTranslate = swiper.translate;
    swiper.translate = swiper.isHorizontal() ? x : y; // Check if we need to update progress

    var newProgress;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (translate - swiper.minTranslate()) / translatesDiff;
    }

    if (newProgress !== progress) {
      swiper.updateProgress(translate);
    }

    swiper.emit('setTranslate', swiper.translate, byController);
  }

  function minTranslate() {
    return -this.snapGrid[0];
  }

  function maxTranslate() {
    return -this.snapGrid[this.snapGrid.length - 1];
  }

  function translateTo(translate, speed, runCallbacks, translateBounds, internal) {
    var obj;
    if (translate === void 0) translate = 0;
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    if (translateBounds === void 0) translateBounds = true;
    var swiper = this;
    var params = swiper.params;
    var wrapperEl = swiper.wrapperEl;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }

    var minTranslate = swiper.minTranslate();
    var maxTranslate = swiper.maxTranslate();
    var newTranslate;

    if (translateBounds && translate > minTranslate) {
      newTranslate = minTranslate;
    } else if (translateBounds && translate < maxTranslate) {
      newTranslate = maxTranslate;
    } else {
      newTranslate = translate;
    } // Update progress


    swiper.updateProgress(newTranslate);

    if (params.cssMode) {
      var isH = swiper.isHorizontal();

      if (speed === 0) {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
      } else {
        // eslint-disable-next-line
        if (wrapperEl.scrollTo) {
          wrapperEl.scrollTo((obj = {}, obj[isH ? 'left' : 'top'] = -newTranslate, obj.behavior = 'smooth', obj));
        } else {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = -newTranslate;
        }
      }

      return true;
    }

    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(newTranslate);

      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionEnd');
      }
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(newTranslate);

      if (runCallbacks) {
        swiper.emit('beforeTransitionStart', speed, internal);
        swiper.emit('transitionStart');
      }

      if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onTranslateToWrapperTransitionEnd) {
          swiper.onTranslateToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) {
              return;
            }

            if (e.target !== this) {
              return;
            }

            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
            swiper.onTranslateToWrapperTransitionEnd = null;
            delete swiper.onTranslateToWrapperTransitionEnd;

            if (runCallbacks) {
              swiper.emit('transitionEnd');
            }
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onTranslateToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onTranslateToWrapperTransitionEnd);
      }
    }

    return true;
  }

  var translate = {
    getTranslate: getTranslate,
    setTranslate: setTranslate,
    minTranslate: minTranslate,
    maxTranslate: maxTranslate,
    translateTo: translateTo
  };

  function setTransition(duration, byController) {
    var swiper = this;

    if (!swiper.params.cssMode) {
      swiper.$wrapperEl.transition(duration);
    }

    swiper.emit('setTransition', duration, byController);
  }

  function transitionStart(runCallbacks, direction) {
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var activeIndex = swiper.activeIndex;
    var params = swiper.params;
    var previousIndex = swiper.previousIndex;

    if (params.cssMode) {
      return;
    }

    if (params.autoHeight) {
      swiper.updateAutoHeight();
    }

    var dir = direction;

    if (!dir) {
      if (activeIndex > previousIndex) {
        dir = 'next';
      } else if (activeIndex < previousIndex) {
        dir = 'prev';
      } else {
        dir = 'reset';
      }
    }

    swiper.emit('transitionStart');

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit('slideResetTransitionStart');
        return;
      }

      swiper.emit('slideChangeTransitionStart');

      if (dir === 'next') {
        swiper.emit('slideNextTransitionStart');
      } else {
        swiper.emit('slidePrevTransitionStart');
      }
    }
  }

  function transitionEnd$1(runCallbacks, direction) {
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var activeIndex = swiper.activeIndex;
    var previousIndex = swiper.previousIndex;
    var params = swiper.params;
    swiper.animating = false;

    if (params.cssMode) {
      return;
    }

    swiper.setTransition(0);
    var dir = direction;

    if (!dir) {
      if (activeIndex > previousIndex) {
        dir = 'next';
      } else if (activeIndex < previousIndex) {
        dir = 'prev';
      } else {
        dir = 'reset';
      }
    }

    swiper.emit('transitionEnd');

    if (runCallbacks && activeIndex !== previousIndex) {
      if (dir === 'reset') {
        swiper.emit('slideResetTransitionEnd');
        return;
      }

      swiper.emit('slideChangeTransitionEnd');

      if (dir === 'next') {
        swiper.emit('slideNextTransitionEnd');
      } else {
        swiper.emit('slidePrevTransitionEnd');
      }
    }
  }

  var transition$1 = {
    setTransition: setTransition,
    transitionStart: transitionStart,
    transitionEnd: transitionEnd$1
  };

  function slideTo(index, speed, runCallbacks, internal) {
    var obj;
    if (index === void 0) index = 0;
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var slideIndex = index;

    if (slideIndex < 0) {
      slideIndex = 0;
    }

    var params = swiper.params;
    var snapGrid = swiper.snapGrid;
    var slidesGrid = swiper.slidesGrid;
    var previousIndex = swiper.previousIndex;
    var activeIndex = swiper.activeIndex;
    var rtl = swiper.rtlTranslate;
    var wrapperEl = swiper.wrapperEl;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return false;
    }

    var skip = Math.min(swiper.params.slidesPerGroupSkip, slideIndex);
    var snapIndex = skip + Math.floor((slideIndex - skip) / swiper.params.slidesPerGroup);

    if (snapIndex >= snapGrid.length) {
      snapIndex = snapGrid.length - 1;
    }

    if ((activeIndex || params.initialSlide || 0) === (previousIndex || 0) && runCallbacks) {
      swiper.emit('beforeSlideChangeStart');
    }

    var translate = -snapGrid[snapIndex]; // Update progress

    swiper.updateProgress(translate); // Normalize slideIndex

    if (params.normalizeSlideIndex) {
      for (var i = 0; i < slidesGrid.length; i += 1) {
        if (-Math.floor(translate * 100) >= Math.floor(slidesGrid[i] * 100)) {
          slideIndex = i;
        }
      }
    } // Directions locks


    if (swiper.initialized && slideIndex !== activeIndex) {
      if (!swiper.allowSlideNext && translate < swiper.translate && translate < swiper.minTranslate()) {
        return false;
      }

      if (!swiper.allowSlidePrev && translate > swiper.translate && translate > swiper.maxTranslate()) {
        if ((activeIndex || 0) !== slideIndex) {
          return false;
        }
      }
    }

    var direction;

    if (slideIndex > activeIndex) {
      direction = 'next';
    } else if (slideIndex < activeIndex) {
      direction = 'prev';
    } else {
      direction = 'reset';
    } // Update Index


    if (rtl && -translate === swiper.translate || !rtl && translate === swiper.translate) {
      swiper.updateActiveIndex(slideIndex); // Update Height

      if (params.autoHeight) {
        swiper.updateAutoHeight();
      }

      swiper.updateSlidesClasses();

      if (params.effect !== 'slide') {
        swiper.setTranslate(translate);
      }

      if (direction !== 'reset') {
        swiper.transitionStart(runCallbacks, direction);
        swiper.transitionEnd(runCallbacks, direction);
      }

      return false;
    }

    if (params.cssMode) {
      var isH = swiper.isHorizontal();
      var t = -translate;

      if (rtl) {
        t = wrapperEl.scrollWidth - wrapperEl.offsetWidth - t;
      }

      if (speed === 0) {
        wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
      } else {
        // eslint-disable-next-line
        if (wrapperEl.scrollTo) {
          wrapperEl.scrollTo((obj = {}, obj[isH ? 'left' : 'top'] = t, obj.behavior = 'smooth', obj));
        } else {
          wrapperEl[isH ? 'scrollLeft' : 'scrollTop'] = t;
        }
      }

      return true;
    }

    if (speed === 0) {
      swiper.setTransition(0);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);
      swiper.transitionEnd(runCallbacks, direction);
    } else {
      swiper.setTransition(speed);
      swiper.setTranslate(translate);
      swiper.updateActiveIndex(slideIndex);
      swiper.updateSlidesClasses();
      swiper.emit('beforeTransitionStart', speed, internal);
      swiper.transitionStart(runCallbacks, direction);

      if (!swiper.animating) {
        swiper.animating = true;

        if (!swiper.onSlideToWrapperTransitionEnd) {
          swiper.onSlideToWrapperTransitionEnd = function transitionEnd(e) {
            if (!swiper || swiper.destroyed) {
              return;
            }

            if (e.target !== this) {
              return;
            }

            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
            swiper.onSlideToWrapperTransitionEnd = null;
            delete swiper.onSlideToWrapperTransitionEnd;
            swiper.transitionEnd(runCallbacks, direction);
          };
        }

        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.onSlideToWrapperTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.onSlideToWrapperTransitionEnd);
      }
    }

    return true;
  }

  function slideToLoop(index, speed, runCallbacks, internal) {
    if (index === void 0) index = 0;
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var newIndex = index;

    if (swiper.params.loop) {
      newIndex += swiper.loopedSlides;
    }

    return swiper.slideTo(newIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideNext(speed, runCallbacks, internal) {
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var params = swiper.params;
    var animating = swiper.animating;
    var increment = swiper.activeIndex < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup;

    if (params.loop) {
      if (animating) {
        return false;
      }

      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }

    return swiper.slideTo(swiper.activeIndex + increment, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slidePrev(speed, runCallbacks, internal) {
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    var params = swiper.params;
    var animating = swiper.animating;
    var snapGrid = swiper.snapGrid;
    var slidesGrid = swiper.slidesGrid;
    var rtlTranslate = swiper.rtlTranslate;

    if (params.loop) {
      if (animating) {
        return false;
      }

      swiper.loopFix(); // eslint-disable-next-line

      swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
    }

    var translate = rtlTranslate ? swiper.translate : -swiper.translate;

    function normalize(val) {
      if (val < 0) {
        return -Math.floor(Math.abs(val));
      }

      return Math.floor(val);
    }

    var normalizedTranslate = normalize(translate);
    var normalizedSnapGrid = snapGrid.map(function (val) {
      return normalize(val);
    });
    var normalizedSlidesGrid = slidesGrid.map(function (val) {
      return normalize(val);
    });
    var currentSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate)];
    var prevSnap = snapGrid[normalizedSnapGrid.indexOf(normalizedTranslate) - 1];

    if (typeof prevSnap === 'undefined' && params.cssMode) {
      snapGrid.forEach(function (snap) {
        if (!prevSnap && normalizedTranslate >= snap) {
          prevSnap = snap;
        }
      });
    }

    var prevIndex;

    if (typeof prevSnap !== 'undefined') {
      prevIndex = slidesGrid.indexOf(prevSnap);

      if (prevIndex < 0) {
        prevIndex = swiper.activeIndex - 1;
      }
    }

    return swiper.slideTo(prevIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideReset(speed, runCallbacks, internal) {
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    var swiper = this;
    return swiper.slideTo(swiper.activeIndex, speed, runCallbacks, internal);
  }
  /* eslint no-unused-vars: "off" */


  function slideToClosest(speed, runCallbacks, internal, threshold) {
    if (speed === void 0) speed = this.params.speed;
    if (runCallbacks === void 0) runCallbacks = true;
    if (threshold === void 0) threshold = 0.5;
    var swiper = this;
    var index = swiper.activeIndex;
    var skip = Math.min(swiper.params.slidesPerGroupSkip, index);
    var snapIndex = skip + Math.floor((index - skip) / swiper.params.slidesPerGroup);
    var translate = swiper.rtlTranslate ? swiper.translate : -swiper.translate;

    if (translate >= swiper.snapGrid[snapIndex]) {
      // The current translate is on or after the current snap index, so the choice
      // is between the current index and the one after it.
      var currentSnap = swiper.snapGrid[snapIndex];
      var nextSnap = swiper.snapGrid[snapIndex + 1];

      if (translate - currentSnap > (nextSnap - currentSnap) * threshold) {
        index += swiper.params.slidesPerGroup;
      }
    } else {
      // The current translate is before the current snap index, so the choice
      // is between the current index and the one before it.
      var prevSnap = swiper.snapGrid[snapIndex - 1];
      var currentSnap$1 = swiper.snapGrid[snapIndex];

      if (translate - prevSnap <= (currentSnap$1 - prevSnap) * threshold) {
        index -= swiper.params.slidesPerGroup;
      }
    }

    index = Math.max(index, 0);
    index = Math.min(index, swiper.slidesGrid.length - 1);
    return swiper.slideTo(index, speed, runCallbacks, internal);
  }

  function slideToClickedSlide() {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var slidesPerView = params.slidesPerView === 'auto' ? swiper.slidesPerViewDynamic() : params.slidesPerView;
    var slideToIndex = swiper.clickedIndex;
    var realIndex;

    if (params.loop) {
      if (swiper.animating) {
        return;
      }

      realIndex = parseInt($(swiper.clickedSlide).attr('data-swiper-slide-index'), 10);

      if (params.centeredSlides) {
        if (slideToIndex < swiper.loopedSlides - slidesPerView / 2 || slideToIndex > swiper.slides.length - swiper.loopedSlides + slidesPerView / 2) {
          swiper.loopFix();
          slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
          Utils.nextTick(function () {
            swiper.slideTo(slideToIndex);
          });
        } else {
          swiper.slideTo(slideToIndex);
        }
      } else if (slideToIndex > swiper.slides.length - slidesPerView) {
        swiper.loopFix();
        slideToIndex = $wrapperEl.children("." + params.slideClass + "[data-swiper-slide-index=\"" + realIndex + "\"]:not(." + params.slideDuplicateClass + ")").eq(0).index();
        Utils.nextTick(function () {
          swiper.slideTo(slideToIndex);
        });
      } else {
        swiper.slideTo(slideToIndex);
      }
    } else {
      swiper.slideTo(slideToIndex);
    }
  }

  var slide = {
    slideTo: slideTo,
    slideToLoop: slideToLoop,
    slideNext: slideNext,
    slidePrev: slidePrev,
    slideReset: slideReset,
    slideToClosest: slideToClosest,
    slideToClickedSlide: slideToClickedSlide
  };

  function loopCreate() {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl; // Remove duplicated slides

    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass).remove();
    var slides = $wrapperEl.children("." + params.slideClass);

    if (params.loopFillGroupWithBlank) {
      var blankSlidesNum = params.slidesPerGroup - slides.length % params.slidesPerGroup;

      if (blankSlidesNum !== params.slidesPerGroup) {
        for (var i = 0; i < blankSlidesNum; i += 1) {
          var blankNode = $(doc.createElement('div')).addClass(params.slideClass + " " + params.slideBlankClass);
          $wrapperEl.append(blankNode);
        }

        slides = $wrapperEl.children("." + params.slideClass);
      }
    }

    if (params.slidesPerView === 'auto' && !params.loopedSlides) {
      params.loopedSlides = slides.length;
    }

    swiper.loopedSlides = Math.ceil(parseFloat(params.loopedSlides || params.slidesPerView, 10));
    swiper.loopedSlides += params.loopAdditionalSlides;

    if (swiper.loopedSlides > slides.length) {
      swiper.loopedSlides = slides.length;
    }

    var prependSlides = [];
    var appendSlides = [];
    slides.each(function (index, el) {
      var slide = $(el);

      if (index < swiper.loopedSlides) {
        appendSlides.push(el);
      }

      if (index < slides.length && index >= slides.length - swiper.loopedSlides) {
        prependSlides.push(el);
      }

      slide.attr('data-swiper-slide-index', index);
    });

    for (var i$1 = 0; i$1 < appendSlides.length; i$1 += 1) {
      $wrapperEl.append($(appendSlides[i$1].cloneNode(true)).addClass(params.slideDuplicateClass));
    }

    for (var i$2 = prependSlides.length - 1; i$2 >= 0; i$2 -= 1) {
      $wrapperEl.prepend($(prependSlides[i$2].cloneNode(true)).addClass(params.slideDuplicateClass));
    }
  }

  function loopFix() {
    var swiper = this;
    swiper.emit('beforeLoopFix');
    var activeIndex = swiper.activeIndex;
    var slides = swiper.slides;
    var loopedSlides = swiper.loopedSlides;
    var allowSlidePrev = swiper.allowSlidePrev;
    var allowSlideNext = swiper.allowSlideNext;
    var snapGrid = swiper.snapGrid;
    var rtl = swiper.rtlTranslate;
    var newIndex;
    swiper.allowSlidePrev = true;
    swiper.allowSlideNext = true;
    var snapTranslate = -snapGrid[activeIndex];
    var diff = snapTranslate - swiper.getTranslate(); // Fix For Negative Oversliding

    if (activeIndex < loopedSlides) {
      newIndex = slides.length - loopedSlides * 3 + activeIndex;
      newIndex += loopedSlides;
      var slideChanged = swiper.slideTo(newIndex, 0, false, true);

      if (slideChanged && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    } else if (activeIndex >= slides.length - loopedSlides) {
      // Fix For Positive Oversliding
      newIndex = -slides.length + activeIndex + loopedSlides;
      newIndex += loopedSlides;
      var slideChanged$1 = swiper.slideTo(newIndex, 0, false, true);

      if (slideChanged$1 && diff !== 0) {
        swiper.setTranslate((rtl ? -swiper.translate : swiper.translate) - diff);
      }
    }

    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;
    swiper.emit('loopFix');
  }

  function loopDestroy() {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl;
    var params = swiper.params;
    var slides = swiper.slides;
    $wrapperEl.children("." + params.slideClass + "." + params.slideDuplicateClass + ",." + params.slideClass + "." + params.slideBlankClass).remove();
    slides.removeAttr('data-swiper-slide-index');
  }

  var loop = {
    loopCreate: loopCreate,
    loopFix: loopFix,
    loopDestroy: loopDestroy
  };

  function setGrabCursor(moving) {
    var swiper = this;

    if (Support.touch || !swiper.params.simulateTouch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }

    var el = swiper.el;
    el.style.cursor = 'move';
    el.style.cursor = moving ? '-webkit-grabbing' : '-webkit-grab';
    el.style.cursor = moving ? '-moz-grabbin' : '-moz-grab';
    el.style.cursor = moving ? 'grabbing' : 'grab';
  }

  function unsetGrabCursor() {
    var swiper = this;

    if (Support.touch || swiper.params.watchOverflow && swiper.isLocked || swiper.params.cssMode) {
      return;
    }

    swiper.el.style.cursor = '';
  }

  var grabCursor = {
    setGrabCursor: setGrabCursor,
    unsetGrabCursor: unsetGrabCursor
  };

  function appendSlide(slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl;
    var params = swiper.params;

    if (params.loop) {
      swiper.loopDestroy();
    }

    if (typeof slides === 'object' && 'length' in slides) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) {
          $wrapperEl.append(slides[i]);
        }
      }
    } else {
      $wrapperEl.append(slides);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && Support.observer)) {
      swiper.update();
    }
  }

  function prependSlide(slides) {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var activeIndex = swiper.activeIndex;

    if (params.loop) {
      swiper.loopDestroy();
    }

    var newActiveIndex = activeIndex + 1;

    if (typeof slides === 'object' && 'length' in slides) {
      for (var i = 0; i < slides.length; i += 1) {
        if (slides[i]) {
          $wrapperEl.prepend(slides[i]);
        }
      }

      newActiveIndex = activeIndex + slides.length;
    } else {
      $wrapperEl.prepend(slides);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && Support.observer)) {
      swiper.update();
    }

    swiper.slideTo(newActiveIndex, 0, false);
  }

  function addSlide(index, slides) {
    var swiper = this;
    var $wrapperEl = swiper.$wrapperEl;
    var params = swiper.params;
    var activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;

    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children("." + params.slideClass);
    }

    var baseLength = swiper.slides.length;

    if (index <= 0) {
      swiper.prependSlide(slides);
      return;
    }

    if (index >= baseLength) {
      swiper.appendSlide(slides);
      return;
    }

    var newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + 1 : activeIndexBuffer;
    var slidesBuffer = [];

    for (var i = baseLength - 1; i >= index; i -= 1) {
      var currentSlide = swiper.slides.eq(i);
      currentSlide.remove();
      slidesBuffer.unshift(currentSlide);
    }

    if (typeof slides === 'object' && 'length' in slides) {
      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
        if (slides[i$1]) {
          $wrapperEl.append(slides[i$1]);
        }
      }

      newActiveIndex = activeIndexBuffer > index ? activeIndexBuffer + slides.length : activeIndexBuffer;
    } else {
      $wrapperEl.append(slides);
    }

    for (var i$2 = 0; i$2 < slidesBuffer.length; i$2 += 1) {
      $wrapperEl.append(slidesBuffer[i$2]);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && Support.observer)) {
      swiper.update();
    }

    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeSlide(slidesIndexes) {
    var swiper = this;
    var params = swiper.params;
    var $wrapperEl = swiper.$wrapperEl;
    var activeIndex = swiper.activeIndex;
    var activeIndexBuffer = activeIndex;

    if (params.loop) {
      activeIndexBuffer -= swiper.loopedSlides;
      swiper.loopDestroy();
      swiper.slides = $wrapperEl.children("." + params.slideClass);
    }

    var newActiveIndex = activeIndexBuffer;
    var indexToRemove;

    if (typeof slidesIndexes === 'object' && 'length' in slidesIndexes) {
      for (var i = 0; i < slidesIndexes.length; i += 1) {
        indexToRemove = slidesIndexes[i];

        if (swiper.slides[indexToRemove]) {
          swiper.slides.eq(indexToRemove).remove();
        }

        if (indexToRemove < newActiveIndex) {
          newActiveIndex -= 1;
        }
      }

      newActiveIndex = Math.max(newActiveIndex, 0);
    } else {
      indexToRemove = slidesIndexes;

      if (swiper.slides[indexToRemove]) {
        swiper.slides.eq(indexToRemove).remove();
      }

      if (indexToRemove < newActiveIndex) {
        newActiveIndex -= 1;
      }

      newActiveIndex = Math.max(newActiveIndex, 0);
    }

    if (params.loop) {
      swiper.loopCreate();
    }

    if (!(params.observer && Support.observer)) {
      swiper.update();
    }

    if (params.loop) {
      swiper.slideTo(newActiveIndex + swiper.loopedSlides, 0, false);
    } else {
      swiper.slideTo(newActiveIndex, 0, false);
    }
  }

  function removeAllSlides() {
    var swiper = this;
    var slidesIndexes = [];

    for (var i = 0; i < swiper.slides.length; i += 1) {
      slidesIndexes.push(i);
    }

    swiper.removeSlide(slidesIndexes);
  }

  var manipulation = {
    appendSlide: appendSlide,
    prependSlide: prependSlide,
    addSlide: addSlide,
    removeSlide: removeSlide,
    removeAllSlides: removeAllSlides
  };

  var Device = function Device() {
    var platform = win.navigator.platform;
    var ua = win.navigator.userAgent;
    var device = {
      ios: false,
      android: false,
      androidChrome: false,
      desktop: false,
      iphone: false,
      ipod: false,
      ipad: false,
      edge: false,
      ie: false,
      firefox: false,
      macos: false,
      windows: false,
      cordova: !!(win.cordova || win.phonegap),
      phonegap: !!(win.cordova || win.phonegap),
      electron: false
    };
    var screenWidth = win.screen.width;
    var screenHeight = win.screen.height;
    var android = ua.match(/(Android);?[\s\/]+([\d.]+)?/); // eslint-disable-line

    var ipad = ua.match(/(iPad).*OS\s([\d_]+)/);
    var ipod = ua.match(/(iPod)(.*OS\s([\d_]+))?/);
    var iphone = !ipad && ua.match(/(iPhone\sOS|iOS)\s([\d_]+)/);
    var ie = ua.indexOf('MSIE ') >= 0 || ua.indexOf('Trident/') >= 0;
    var edge = ua.indexOf('Edge/') >= 0;
    var firefox = ua.indexOf('Gecko/') >= 0 && ua.indexOf('Firefox/') >= 0;
    var windows = platform === 'Win32';
    var electron = ua.toLowerCase().indexOf('electron') >= 0;
    var macos = platform === 'MacIntel'; // iPadOs 13 fix

    if (!ipad && macos && Support.touch && (screenWidth === 1024 && screenHeight === 1366 || // Pro 12.9
    screenWidth === 834 && screenHeight === 1194 // Pro 11
    || screenWidth === 834 && screenHeight === 1112 // Pro 10.5
    || screenWidth === 768 && screenHeight === 1024 // other
    )) {
      ipad = ua.match(/(Version)\/([\d.]+)/);
      macos = false;
    }

    device.ie = ie;
    device.edge = edge;
    device.firefox = firefox; // Android

    if (android && !windows) {
      device.os = 'android';
      device.osVersion = android[2];
      device.android = true;
      device.androidChrome = ua.toLowerCase().indexOf('chrome') >= 0;
    }

    if (ipad || iphone || ipod) {
      device.os = 'ios';
      device.ios = true;
    } // iOS


    if (iphone && !ipod) {
      device.osVersion = iphone[2].replace(/_/g, '.');
      device.iphone = true;
    }

    if (ipad) {
      device.osVersion = ipad[2].replace(/_/g, '.');
      device.ipad = true;
    }

    if (ipod) {
      device.osVersion = ipod[3] ? ipod[3].replace(/_/g, '.') : null;
      device.ipod = true;
    } // iOS 8+ changed UA


    if (device.ios && device.osVersion && ua.indexOf('Version/') >= 0) {
      if (device.osVersion.split('.')[0] === '10') {
        device.osVersion = ua.toLowerCase().split('version/')[1].split(' ')[0];
      }
    } // Webview


    device.webView = !!((iphone || ipad || ipod) && (ua.match(/.*AppleWebKit(?!.*Safari)/i) || win.navigator.standalone)) || win.matchMedia && win.matchMedia('(display-mode: standalone)').matches;
    device.webview = device.webView;
    device.standalone = device.webView; // Desktop

    device.desktop = !(device.ios || device.android) || electron;

    if (device.desktop) {
      device.electron = electron;
      device.macos = macos;
      device.windows = windows;

      if (device.macos) {
        device.os = 'macos';
      }

      if (device.windows) {
        device.os = 'windows';
      }
    } // Pixel Ratio


    device.pixelRatio = win.devicePixelRatio || 1; // Export object

    return device;
  }();

  function onTouchStart(event) {
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params;
    var touches = swiper.touches;

    if (swiper.animating && params.preventInteractionOnTransition) {
      return;
    }

    var e = event;

    if (e.originalEvent) {
      e = e.originalEvent;
    }

    var $targetEl = $(e.target);

    if (params.touchEventsTarget === 'wrapper') {
      if (!$targetEl.closest(swiper.wrapperEl).length) {
        return;
      }
    }

    data.isTouchEvent = e.type === 'touchstart';

    if (!data.isTouchEvent && 'which' in e && e.which === 3) {
      return;
    }

    if (!data.isTouchEvent && 'button' in e && e.button > 0) {
      return;
    }

    if (data.isTouched && data.isMoved) {
      return;
    }

    if (params.noSwiping && $targetEl.closest(params.noSwipingSelector ? params.noSwipingSelector : "." + params.noSwipingClass)[0]) {
      swiper.allowClick = true;
      return;
    }

    if (params.swipeHandler) {
      if (!$targetEl.closest(params.swipeHandler)[0]) {
        return;
      }
    }

    touches.currentX = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
    touches.currentY = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    var startX = touches.currentX;
    var startY = touches.currentY; // Do NOT start if iOS edge swipe is detected. Otherwise iOS app (UIWebView) cannot swipe-to-go-back anymore

    var edgeSwipeDetection = params.edgeSwipeDetection || params.iOSEdgeSwipeDetection;
    var edgeSwipeThreshold = params.edgeSwipeThreshold || params.iOSEdgeSwipeThreshold;

    if (edgeSwipeDetection && (startX <= edgeSwipeThreshold || startX >= win.screen.width - edgeSwipeThreshold)) {
      return;
    }

    Utils.extend(data, {
      isTouched: true,
      isMoved: false,
      allowTouchCallbacks: true,
      isScrolling: undefined,
      startMoving: undefined
    });
    touches.startX = startX;
    touches.startY = startY;
    data.touchStartTime = Utils.now();
    swiper.allowClick = true;
    swiper.updateSize();
    swiper.swipeDirection = undefined;

    if (params.threshold > 0) {
      data.allowThresholdMove = false;
    }

    if (e.type !== 'touchstart') {
      var preventDefault = true;

      if ($targetEl.is(data.formElements)) {
        preventDefault = false;
      }

      if (doc.activeElement && $(doc.activeElement).is(data.formElements) && doc.activeElement !== $targetEl[0]) {
        doc.activeElement.blur();
      }

      var shouldPreventDefault = preventDefault && swiper.allowTouchMove && params.touchStartPreventDefault;

      if (params.touchStartForcePreventDefault || shouldPreventDefault) {
        e.preventDefault();
      }
    }

    swiper.emit('touchStart', e);
  }

  function onTouchMove(event) {
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params;
    var touches = swiper.touches;
    var rtl = swiper.rtlTranslate;
    var e = event;

    if (e.originalEvent) {
      e = e.originalEvent;
    }

    if (!data.isTouched) {
      if (data.startMoving && data.isScrolling) {
        swiper.emit('touchMoveOpposite', e);
      }

      return;
    }

    if (data.isTouchEvent && e.type === 'mousemove') {
      return;
    }

    var targetTouch = e.type === 'touchmove' && e.targetTouches && (e.targetTouches[0] || e.changedTouches[0]);
    var pageX = e.type === 'touchmove' ? targetTouch.pageX : e.pageX;
    var pageY = e.type === 'touchmove' ? targetTouch.pageY : e.pageY;

    if (e.preventedByNestedSwiper) {
      touches.startX = pageX;
      touches.startY = pageY;
      return;
    }

    if (!swiper.allowTouchMove) {
      // isMoved = true;
      swiper.allowClick = false;

      if (data.isTouched) {
        Utils.extend(touches, {
          startX: pageX,
          startY: pageY,
          currentX: pageX,
          currentY: pageY
        });
        data.touchStartTime = Utils.now();
      }

      return;
    }

    if (data.isTouchEvent && params.touchReleaseOnEdges && !params.loop) {
      if (swiper.isVertical()) {
        // Vertical
        if (pageY < touches.startY && swiper.translate <= swiper.maxTranslate() || pageY > touches.startY && swiper.translate >= swiper.minTranslate()) {
          data.isTouched = false;
          data.isMoved = false;
          return;
        }
      } else if (pageX < touches.startX && swiper.translate <= swiper.maxTranslate() || pageX > touches.startX && swiper.translate >= swiper.minTranslate()) {
        return;
      }
    }

    if (data.isTouchEvent && doc.activeElement) {
      if (e.target === doc.activeElement && $(e.target).is(data.formElements)) {
        data.isMoved = true;
        swiper.allowClick = false;
        return;
      }
    }

    if (data.allowTouchCallbacks) {
      swiper.emit('touchMove', e);
    }

    if (e.targetTouches && e.targetTouches.length > 1) {
      return;
    }

    touches.currentX = pageX;
    touches.currentY = pageY;
    var diffX = touches.currentX - touches.startX;
    var diffY = touches.currentY - touches.startY;

    if (swiper.params.threshold && Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2)) < swiper.params.threshold) {
      return;
    }

    if (typeof data.isScrolling === 'undefined') {
      var touchAngle;

      if (swiper.isHorizontal() && touches.currentY === touches.startY || swiper.isVertical() && touches.currentX === touches.startX) {
        data.isScrolling = false;
      } else {
        // eslint-disable-next-line
        if (diffX * diffX + diffY * diffY >= 25) {
          touchAngle = Math.atan2(Math.abs(diffY), Math.abs(diffX)) * 180 / Math.PI;
          data.isScrolling = swiper.isHorizontal() ? touchAngle > params.touchAngle : 90 - touchAngle > params.touchAngle;
        }
      }
    }

    if (data.isScrolling) {
      swiper.emit('touchMoveOpposite', e);
    }

    if (typeof data.startMoving === 'undefined') {
      if (touches.currentX !== touches.startX || touches.currentY !== touches.startY) {
        data.startMoving = true;
      }
    }

    if (data.isScrolling) {
      data.isTouched = false;
      return;
    }

    if (!data.startMoving) {
      return;
    }

    swiper.allowClick = false;

    if (!params.cssMode) {
      e.preventDefault();
    }

    if (params.touchMoveStopPropagation && !params.nested) {
      e.stopPropagation();
    }

    if (!data.isMoved) {
      if (params.loop) {
        swiper.loopFix();
      }

      data.startTranslate = swiper.getTranslate();
      swiper.setTransition(0);

      if (swiper.animating) {
        swiper.$wrapperEl.trigger('webkitTransitionEnd transitionend');
      }

      data.allowMomentumBounce = false; // Grab Cursor

      if (params.grabCursor && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
        swiper.setGrabCursor(true);
      }

      swiper.emit('sliderFirstMove', e);
    }

    swiper.emit('sliderMove', e);
    data.isMoved = true;
    var diff = swiper.isHorizontal() ? diffX : diffY;
    touches.diff = diff;
    diff *= params.touchRatio;

    if (rtl) {
      diff = -diff;
    }

    swiper.swipeDirection = diff > 0 ? 'prev' : 'next';
    data.currentTranslate = diff + data.startTranslate;
    var disableParentSwiper = true;
    var resistanceRatio = params.resistanceRatio;

    if (params.touchReleaseOnEdges) {
      resistanceRatio = 0;
    }

    if (diff > 0 && data.currentTranslate > swiper.minTranslate()) {
      disableParentSwiper = false;

      if (params.resistance) {
        data.currentTranslate = swiper.minTranslate() - 1 + Math.pow(-swiper.minTranslate() + data.startTranslate + diff, resistanceRatio);
      }
    } else if (diff < 0 && data.currentTranslate < swiper.maxTranslate()) {
      disableParentSwiper = false;

      if (params.resistance) {
        data.currentTranslate = swiper.maxTranslate() + 1 - Math.pow(swiper.maxTranslate() - data.startTranslate - diff, resistanceRatio);
      }
    }

    if (disableParentSwiper) {
      e.preventedByNestedSwiper = true;
    } // Directions locks


    if (!swiper.allowSlideNext && swiper.swipeDirection === 'next' && data.currentTranslate < data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    }

    if (!swiper.allowSlidePrev && swiper.swipeDirection === 'prev' && data.currentTranslate > data.startTranslate) {
      data.currentTranslate = data.startTranslate;
    } // Threshold


    if (params.threshold > 0) {
      if (Math.abs(diff) > params.threshold || data.allowThresholdMove) {
        if (!data.allowThresholdMove) {
          data.allowThresholdMove = true;
          touches.startX = touches.currentX;
          touches.startY = touches.currentY;
          data.currentTranslate = data.startTranslate;
          touches.diff = swiper.isHorizontal() ? touches.currentX - touches.startX : touches.currentY - touches.startY;
          return;
        }
      } else {
        data.currentTranslate = data.startTranslate;
        return;
      }
    }

    if (!params.followFinger || params.cssMode) {
      return;
    } // Update active index in free mode


    if (params.freeMode || params.watchSlidesProgress || params.watchSlidesVisibility) {
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    }

    if (params.freeMode) {
      // Velocity
      if (data.velocities.length === 0) {
        data.velocities.push({
          position: touches[swiper.isHorizontal() ? 'startX' : 'startY'],
          time: data.touchStartTime
        });
      }

      data.velocities.push({
        position: touches[swiper.isHorizontal() ? 'currentX' : 'currentY'],
        time: Utils.now()
      });
    } // Update progress


    swiper.updateProgress(data.currentTranslate); // Update translate

    swiper.setTranslate(data.currentTranslate);
  }

  function onTouchEnd(event) {
    var swiper = this;
    var data = swiper.touchEventsData;
    var params = swiper.params;
    var touches = swiper.touches;
    var rtl = swiper.rtlTranslate;
    var $wrapperEl = swiper.$wrapperEl;
    var slidesGrid = swiper.slidesGrid;
    var snapGrid = swiper.snapGrid;
    var e = event;

    if (e.originalEvent) {
      e = e.originalEvent;
    }

    if (data.allowTouchCallbacks) {
      swiper.emit('touchEnd', e);
    }

    data.allowTouchCallbacks = false;

    if (!data.isTouched) {
      if (data.isMoved && params.grabCursor) {
        swiper.setGrabCursor(false);
      }

      data.isMoved = false;
      data.startMoving = false;
      return;
    } // Return Grab Cursor


    if (params.grabCursor && data.isMoved && data.isTouched && (swiper.allowSlideNext === true || swiper.allowSlidePrev === true)) {
      swiper.setGrabCursor(false);
    } // Time diff


    var touchEndTime = Utils.now();
    var timeDiff = touchEndTime - data.touchStartTime; // Tap, doubleTap, Click

    if (swiper.allowClick) {
      swiper.updateClickedSlide(e);
      swiper.emit('tap click', e);

      if (timeDiff < 300 && touchEndTime - data.lastClickTime < 300) {
        swiper.emit('doubleTap doubleClick', e);
      }
    }

    data.lastClickTime = Utils.now();
    Utils.nextTick(function () {
      if (!swiper.destroyed) {
        swiper.allowClick = true;
      }
    });

    if (!data.isTouched || !data.isMoved || !swiper.swipeDirection || touches.diff === 0 || data.currentTranslate === data.startTranslate) {
      data.isTouched = false;
      data.isMoved = false;
      data.startMoving = false;
      return;
    }

    data.isTouched = false;
    data.isMoved = false;
    data.startMoving = false;
    var currentPos;

    if (params.followFinger) {
      currentPos = rtl ? swiper.translate : -swiper.translate;
    } else {
      currentPos = -data.currentTranslate;
    }

    if (params.cssMode) {
      return;
    }

    if (params.freeMode) {
      if (currentPos < -swiper.minTranslate()) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (currentPos > -swiper.maxTranslate()) {
        if (swiper.slides.length < snapGrid.length) {
          swiper.slideTo(snapGrid.length - 1);
        } else {
          swiper.slideTo(swiper.slides.length - 1);
        }

        return;
      }

      if (params.freeModeMomentum) {
        if (data.velocities.length > 1) {
          var lastMoveEvent = data.velocities.pop();
          var velocityEvent = data.velocities.pop();
          var distance = lastMoveEvent.position - velocityEvent.position;
          var time = lastMoveEvent.time - velocityEvent.time;
          swiper.velocity = distance / time;
          swiper.velocity /= 2;

          if (Math.abs(swiper.velocity) < params.freeModeMinimumVelocity) {
            swiper.velocity = 0;
          } // this implies that the user stopped moving a finger then released.
          // There would be no events with distance zero, so the last event is stale.


          if (time > 150 || Utils.now() - lastMoveEvent.time > 300) {
            swiper.velocity = 0;
          }
        } else {
          swiper.velocity = 0;
        }

        swiper.velocity *= params.freeModeMomentumVelocityRatio;
        data.velocities.length = 0;
        var momentumDuration = 1000 * params.freeModeMomentumRatio;
        var momentumDistance = swiper.velocity * momentumDuration;
        var newPosition = swiper.translate + momentumDistance;

        if (rtl) {
          newPosition = -newPosition;
        }

        var doBounce = false;
        var afterBouncePosition;
        var bounceAmount = Math.abs(swiper.velocity) * 20 * params.freeModeMomentumBounceRatio;
        var needsLoopFix;

        if (newPosition < swiper.maxTranslate()) {
          if (params.freeModeMomentumBounce) {
            if (newPosition + swiper.maxTranslate() < -bounceAmount) {
              newPosition = swiper.maxTranslate() - bounceAmount;
            }

            afterBouncePosition = swiper.maxTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.maxTranslate();
          }

          if (params.loop && params.centeredSlides) {
            needsLoopFix = true;
          }
        } else if (newPosition > swiper.minTranslate()) {
          if (params.freeModeMomentumBounce) {
            if (newPosition - swiper.minTranslate() > bounceAmount) {
              newPosition = swiper.minTranslate() + bounceAmount;
            }

            afterBouncePosition = swiper.minTranslate();
            doBounce = true;
            data.allowMomentumBounce = true;
          } else {
            newPosition = swiper.minTranslate();
          }

          if (params.loop && params.centeredSlides) {
            needsLoopFix = true;
          }
        } else if (params.freeModeSticky) {
          var nextSlide;

          for (var j = 0; j < snapGrid.length; j += 1) {
            if (snapGrid[j] > -newPosition) {
              nextSlide = j;
              break;
            }
          }

          if (Math.abs(snapGrid[nextSlide] - newPosition) < Math.abs(snapGrid[nextSlide - 1] - newPosition) || swiper.swipeDirection === 'next') {
            newPosition = snapGrid[nextSlide];
          } else {
            newPosition = snapGrid[nextSlide - 1];
          }

          newPosition = -newPosition;
        }

        if (needsLoopFix) {
          swiper.once('transitionEnd', function () {
            swiper.loopFix();
          });
        } // Fix duration


        if (swiper.velocity !== 0) {
          if (rtl) {
            momentumDuration = Math.abs((-newPosition - swiper.translate) / swiper.velocity);
          } else {
            momentumDuration = Math.abs((newPosition - swiper.translate) / swiper.velocity);
          }

          if (params.freeModeSticky) {
            // If freeModeSticky is active and the user ends a swipe with a slow-velocity
            // event, then durations can be 20+ seconds to slide one (or zero!) slides.
            // It's easy to see this when simulating touch with mouse events. To fix this,
            // limit single-slide swipes to the default slide duration. This also has the
            // nice side effect of matching slide speed if the user stopped moving before
            // lifting finger or mouse vs. moving slowly before lifting the finger/mouse.
            // For faster swipes, also apply limits (albeit higher ones).
            var moveDistance = Math.abs((rtl ? -newPosition : newPosition) - swiper.translate);
            var currentSlideSize = swiper.slidesSizesGrid[swiper.activeIndex];

            if (moveDistance < currentSlideSize) {
              momentumDuration = params.speed;
            } else if (moveDistance < 2 * currentSlideSize) {
              momentumDuration = params.speed * 1.5;
            } else {
              momentumDuration = params.speed * 2.5;
            }
          }
        } else if (params.freeModeSticky) {
          swiper.slideToClosest();
          return;
        }

        if (params.freeModeMomentumBounce && doBounce) {
          swiper.updateProgress(afterBouncePosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);
          swiper.animating = true;
          $wrapperEl.transitionEnd(function () {
            if (!swiper || swiper.destroyed || !data.allowMomentumBounce) {
              return;
            }

            swiper.emit('momentumBounce');
            swiper.setTransition(params.speed);
            swiper.setTranslate(afterBouncePosition);
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) {
                return;
              }

              swiper.transitionEnd();
            });
          });
        } else if (swiper.velocity) {
          swiper.updateProgress(newPosition);
          swiper.setTransition(momentumDuration);
          swiper.setTranslate(newPosition);
          swiper.transitionStart(true, swiper.swipeDirection);

          if (!swiper.animating) {
            swiper.animating = true;
            $wrapperEl.transitionEnd(function () {
              if (!swiper || swiper.destroyed) {
                return;
              }

              swiper.transitionEnd();
            });
          }
        } else {
          swiper.updateProgress(newPosition);
        }

        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      } else if (params.freeModeSticky) {
        swiper.slideToClosest();
        return;
      }

      if (!params.freeModeMomentum || timeDiff >= params.longSwipesMs) {
        swiper.updateProgress();
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      return;
    } // Find current slide


    var stopIndex = 0;
    var groupSize = swiper.slidesSizesGrid[0];

    for (var i = 0; i < slidesGrid.length; i += i < params.slidesPerGroupSkip ? 1 : params.slidesPerGroup) {
      var increment$1 = i < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

      if (typeof slidesGrid[i + increment$1] !== 'undefined') {
        if (currentPos >= slidesGrid[i] && currentPos < slidesGrid[i + increment$1]) {
          stopIndex = i;
          groupSize = slidesGrid[i + increment$1] - slidesGrid[i];
        }
      } else if (currentPos >= slidesGrid[i]) {
        stopIndex = i;
        groupSize = slidesGrid[slidesGrid.length - 1] - slidesGrid[slidesGrid.length - 2];
      }
    } // Find current slide size


    var ratio = (currentPos - slidesGrid[stopIndex]) / groupSize;
    var increment = stopIndex < params.slidesPerGroupSkip - 1 ? 1 : params.slidesPerGroup;

    if (timeDiff > params.longSwipesMs) {
      // Long touches
      if (!params.longSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      if (swiper.swipeDirection === 'next') {
        if (ratio >= params.longSwipesRatio) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }

      if (swiper.swipeDirection === 'prev') {
        if (ratio > 1 - params.longSwipesRatio) {
          swiper.slideTo(stopIndex + increment);
        } else {
          swiper.slideTo(stopIndex);
        }
      }
    } else {
      // Short swipes
      if (!params.shortSwipes) {
        swiper.slideTo(swiper.activeIndex);
        return;
      }

      var isNavButtonTarget = swiper.navigation && (e.target === swiper.navigation.nextEl || e.target === swiper.navigation.prevEl);

      if (!isNavButtonTarget) {
        if (swiper.swipeDirection === 'next') {
          swiper.slideTo(stopIndex + increment);
        }

        if (swiper.swipeDirection === 'prev') {
          swiper.slideTo(stopIndex);
        }
      } else if (e.target === swiper.navigation.nextEl) {
        swiper.slideTo(stopIndex + increment);
      } else {
        swiper.slideTo(stopIndex);
      }
    }
  }

  function onResize() {
    var swiper = this;
    var params = swiper.params;
    var el = swiper.el;

    if (el && el.offsetWidth === 0) {
      return;
    } // Breakpoints


    if (params.breakpoints) {
      swiper.setBreakpoint();
    } // Save locks


    var allowSlideNext = swiper.allowSlideNext;
    var allowSlidePrev = swiper.allowSlidePrev;
    var snapGrid = swiper.snapGrid; // Disable locks on resize

    swiper.allowSlideNext = true;
    swiper.allowSlidePrev = true;
    swiper.updateSize();
    swiper.updateSlides();
    swiper.updateSlidesClasses();

    if ((params.slidesPerView === 'auto' || params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
      swiper.slideTo(swiper.slides.length - 1, 0, false, true);
    } else {
      swiper.slideTo(swiper.activeIndex, 0, false, true);
    }

    if (swiper.autoplay && swiper.autoplay.running && swiper.autoplay.paused) {
      swiper.autoplay.run();
    } // Return locks after resize


    swiper.allowSlidePrev = allowSlidePrev;
    swiper.allowSlideNext = allowSlideNext;

    if (swiper.params.watchOverflow && snapGrid !== swiper.snapGrid) {
      swiper.checkOverflow();
    }
  }

  function onClick(e) {
    var swiper = this;

    if (!swiper.allowClick) {
      if (swiper.params.preventClicks) {
        e.preventDefault();
      }

      if (swiper.params.preventClicksPropagation && swiper.animating) {
        e.stopPropagation();
        e.stopImmediatePropagation();
      }
    }
  }

  function onScroll() {
    var swiper = this;
    var wrapperEl = swiper.wrapperEl;
    var rtlTranslate = swiper.rtlTranslate;
    swiper.previousTranslate = swiper.translate;

    if (swiper.isHorizontal()) {
      if (rtlTranslate) {
        swiper.translate = wrapperEl.scrollWidth - wrapperEl.offsetWidth - wrapperEl.scrollLeft;
      } else {
        swiper.translate = -wrapperEl.scrollLeft;
      }
    } else {
      swiper.translate = -wrapperEl.scrollTop;
    } // eslint-disable-next-line


    if (swiper.translate === -0) {
      swiper.translate = 0;
    }

    swiper.updateActiveIndex();
    swiper.updateSlidesClasses();
    var newProgress;
    var translatesDiff = swiper.maxTranslate() - swiper.minTranslate();

    if (translatesDiff === 0) {
      newProgress = 0;
    } else {
      newProgress = (swiper.translate - swiper.minTranslate()) / translatesDiff;
    }

    if (newProgress !== swiper.progress) {
      swiper.updateProgress(rtlTranslate ? -swiper.translate : swiper.translate);
    }

    swiper.emit('setTranslate', swiper.translate, false);
  }

  var dummyEventAttached = false;

  function dummyEventListener() {}

  function attachEvents() {
    var swiper = this;
    var params = swiper.params;
    var touchEvents = swiper.touchEvents;
    var el = swiper.el;
    var wrapperEl = swiper.wrapperEl;
    swiper.onTouchStart = onTouchStart.bind(swiper);
    swiper.onTouchMove = onTouchMove.bind(swiper);
    swiper.onTouchEnd = onTouchEnd.bind(swiper);

    if (params.cssMode) {
      swiper.onScroll = onScroll.bind(swiper);
    }

    swiper.onClick = onClick.bind(swiper);
    var capture = !!params.nested; // Touch Events

    if (!Support.touch && Support.pointerEvents) {
      el.addEventListener(touchEvents.start, swiper.onTouchStart, false);
      doc.addEventListener(touchEvents.move, swiper.onTouchMove, capture);
      doc.addEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        var passiveListener = touchEvents.start === 'touchstart' && Support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el.addEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        el.addEventListener(touchEvents.move, swiper.onTouchMove, Support.passiveListener ? {
          passive: false,
          capture: capture
        } : capture);
        el.addEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

        if (touchEvents.cancel) {
          el.addEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }

        if (!dummyEventAttached) {
          doc.addEventListener('touchstart', dummyEventListener);
          dummyEventAttached = true;
        }
      }

      if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
        el.addEventListener('mousedown', swiper.onTouchStart, false);
        doc.addEventListener('mousemove', swiper.onTouchMove, capture);
        doc.addEventListener('mouseup', swiper.onTouchEnd, false);
      }
    } // Prevent Links Clicks


    if (params.preventClicks || params.preventClicksPropagation) {
      el.addEventListener('click', swiper.onClick, true);
    }

    if (params.cssMode) {
      wrapperEl.addEventListener('scroll', swiper.onScroll);
    } // Resize handler


    if (params.updateOnWindowResize) {
      swiper.on(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize, true);
    } else {
      swiper.on('observerUpdate', onResize, true);
    }
  }

  function detachEvents() {
    var swiper = this;
    var params = swiper.params;
    var touchEvents = swiper.touchEvents;
    var el = swiper.el;
    var wrapperEl = swiper.wrapperEl;
    var capture = !!params.nested; // Touch Events

    if (!Support.touch && Support.pointerEvents) {
      el.removeEventListener(touchEvents.start, swiper.onTouchStart, false);
      doc.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
      doc.removeEventListener(touchEvents.end, swiper.onTouchEnd, false);
    } else {
      if (Support.touch) {
        var passiveListener = touchEvents.start === 'onTouchStart' && Support.passiveListener && params.passiveListeners ? {
          passive: true,
          capture: false
        } : false;
        el.removeEventListener(touchEvents.start, swiper.onTouchStart, passiveListener);
        el.removeEventListener(touchEvents.move, swiper.onTouchMove, capture);
        el.removeEventListener(touchEvents.end, swiper.onTouchEnd, passiveListener);

        if (touchEvents.cancel) {
          el.removeEventListener(touchEvents.cancel, swiper.onTouchEnd, passiveListener);
        }
      }

      if (params.simulateTouch && !Device.ios && !Device.android || params.simulateTouch && !Support.touch && Device.ios) {
        el.removeEventListener('mousedown', swiper.onTouchStart, false);
        doc.removeEventListener('mousemove', swiper.onTouchMove, capture);
        doc.removeEventListener('mouseup', swiper.onTouchEnd, false);
      }
    } // Prevent Links Clicks


    if (params.preventClicks || params.preventClicksPropagation) {
      el.removeEventListener('click', swiper.onClick, true);
    }

    if (params.cssMode) {
      wrapperEl.removeEventListener('scroll', swiper.onScroll);
    } // Resize handler


    swiper.off(Device.ios || Device.android ? 'resize orientationchange observerUpdate' : 'resize observerUpdate', onResize);
  }

  var events = {
    attachEvents: attachEvents,
    detachEvents: detachEvents
  };

  function setBreakpoint() {
    var swiper = this;
    var activeIndex = swiper.activeIndex;
    var initialized = swiper.initialized;
    var loopedSlides = swiper.loopedSlides;
    if (loopedSlides === void 0) loopedSlides = 0;
    var params = swiper.params;
    var $el = swiper.$el;
    var breakpoints = params.breakpoints;

    if (!breakpoints || breakpoints && Object.keys(breakpoints).length === 0) {
      return;
    } // Get breakpoint for window width and update parameters


    var breakpoint = swiper.getBreakpoint(breakpoints);

    if (breakpoint && swiper.currentBreakpoint !== breakpoint) {
      var breakpointOnlyParams = breakpoint in breakpoints ? breakpoints[breakpoint] : undefined;

      if (breakpointOnlyParams) {
        ['slidesPerView', 'spaceBetween', 'slidesPerGroup', 'slidesPerGroupSkip', 'slidesPerColumn'].forEach(function (param) {
          var paramValue = breakpointOnlyParams[param];

          if (typeof paramValue === 'undefined') {
            return;
          }

          if (param === 'slidesPerView' && (paramValue === 'AUTO' || paramValue === 'auto')) {
            breakpointOnlyParams[param] = 'auto';
          } else if (param === 'slidesPerView') {
            breakpointOnlyParams[param] = parseFloat(paramValue);
          } else {
            breakpointOnlyParams[param] = parseInt(paramValue, 10);
          }
        });
      }

      var breakpointParams = breakpointOnlyParams || swiper.originalParams;
      var wasMultiRow = params.slidesPerColumn > 1;
      var isMultiRow = breakpointParams.slidesPerColumn > 1;

      if (wasMultiRow && !isMultiRow) {
        $el.removeClass(params.containerModifierClass + "multirow " + params.containerModifierClass + "multirow-column");
      } else if (!wasMultiRow && isMultiRow) {
        $el.addClass(params.containerModifierClass + "multirow");

        if (breakpointParams.slidesPerColumnFill === 'column') {
          $el.addClass(params.containerModifierClass + "multirow-column");
        }
      }

      var directionChanged = breakpointParams.direction && breakpointParams.direction !== params.direction;
      var needsReLoop = params.loop && (breakpointParams.slidesPerView !== params.slidesPerView || directionChanged);

      if (directionChanged && initialized) {
        swiper.changeDirection();
      }

      Utils.extend(swiper.params, breakpointParams);
      Utils.extend(swiper, {
        allowTouchMove: swiper.params.allowTouchMove,
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev
      });
      swiper.currentBreakpoint = breakpoint;

      if (needsReLoop && initialized) {
        swiper.loopDestroy();
        swiper.loopCreate();
        swiper.updateSlides();
        swiper.slideTo(activeIndex - loopedSlides + swiper.loopedSlides, 0, false);
      }

      swiper.emit('breakpoint', breakpointParams);
    }
  }

  function getBreakpoint(breakpoints) {
    // Get breakpoint for window width
    if (!breakpoints) {
      return undefined;
    }

    var breakpoint = false;
    var points = Object.keys(breakpoints).map(function (point) {
      if (typeof point === 'string' && point.indexOf('@') === 0) {
        var minRatio = parseFloat(point.substr(1));
        var value = win.innerHeight * minRatio;
        return {
          value: value,
          point: point
        };
      }

      return {
        value: point,
        point: point
      };
    });
    points.sort(function (a, b) {
      return parseInt(a.value, 10) - parseInt(b.value, 10);
    });

    for (var i = 0; i < points.length; i += 1) {
      var ref = points[i];
      var point = ref.point;
      var value = ref.value;

      if (value <= win.innerWidth) {
        breakpoint = point;
      }
    }

    return breakpoint || 'max';
  }

  var breakpoints = {
    setBreakpoint: setBreakpoint,
    getBreakpoint: getBreakpoint
  };

  function addClasses() {
    var swiper = this;
    var classNames = swiper.classNames;
    var params = swiper.params;
    var rtl = swiper.rtl;
    var $el = swiper.$el;
    var suffixes = [];
    suffixes.push('initialized');
    suffixes.push(params.direction);

    if (params.freeMode) {
      suffixes.push('free-mode');
    }

    if (params.autoHeight) {
      suffixes.push('autoheight');
    }

    if (rtl) {
      suffixes.push('rtl');
    }

    if (params.slidesPerColumn > 1) {
      suffixes.push('multirow');

      if (params.slidesPerColumnFill === 'column') {
        suffixes.push('multirow-column');
      }
    }

    if (Device.android) {
      suffixes.push('android');
    }

    if (Device.ios) {
      suffixes.push('ios');
    }

    if (params.cssMode) {
      suffixes.push('css-mode');
    }

    suffixes.forEach(function (suffix) {
      classNames.push(params.containerModifierClass + suffix);
    });
    $el.addClass(classNames.join(' '));
  }

  function removeClasses() {
    var swiper = this;
    var $el = swiper.$el;
    var classNames = swiper.classNames;
    $el.removeClass(classNames.join(' '));
  }

  var classes = {
    addClasses: addClasses,
    removeClasses: removeClasses
  };

  function loadImage(imageEl, src, srcset, sizes, checkForComplete, callback) {
    var image;

    function onReady() {
      if (callback) {
        callback();
      }
    }

    if (!imageEl.complete || !checkForComplete) {
      if (src) {
        image = new win.Image();
        image.onload = onReady;
        image.onerror = onReady;

        if (sizes) {
          image.sizes = sizes;
        }

        if (srcset) {
          image.srcset = srcset;
        }

        if (src) {
          image.src = src;
        }
      } else {
        onReady();
      }
    } else {
      // image already loaded...
      onReady();
    }
  }

  function preloadImages() {
    var swiper = this;
    swiper.imagesToLoad = swiper.$el.find('img');

    function onReady() {
      if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper.destroyed) {
        return;
      }

      if (swiper.imagesLoaded !== undefined) {
        swiper.imagesLoaded += 1;
      }

      if (swiper.imagesLoaded === swiper.imagesToLoad.length) {
        if (swiper.params.updateOnImagesReady) {
          swiper.update();
        }

        swiper.emit('imagesReady');
      }
    }

    for (var i = 0; i < swiper.imagesToLoad.length; i += 1) {
      var imageEl = swiper.imagesToLoad[i];
      swiper.loadImage(imageEl, imageEl.currentSrc || imageEl.getAttribute('src'), imageEl.srcset || imageEl.getAttribute('srcset'), imageEl.sizes || imageEl.getAttribute('sizes'), true, onReady);
    }
  }

  var images = {
    loadImage: loadImage,
    preloadImages: preloadImages
  };

  function checkOverflow() {
    var swiper = this;
    var params = swiper.params;
    var wasLocked = swiper.isLocked;
    var lastSlidePosition = swiper.slides.length > 0 && params.slidesOffsetBefore + params.spaceBetween * (swiper.slides.length - 1) + swiper.slides[0].offsetWidth * swiper.slides.length;

    if (params.slidesOffsetBefore && params.slidesOffsetAfter && lastSlidePosition) {
      swiper.isLocked = lastSlidePosition <= swiper.size;
    } else {
      swiper.isLocked = swiper.snapGrid.length === 1;
    }

    swiper.allowSlideNext = !swiper.isLocked;
    swiper.allowSlidePrev = !swiper.isLocked; // events

    if (wasLocked !== swiper.isLocked) {
      swiper.emit(swiper.isLocked ? 'lock' : 'unlock');
    }

    if (wasLocked && wasLocked !== swiper.isLocked) {
      swiper.isEnd = false;
      swiper.navigation.update();
    }
  }

  var checkOverflow$1 = {
    checkOverflow: checkOverflow
  };
  var defaults = {
    init: true,
    direction: 'horizontal',
    touchEventsTarget: 'container',
    initialSlide: 0,
    speed: 300,
    cssMode: false,
    updateOnWindowResize: true,
    //
    preventInteractionOnTransition: false,
    // To support iOS's swipe-to-go-back gesture (when being used in-app, with UIWebView).
    edgeSwipeDetection: false,
    edgeSwipeThreshold: 20,
    // Free mode
    freeMode: false,
    freeModeMomentum: true,
    freeModeMomentumRatio: 1,
    freeModeMomentumBounce: true,
    freeModeMomentumBounceRatio: 1,
    freeModeMomentumVelocityRatio: 1,
    freeModeSticky: false,
    freeModeMinimumVelocity: 0.02,
    // Autoheight
    autoHeight: false,
    // Set wrapper width
    setWrapperSize: false,
    // Virtual Translate
    virtualTranslate: false,
    // Effects
    effect: 'slide',
    // 'slide' or 'fade' or 'cube' or 'coverflow' or 'flip'
    // Breakpoints
    breakpoints: undefined,
    // Slides grid
    spaceBetween: 0,
    slidesPerView: 1,
    slidesPerColumn: 1,
    slidesPerColumnFill: 'column',
    slidesPerGroup: 1,
    slidesPerGroupSkip: 0,
    centeredSlides: false,
    centeredSlidesBounds: false,
    slidesOffsetBefore: 0,
    // in px
    slidesOffsetAfter: 0,
    // in px
    normalizeSlideIndex: true,
    centerInsufficientSlides: false,
    // Disable swiper and hide navigation when container not overflow
    watchOverflow: false,
    // Round length
    roundLengths: false,
    // Touches
    touchRatio: 1,
    touchAngle: 45,
    simulateTouch: true,
    shortSwipes: true,
    longSwipes: true,
    longSwipesRatio: 0.5,
    longSwipesMs: 300,
    followFinger: true,
    allowTouchMove: true,
    threshold: 0,
    touchMoveStopPropagation: false,
    touchStartPreventDefault: true,
    touchStartForcePreventDefault: false,
    touchReleaseOnEdges: false,
    // Unique Navigation Elements
    uniqueNavElements: true,
    // Resistance
    resistance: true,
    resistanceRatio: 0.85,
    // Progress
    watchSlidesProgress: false,
    watchSlidesVisibility: false,
    // Cursor
    grabCursor: false,
    // Clicks
    preventClicks: true,
    preventClicksPropagation: true,
    slideToClickedSlide: false,
    // Images
    preloadImages: true,
    updateOnImagesReady: true,
    // loop
    loop: false,
    loopAdditionalSlides: 0,
    loopedSlides: null,
    loopFillGroupWithBlank: false,
    // Swiping/no swiping
    allowSlidePrev: true,
    allowSlideNext: true,
    swipeHandler: null,
    // '.swipe-handler',
    noSwiping: true,
    noSwipingClass: 'swiper-no-swiping',
    noSwipingSelector: null,
    // Passive Listeners
    passiveListeners: true,
    // NS
    containerModifierClass: 'swiper-container-',
    // NEW
    slideClass: 'swiper-slide',
    slideBlankClass: 'swiper-slide-invisible-blank',
    slideActiveClass: 'swiper-slide-active',
    slideDuplicateActiveClass: 'swiper-slide-duplicate-active',
    slideVisibleClass: 'swiper-slide-visible',
    slideDuplicateClass: 'swiper-slide-duplicate',
    slideNextClass: 'swiper-slide-next',
    slideDuplicateNextClass: 'swiper-slide-duplicate-next',
    slidePrevClass: 'swiper-slide-prev',
    slideDuplicatePrevClass: 'swiper-slide-duplicate-prev',
    wrapperClass: 'swiper-wrapper',
    // Callbacks
    runCallbacksOnInit: true
  };
  /* eslint no-param-reassign: "off" */

  var prototypes = {
    update: update,
    translate: translate,
    transition: transition$1,
    slide: slide,
    loop: loop,
    grabCursor: grabCursor,
    manipulation: manipulation,
    events: events,
    breakpoints: breakpoints,
    checkOverflow: checkOverflow$1,
    classes: classes,
    images: images
  };
  var extendedDefaults = {};

  var Swiper = /*@__PURE__*/function (SwiperClass) {
    function Swiper() {
      var assign;
      var args = [],
          len = arguments.length;

      while (len--) args[len] = arguments[len];

      var el;
      var params;

      if (args.length === 1 && args[0].constructor && args[0].constructor === Object) {
        params = args[0];
      } else {
        assign = args, el = assign[0], params = assign[1];
      }

      if (!params) {
        params = {};
      }

      params = Utils.extend({}, params);

      if (el && !params.el) {
        params.el = el;
      }

      SwiperClass.call(this, params);
      Object.keys(prototypes).forEach(function (prototypeGroup) {
        Object.keys(prototypes[prototypeGroup]).forEach(function (protoMethod) {
          if (!Swiper.prototype[protoMethod]) {
            Swiper.prototype[protoMethod] = prototypes[prototypeGroup][protoMethod];
          }
        });
      }); // Swiper Instance

      var swiper = this;

      if (typeof swiper.modules === 'undefined') {
        swiper.modules = {};
      }

      Object.keys(swiper.modules).forEach(function (moduleName) {
        var module = swiper.modules[moduleName];

        if (module.params) {
          var moduleParamName = Object.keys(module.params)[0];
          var moduleParams = module.params[moduleParamName];

          if (typeof moduleParams !== 'object' || moduleParams === null) {
            return;
          }

          if (!(moduleParamName in params && 'enabled' in moduleParams)) {
            return;
          }

          if (params[moduleParamName] === true) {
            params[moduleParamName] = {
              enabled: true
            };
          }

          if (typeof params[moduleParamName] === 'object' && !('enabled' in params[moduleParamName])) {
            params[moduleParamName].enabled = true;
          }

          if (!params[moduleParamName]) {
            params[moduleParamName] = {
              enabled: false
            };
          }
        }
      }); // Extend defaults with modules params

      var swiperParams = Utils.extend({}, defaults);
      swiper.useModulesParams(swiperParams); // Extend defaults with passed params

      swiper.params = Utils.extend({}, swiperParams, extendedDefaults, params);
      swiper.originalParams = Utils.extend({}, swiper.params);
      swiper.passedParams = Utils.extend({}, params); // Save Dom lib

      swiper.$ = $; // Find el

      var $el = $(swiper.params.el);
      el = $el[0];

      if (!el) {
        return undefined;
      }

      if ($el.length > 1) {
        var swipers = [];
        $el.each(function (index, containerEl) {
          var newParams = Utils.extend({}, params, {
            el: containerEl
          });
          swipers.push(new Swiper(newParams));
        });
        return swipers;
      }

      el.swiper = swiper;
      $el.data('swiper', swiper); // Find Wrapper

      var $wrapperEl;

      if (el && el.shadowRoot && el.shadowRoot.querySelector) {
        $wrapperEl = $(el.shadowRoot.querySelector("." + swiper.params.wrapperClass)); // Children needs to return slot items

        $wrapperEl.children = function (options) {
          return $el.children(options);
        };
      } else {
        $wrapperEl = $el.children("." + swiper.params.wrapperClass);
      } // Extend Swiper


      Utils.extend(swiper, {
        $el: $el,
        el: el,
        $wrapperEl: $wrapperEl,
        wrapperEl: $wrapperEl[0],
        // Classes
        classNames: [],
        // Slides
        slides: $(),
        slidesGrid: [],
        snapGrid: [],
        slidesSizesGrid: [],
        // isDirection
        isHorizontal: function isHorizontal() {
          return swiper.params.direction === 'horizontal';
        },
        isVertical: function isVertical() {
          return swiper.params.direction === 'vertical';
        },
        // RTL
        rtl: el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl',
        rtlTranslate: swiper.params.direction === 'horizontal' && (el.dir.toLowerCase() === 'rtl' || $el.css('direction') === 'rtl'),
        wrongRTL: $wrapperEl.css('display') === '-webkit-box',
        // Indexes
        activeIndex: 0,
        realIndex: 0,
        //
        isBeginning: true,
        isEnd: false,
        // Props
        translate: 0,
        previousTranslate: 0,
        progress: 0,
        velocity: 0,
        animating: false,
        // Locks
        allowSlideNext: swiper.params.allowSlideNext,
        allowSlidePrev: swiper.params.allowSlidePrev,
        // Touch Events
        touchEvents: function touchEvents() {
          var touch = ['touchstart', 'touchmove', 'touchend', 'touchcancel'];
          var desktop = ['mousedown', 'mousemove', 'mouseup'];

          if (Support.pointerEvents) {
            desktop = ['pointerdown', 'pointermove', 'pointerup'];
          }

          swiper.touchEventsTouch = {
            start: touch[0],
            move: touch[1],
            end: touch[2],
            cancel: touch[3]
          };
          swiper.touchEventsDesktop = {
            start: desktop[0],
            move: desktop[1],
            end: desktop[2]
          };
          return Support.touch || !swiper.params.simulateTouch ? swiper.touchEventsTouch : swiper.touchEventsDesktop;
        }(),
        touchEventsData: {
          isTouched: undefined,
          isMoved: undefined,
          allowTouchCallbacks: undefined,
          touchStartTime: undefined,
          isScrolling: undefined,
          currentTranslate: undefined,
          startTranslate: undefined,
          allowThresholdMove: undefined,
          // Form elements to match
          formElements: 'input, select, option, textarea, button, video, label',
          // Last click time
          lastClickTime: Utils.now(),
          clickTimeout: undefined,
          // Velocities
          velocities: [],
          allowMomentumBounce: undefined,
          isTouchEvent: undefined,
          startMoving: undefined
        },
        // Clicks
        allowClick: true,
        // Touches
        allowTouchMove: swiper.params.allowTouchMove,
        touches: {
          startX: 0,
          startY: 0,
          currentX: 0,
          currentY: 0,
          diff: 0
        },
        // Images
        imagesToLoad: [],
        imagesLoaded: 0
      }); // Install Modules

      swiper.useModules(); // Init

      if (swiper.params.init) {
        swiper.init();
      } // Return app instance


      return swiper;
    }

    if (SwiperClass) Swiper.__proto__ = SwiperClass;
    Swiper.prototype = Object.create(SwiperClass && SwiperClass.prototype);
    Swiper.prototype.constructor = Swiper;
    var staticAccessors = {
      extendedDefaults: {
        configurable: true
      },
      defaults: {
        configurable: true
      },
      Class: {
        configurable: true
      },
      $: {
        configurable: true
      }
    };

    Swiper.prototype.slidesPerViewDynamic = function slidesPerViewDynamic() {
      var swiper = this;
      var params = swiper.params;
      var slides = swiper.slides;
      var slidesGrid = swiper.slidesGrid;
      var swiperSize = swiper.size;
      var activeIndex = swiper.activeIndex;
      var spv = 1;

      if (params.centeredSlides) {
        var slideSize = slides[activeIndex].swiperSlideSize;
        var breakLoop;

        for (var i = activeIndex + 1; i < slides.length; i += 1) {
          if (slides[i] && !breakLoop) {
            slideSize += slides[i].swiperSlideSize;
            spv += 1;

            if (slideSize > swiperSize) {
              breakLoop = true;
            }
          }
        }

        for (var i$1 = activeIndex - 1; i$1 >= 0; i$1 -= 1) {
          if (slides[i$1] && !breakLoop) {
            slideSize += slides[i$1].swiperSlideSize;
            spv += 1;

            if (slideSize > swiperSize) {
              breakLoop = true;
            }
          }
        }
      } else {
        for (var i$2 = activeIndex + 1; i$2 < slides.length; i$2 += 1) {
          if (slidesGrid[i$2] - slidesGrid[activeIndex] < swiperSize) {
            spv += 1;
          }
        }
      }

      return spv;
    };

    Swiper.prototype.update = function update() {
      var swiper = this;

      if (!swiper || swiper.destroyed) {
        return;
      }

      var snapGrid = swiper.snapGrid;
      var params = swiper.params; // Breakpoints

      if (params.breakpoints) {
        swiper.setBreakpoint();
      }

      swiper.updateSize();
      swiper.updateSlides();
      swiper.updateProgress();
      swiper.updateSlidesClasses();

      function setTranslate() {
        var translateValue = swiper.rtlTranslate ? swiper.translate * -1 : swiper.translate;
        var newTranslate = Math.min(Math.max(translateValue, swiper.maxTranslate()), swiper.minTranslate());
        swiper.setTranslate(newTranslate);
        swiper.updateActiveIndex();
        swiper.updateSlidesClasses();
      }

      var translated;

      if (swiper.params.freeMode) {
        setTranslate();

        if (swiper.params.autoHeight) {
          swiper.updateAutoHeight();
        }
      } else {
        if ((swiper.params.slidesPerView === 'auto' || swiper.params.slidesPerView > 1) && swiper.isEnd && !swiper.params.centeredSlides) {
          translated = swiper.slideTo(swiper.slides.length - 1, 0, false, true);
        } else {
          translated = swiper.slideTo(swiper.activeIndex, 0, false, true);
        }

        if (!translated) {
          setTranslate();
        }
      }

      if (params.watchOverflow && snapGrid !== swiper.snapGrid) {
        swiper.checkOverflow();
      }

      swiper.emit('update');
    };

    Swiper.prototype.changeDirection = function changeDirection(newDirection, needUpdate) {
      if (needUpdate === void 0) needUpdate = true;
      var swiper = this;
      var currentDirection = swiper.params.direction;

      if (!newDirection) {
        // eslint-disable-next-line
        newDirection = currentDirection === 'horizontal' ? 'vertical' : 'horizontal';
      }

      if (newDirection === currentDirection || newDirection !== 'horizontal' && newDirection !== 'vertical') {
        return swiper;
      }

      swiper.$el.removeClass("" + swiper.params.containerModifierClass + currentDirection).addClass("" + swiper.params.containerModifierClass + newDirection);
      swiper.params.direction = newDirection;
      swiper.slides.each(function (slideIndex, slideEl) {
        if (newDirection === 'vertical') {
          slideEl.style.width = '';
        } else {
          slideEl.style.height = '';
        }
      });
      swiper.emit('changeDirection');

      if (needUpdate) {
        swiper.update();
      }

      return swiper;
    };

    Swiper.prototype.init = function init() {
      var swiper = this;

      if (swiper.initialized) {
        return;
      }

      swiper.emit('beforeInit'); // Set breakpoint

      if (swiper.params.breakpoints) {
        swiper.setBreakpoint();
      } // Add Classes


      swiper.addClasses(); // Create loop

      if (swiper.params.loop) {
        swiper.loopCreate();
      } // Update size


      swiper.updateSize(); // Update slides

      swiper.updateSlides();

      if (swiper.params.watchOverflow) {
        swiper.checkOverflow();
      } // Set Grab Cursor


      if (swiper.params.grabCursor) {
        swiper.setGrabCursor();
      }

      if (swiper.params.preloadImages) {
        swiper.preloadImages();
      } // Slide To Initial Slide


      if (swiper.params.loop) {
        swiper.slideTo(swiper.params.initialSlide + swiper.loopedSlides, 0, swiper.params.runCallbacksOnInit);
      } else {
        swiper.slideTo(swiper.params.initialSlide, 0, swiper.params.runCallbacksOnInit);
      } // Attach events


      swiper.attachEvents(); // Init Flag

      swiper.initialized = true; // Emit

      swiper.emit('init');
    };

    Swiper.prototype.destroy = function destroy(deleteInstance, cleanStyles) {
      if (deleteInstance === void 0) deleteInstance = true;
      if (cleanStyles === void 0) cleanStyles = true;
      var swiper = this;
      var params = swiper.params;
      var $el = swiper.$el;
      var $wrapperEl = swiper.$wrapperEl;
      var slides = swiper.slides;

      if (typeof swiper.params === 'undefined' || swiper.destroyed) {
        return null;
      }

      swiper.emit('beforeDestroy'); // Init Flag

      swiper.initialized = false; // Detach events

      swiper.detachEvents(); // Destroy loop

      if (params.loop) {
        swiper.loopDestroy();
      } // Cleanup styles


      if (cleanStyles) {
        swiper.removeClasses();
        $el.removeAttr('style');
        $wrapperEl.removeAttr('style');

        if (slides && slides.length) {
          slides.removeClass([params.slideVisibleClass, params.slideActiveClass, params.slideNextClass, params.slidePrevClass].join(' ')).removeAttr('style').removeAttr('data-swiper-slide-index');
        }
      }

      swiper.emit('destroy'); // Detach emitter events

      Object.keys(swiper.eventsListeners).forEach(function (eventName) {
        swiper.off(eventName);
      });

      if (deleteInstance !== false) {
        swiper.$el[0].swiper = null;
        swiper.$el.data('swiper', null);
        Utils.deleteProps(swiper);
      }

      swiper.destroyed = true;
      return null;
    };

    Swiper.extendDefaults = function extendDefaults(newDefaults) {
      Utils.extend(extendedDefaults, newDefaults);
    };

    staticAccessors.extendedDefaults.get = function () {
      return extendedDefaults;
    };

    staticAccessors.defaults.get = function () {
      return defaults;
    };

    staticAccessors.Class.get = function () {
      return SwiperClass;
    };

    staticAccessors.$.get = function () {
      return $;
    };

    Object.defineProperties(Swiper, staticAccessors);
    return Swiper;
  }(SwiperClass);

  var Device$1 = {
    name: 'device',
    proto: {
      device: Device
    },
    static: {
      device: Device
    }
  };
  var Support$1 = {
    name: 'support',
    proto: {
      support: Support
    },
    static: {
      support: Support
    }
  };

  var Browser = function Browser() {
    function isSafari() {
      var ua = win.navigator.userAgent.toLowerCase();
      return ua.indexOf('safari') >= 0 && ua.indexOf('chrome') < 0 && ua.indexOf('android') < 0;
    }

    return {
      isEdge: !!win.navigator.userAgent.match(/Edge/g),
      isSafari: isSafari(),
      isUiWebView: /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i.test(win.navigator.userAgent)
    };
  }();

  var Browser$1 = {
    name: 'browser',
    proto: {
      browser: Browser
    },
    static: {
      browser: Browser
    }
  };
  var Resize = {
    name: 'resize',
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        resize: {
          resizeHandler: function resizeHandler() {
            if (!swiper || swiper.destroyed || !swiper.initialized) {
              return;
            }

            swiper.emit('beforeResize');
            swiper.emit('resize');
          },
          orientationChangeHandler: function orientationChangeHandler() {
            if (!swiper || swiper.destroyed || !swiper.initialized) {
              return;
            }

            swiper.emit('orientationchange');
          }
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this; // Emit resize

        win.addEventListener('resize', swiper.resize.resizeHandler); // Emit orientationchange

        win.addEventListener('orientationchange', swiper.resize.orientationChangeHandler);
      },
      destroy: function destroy() {
        var swiper = this;
        win.removeEventListener('resize', swiper.resize.resizeHandler);
        win.removeEventListener('orientationchange', swiper.resize.orientationChangeHandler);
      }
    }
  };
  var Observer = {
    func: win.MutationObserver || win.WebkitMutationObserver,
    attach: function attach(target, options) {
      if (options === void 0) options = {};
      var swiper = this;
      var ObserverFunc = Observer.func;
      var observer = new ObserverFunc(function (mutations) {
        // The observerUpdate event should only be triggered
        // once despite the number of mutations.  Additional
        // triggers are redundant and are very costly
        if (mutations.length === 1) {
          swiper.emit('observerUpdate', mutations[0]);
          return;
        }

        var observerUpdate = function observerUpdate() {
          swiper.emit('observerUpdate', mutations[0]);
        };

        if (win.requestAnimationFrame) {
          win.requestAnimationFrame(observerUpdate);
        } else {
          win.setTimeout(observerUpdate, 0);
        }
      });
      observer.observe(target, {
        attributes: typeof options.attributes === 'undefined' ? true : options.attributes,
        childList: typeof options.childList === 'undefined' ? true : options.childList,
        characterData: typeof options.characterData === 'undefined' ? true : options.characterData
      });
      swiper.observer.observers.push(observer);
    },
    init: function init() {
      var swiper = this;

      if (!Support.observer || !swiper.params.observer) {
        return;
      }

      if (swiper.params.observeParents) {
        var containerParents = swiper.$el.parents();

        for (var i = 0; i < containerParents.length; i += 1) {
          swiper.observer.attach(containerParents[i]);
        }
      } // Observe container


      swiper.observer.attach(swiper.$el[0], {
        childList: swiper.params.observeSlideChildren
      }); // Observe wrapper

      swiper.observer.attach(swiper.$wrapperEl[0], {
        attributes: false
      });
    },
    destroy: function destroy() {
      var swiper = this;
      swiper.observer.observers.forEach(function (observer) {
        observer.disconnect();
      });
      swiper.observer.observers = [];
    }
  };
  var Observer$1 = {
    name: 'observer',
    params: {
      observer: false,
      observeParents: false,
      observeSlideChildren: false
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        observer: {
          init: Observer.init.bind(swiper),
          attach: Observer.attach.bind(swiper),
          destroy: Observer.destroy.bind(swiper),
          observers: []
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;
        swiper.observer.init();
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.observer.destroy();
      }
    }
  };
  var Virtual = {
    update: function update(force) {
      var swiper = this;
      var ref = swiper.params;
      var slidesPerView = ref.slidesPerView;
      var slidesPerGroup = ref.slidesPerGroup;
      var centeredSlides = ref.centeredSlides;
      var ref$1 = swiper.params.virtual;
      var addSlidesBefore = ref$1.addSlidesBefore;
      var addSlidesAfter = ref$1.addSlidesAfter;
      var ref$2 = swiper.virtual;
      var previousFrom = ref$2.from;
      var previousTo = ref$2.to;
      var slides = ref$2.slides;
      var previousSlidesGrid = ref$2.slidesGrid;
      var renderSlide = ref$2.renderSlide;
      var previousOffset = ref$2.offset;
      swiper.updateActiveIndex();
      var activeIndex = swiper.activeIndex || 0;
      var offsetProp;

      if (swiper.rtlTranslate) {
        offsetProp = 'right';
      } else {
        offsetProp = swiper.isHorizontal() ? 'left' : 'top';
      }

      var slidesAfter;
      var slidesBefore;

      if (centeredSlides) {
        slidesAfter = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesBefore;
        slidesBefore = Math.floor(slidesPerView / 2) + slidesPerGroup + addSlidesAfter;
      } else {
        slidesAfter = slidesPerView + (slidesPerGroup - 1) + addSlidesBefore;
        slidesBefore = slidesPerGroup + addSlidesAfter;
      }

      var from = Math.max((activeIndex || 0) - slidesBefore, 0);
      var to = Math.min((activeIndex || 0) + slidesAfter, slides.length - 1);
      var offset = (swiper.slidesGrid[from] || 0) - (swiper.slidesGrid[0] || 0);
      Utils.extend(swiper.virtual, {
        from: from,
        to: to,
        offset: offset,
        slidesGrid: swiper.slidesGrid
      });

      function onRendered() {
        swiper.updateSlides();
        swiper.updateProgress();
        swiper.updateSlidesClasses();

        if (swiper.lazy && swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      }

      if (previousFrom === from && previousTo === to && !force) {
        if (swiper.slidesGrid !== previousSlidesGrid && offset !== previousOffset) {
          swiper.slides.css(offsetProp, offset + "px");
        }

        swiper.updateProgress();
        return;
      }

      if (swiper.params.virtual.renderExternal) {
        swiper.params.virtual.renderExternal.call(swiper, {
          offset: offset,
          from: from,
          to: to,
          slides: function getSlides() {
            var slidesToRender = [];

            for (var i = from; i <= to; i += 1) {
              slidesToRender.push(slides[i]);
            }

            return slidesToRender;
          }()
        });
        onRendered();
        return;
      }

      var prependIndexes = [];
      var appendIndexes = [];

      if (force) {
        swiper.$wrapperEl.find("." + swiper.params.slideClass).remove();
      } else {
        for (var i = previousFrom; i <= previousTo; i += 1) {
          if (i < from || i > to) {
            swiper.$wrapperEl.find("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + i + "\"]").remove();
          }
        }
      }

      for (var i$1 = 0; i$1 < slides.length; i$1 += 1) {
        if (i$1 >= from && i$1 <= to) {
          if (typeof previousTo === 'undefined' || force) {
            appendIndexes.push(i$1);
          } else {
            if (i$1 > previousTo) {
              appendIndexes.push(i$1);
            }

            if (i$1 < previousFrom) {
              prependIndexes.push(i$1);
            }
          }
        }
      }

      appendIndexes.forEach(function (index) {
        swiper.$wrapperEl.append(renderSlide(slides[index], index));
      });
      prependIndexes.sort(function (a, b) {
        return b - a;
      }).forEach(function (index) {
        swiper.$wrapperEl.prepend(renderSlide(slides[index], index));
      });
      swiper.$wrapperEl.children('.swiper-slide').css(offsetProp, offset + "px");
      onRendered();
    },
    renderSlide: function renderSlide(slide, index) {
      var swiper = this;
      var params = swiper.params.virtual;

      if (params.cache && swiper.virtual.cache[index]) {
        return swiper.virtual.cache[index];
      }

      var $slideEl = params.renderSlide ? $(params.renderSlide.call(swiper, slide, index)) : $("<div class=\"" + swiper.params.slideClass + "\" data-swiper-slide-index=\"" + index + "\">" + slide + "</div>");

      if (!$slideEl.attr('data-swiper-slide-index')) {
        $slideEl.attr('data-swiper-slide-index', index);
      }

      if (params.cache) {
        swiper.virtual.cache[index] = $slideEl;
      }

      return $slideEl;
    },
    appendSlide: function appendSlide(slides) {
      var swiper = this;

      if (typeof slides === 'object' && 'length' in slides) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) {
            swiper.virtual.slides.push(slides[i]);
          }
        }
      } else {
        swiper.virtual.slides.push(slides);
      }

      swiper.virtual.update(true);
    },
    prependSlide: function prependSlide(slides) {
      var swiper = this;
      var activeIndex = swiper.activeIndex;
      var newActiveIndex = activeIndex + 1;
      var numberOfNewSlides = 1;

      if (Array.isArray(slides)) {
        for (var i = 0; i < slides.length; i += 1) {
          if (slides[i]) {
            swiper.virtual.slides.unshift(slides[i]);
          }
        }

        newActiveIndex = activeIndex + slides.length;
        numberOfNewSlides = slides.length;
      } else {
        swiper.virtual.slides.unshift(slides);
      }

      if (swiper.params.virtual.cache) {
        var cache = swiper.virtual.cache;
        var newCache = {};
        Object.keys(cache).forEach(function (cachedIndex) {
          var $cachedEl = cache[cachedIndex];
          var cachedElIndex = $cachedEl.attr('data-swiper-slide-index');

          if (cachedElIndex) {
            $cachedEl.attr('data-swiper-slide-index', parseInt(cachedElIndex, 10) + 1);
          }

          newCache[parseInt(cachedIndex, 10) + numberOfNewSlides] = $cachedEl;
        });
        swiper.virtual.cache = newCache;
      }

      swiper.virtual.update(true);
      swiper.slideTo(newActiveIndex, 0);
    },
    removeSlide: function removeSlide(slidesIndexes) {
      var swiper = this;

      if (typeof slidesIndexes === 'undefined' || slidesIndexes === null) {
        return;
      }

      var activeIndex = swiper.activeIndex;

      if (Array.isArray(slidesIndexes)) {
        for (var i = slidesIndexes.length - 1; i >= 0; i -= 1) {
          swiper.virtual.slides.splice(slidesIndexes[i], 1);

          if (swiper.params.virtual.cache) {
            delete swiper.virtual.cache[slidesIndexes[i]];
          }

          if (slidesIndexes[i] < activeIndex) {
            activeIndex -= 1;
          }

          activeIndex = Math.max(activeIndex, 0);
        }
      } else {
        swiper.virtual.slides.splice(slidesIndexes, 1);

        if (swiper.params.virtual.cache) {
          delete swiper.virtual.cache[slidesIndexes];
        }

        if (slidesIndexes < activeIndex) {
          activeIndex -= 1;
        }

        activeIndex = Math.max(activeIndex, 0);
      }

      swiper.virtual.update(true);
      swiper.slideTo(activeIndex, 0);
    },
    removeAllSlides: function removeAllSlides() {
      var swiper = this;
      swiper.virtual.slides = [];

      if (swiper.params.virtual.cache) {
        swiper.virtual.cache = {};
      }

      swiper.virtual.update(true);
      swiper.slideTo(0, 0);
    }
  };
  var Virtual$1 = {
    name: 'virtual',
    params: {
      virtual: {
        enabled: false,
        slides: [],
        cache: true,
        renderSlide: null,
        renderExternal: null,
        addSlidesBefore: 0,
        addSlidesAfter: 0
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        virtual: {
          update: Virtual.update.bind(swiper),
          appendSlide: Virtual.appendSlide.bind(swiper),
          prependSlide: Virtual.prependSlide.bind(swiper),
          removeSlide: Virtual.removeSlide.bind(swiper),
          removeAllSlides: Virtual.removeAllSlides.bind(swiper),
          renderSlide: Virtual.renderSlide.bind(swiper),
          slides: swiper.params.virtual.slides,
          cache: {}
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (!swiper.params.virtual.enabled) {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "virtual");
        var overwriteParams = {
          watchSlidesProgress: true
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);

        if (!swiper.params.initialSlide) {
          swiper.virtual.update();
        }
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (!swiper.params.virtual.enabled) {
          return;
        }

        swiper.virtual.update();
      }
    }
  };
  var Keyboard = {
    handle: function handle(event) {
      var swiper = this;
      var rtl = swiper.rtlTranslate;
      var e = event;

      if (e.originalEvent) {
        e = e.originalEvent;
      } // jquery fix


      var kc = e.keyCode || e.charCode; // Directions locks

      if (!swiper.allowSlideNext && (swiper.isHorizontal() && kc === 39 || swiper.isVertical() && kc === 40 || kc === 34)) {
        return false;
      }

      if (!swiper.allowSlidePrev && (swiper.isHorizontal() && kc === 37 || swiper.isVertical() && kc === 38 || kc === 33)) {
        return false;
      }

      if (e.shiftKey || e.altKey || e.ctrlKey || e.metaKey) {
        return undefined;
      }

      if (doc.activeElement && doc.activeElement.nodeName && (doc.activeElement.nodeName.toLowerCase() === 'input' || doc.activeElement.nodeName.toLowerCase() === 'textarea')) {
        return undefined;
      }

      if (swiper.params.keyboard.onlyInViewport && (kc === 33 || kc === 34 || kc === 37 || kc === 39 || kc === 38 || kc === 40)) {
        var inView = false; // Check that swiper should be inside of visible area of window

        if (swiper.$el.parents("." + swiper.params.slideClass).length > 0 && swiper.$el.parents("." + swiper.params.slideActiveClass).length === 0) {
          return undefined;
        }

        var windowWidth = win.innerWidth;
        var windowHeight = win.innerHeight;
        var swiperOffset = swiper.$el.offset();

        if (rtl) {
          swiperOffset.left -= swiper.$el[0].scrollLeft;
        }

        var swiperCoord = [[swiperOffset.left, swiperOffset.top], [swiperOffset.left + swiper.width, swiperOffset.top], [swiperOffset.left, swiperOffset.top + swiper.height], [swiperOffset.left + swiper.width, swiperOffset.top + swiper.height]];

        for (var i = 0; i < swiperCoord.length; i += 1) {
          var point = swiperCoord[i];

          if (point[0] >= 0 && point[0] <= windowWidth && point[1] >= 0 && point[1] <= windowHeight) {
            inView = true;
          }
        }

        if (!inView) {
          return undefined;
        }
      }

      if (swiper.isHorizontal()) {
        if (kc === 33 || kc === 34 || kc === 37 || kc === 39) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
        }

        if ((kc === 34 || kc === 39) && !rtl || (kc === 33 || kc === 37) && rtl) {
          swiper.slideNext();
        }

        if ((kc === 33 || kc === 37) && !rtl || (kc === 34 || kc === 39) && rtl) {
          swiper.slidePrev();
        }
      } else {
        if (kc === 33 || kc === 34 || kc === 38 || kc === 40) {
          if (e.preventDefault) {
            e.preventDefault();
          } else {
            e.returnValue = false;
          }
        }

        if (kc === 34 || kc === 40) {
          swiper.slideNext();
        }

        if (kc === 33 || kc === 38) {
          swiper.slidePrev();
        }
      }

      swiper.emit('keyPress', kc);
      return undefined;
    },
    enable: function enable() {
      var swiper = this;

      if (swiper.keyboard.enabled) {
        return;
      }

      $(doc).on('keydown', swiper.keyboard.handle);
      swiper.keyboard.enabled = true;
    },
    disable: function disable() {
      var swiper = this;

      if (!swiper.keyboard.enabled) {
        return;
      }

      $(doc).off('keydown', swiper.keyboard.handle);
      swiper.keyboard.enabled = false;
    }
  };
  var Keyboard$1 = {
    name: 'keyboard',
    params: {
      keyboard: {
        enabled: false,
        onlyInViewport: true
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        keyboard: {
          enabled: false,
          enable: Keyboard.enable.bind(swiper),
          disable: Keyboard.disable.bind(swiper),
          handle: Keyboard.handle.bind(swiper)
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.keyboard.enabled) {
          swiper.keyboard.enable();
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.keyboard.enabled) {
          swiper.keyboard.disable();
        }
      }
    }
  };

  function isEventSupported() {
    var eventName = 'onwheel';
    var isSupported = (eventName in doc);

    if (!isSupported) {
      var element = doc.createElement('div');
      element.setAttribute(eventName, 'return;');
      isSupported = typeof element[eventName] === 'function';
    }

    if (!isSupported && doc.implementation && doc.implementation.hasFeature // always returns true in newer browsers as per the standard.
    // @see http://dom.spec.whatwg.org/#dom-domimplementation-hasfeature
    && doc.implementation.hasFeature('', '') !== true) {
      // This is the only way to test support for the `wheel` event in IE9+.
      isSupported = doc.implementation.hasFeature('Events.wheel', '3.0');
    }

    return isSupported;
  }

  var Mousewheel = {
    lastScrollTime: Utils.now(),
    lastEventBeforeSnap: undefined,
    recentWheelEvents: [],
    event: function event() {
      if (win.navigator.userAgent.indexOf('firefox') > -1) {
        return 'DOMMouseScroll';
      }

      return isEventSupported() ? 'wheel' : 'mousewheel';
    },
    normalize: function normalize(e) {
      // Reasonable defaults
      var PIXEL_STEP = 10;
      var LINE_HEIGHT = 40;
      var PAGE_HEIGHT = 800;
      var sX = 0;
      var sY = 0; // spinX, spinY

      var pX = 0;
      var pY = 0; // pixelX, pixelY
      // Legacy

      if ('detail' in e) {
        sY = e.detail;
      }

      if ('wheelDelta' in e) {
        sY = -e.wheelDelta / 120;
      }

      if ('wheelDeltaY' in e) {
        sY = -e.wheelDeltaY / 120;
      }

      if ('wheelDeltaX' in e) {
        sX = -e.wheelDeltaX / 120;
      } // side scrolling on FF with DOMMouseScroll


      if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {
        sX = sY;
        sY = 0;
      }

      pX = sX * PIXEL_STEP;
      pY = sY * PIXEL_STEP;

      if ('deltaY' in e) {
        pY = e.deltaY;
      }

      if ('deltaX' in e) {
        pX = e.deltaX;
      }

      if (e.shiftKey && !pX) {
        // if user scrolls with shift he wants horizontal scroll
        pX = pY;
        pY = 0;
      }

      if ((pX || pY) && e.deltaMode) {
        if (e.deltaMode === 1) {
          // delta in LINE units
          pX *= LINE_HEIGHT;
          pY *= LINE_HEIGHT;
        } else {
          // delta in PAGE units
          pX *= PAGE_HEIGHT;
          pY *= PAGE_HEIGHT;
        }
      } // Fall-back if spin cannot be determined


      if (pX && !sX) {
        sX = pX < 1 ? -1 : 1;
      }

      if (pY && !sY) {
        sY = pY < 1 ? -1 : 1;
      }

      return {
        spinX: sX,
        spinY: sY,
        pixelX: pX,
        pixelY: pY
      };
    },
    handleMouseEnter: function handleMouseEnter() {
      var swiper = this;
      swiper.mouseEntered = true;
    },
    handleMouseLeave: function handleMouseLeave() {
      var swiper = this;
      swiper.mouseEntered = false;
    },
    handle: function handle(event) {
      var e = event;
      var swiper = this;
      var params = swiper.params.mousewheel;

      if (swiper.params.cssMode) {
        e.preventDefault();
      }

      var target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarged !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarged);
      }

      if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) {
        return true;
      }

      if (e.originalEvent) {
        e = e.originalEvent;
      } // jquery fix


      var delta = 0;
      var rtlFactor = swiper.rtlTranslate ? -1 : 1;
      var data = Mousewheel.normalize(e);

      if (params.forceToAxis) {
        if (swiper.isHorizontal()) {
          if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) {
            delta = data.pixelX * rtlFactor;
          } else {
            return true;
          }
        } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) {
          delta = data.pixelY;
        } else {
          return true;
        }
      } else {
        delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;
      }

      if (delta === 0) {
        return true;
      }

      if (params.invert) {
        delta = -delta;
      }

      if (!swiper.params.freeMode) {
        // Register the new event in a variable which stores the relevant data
        var newEvent = {
          time: Utils.now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta),
          raw: event
        }; // Keep the most recent events

        var recentWheelEvents = swiper.mousewheel.recentWheelEvents;

        if (recentWheelEvents.length >= 2) {
          recentWheelEvents.shift(); // only store the last N events
        }

        var prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;
        recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:
        //   If direction has changed or
        //   if the scroll is quicker than the previous one:
        //     Animate the slider.
        // Else (this is the first time the wheel is moved):
        //     Animate the slider.

        if (prevEvent) {
          if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta) {
            swiper.mousewheel.animateSlider(newEvent);
          }
        } else {
          swiper.mousewheel.animateSlider(newEvent);
        } // If it's time to release the scroll:
        //   Return now so you don't hit the preventDefault.


        if (swiper.mousewheel.releaseScroll(newEvent)) {
          return true;
        }
      } else {
        // Freemode or scrollContainer:
        // If we recently snapped after a momentum scroll, then ignore wheel events
        // to give time for the deceleration to finish. Stop ignoring after 500 msecs
        // or if it's a new scroll (larger delta or inverse sign as last event before
        // an end-of-momentum snap).
        var newEvent$1 = {
          time: Utils.now(),
          delta: Math.abs(delta),
          direction: Math.sign(delta)
        };
        var ref = swiper.mousewheel;
        var lastEventBeforeSnap = ref.lastEventBeforeSnap;
        var ignoreWheelEvents = lastEventBeforeSnap && newEvent$1.time < lastEventBeforeSnap.time + 500 && newEvent$1.delta <= lastEventBeforeSnap.delta && newEvent$1.direction === lastEventBeforeSnap.direction;

        if (!ignoreWheelEvents) {
          swiper.mousewheel.lastEventBeforeSnap = undefined;

          if (swiper.params.loop) {
            swiper.loopFix();
          }

          var position = swiper.getTranslate() + delta * params.sensitivity;
          var wasBeginning = swiper.isBeginning;
          var wasEnd = swiper.isEnd;

          if (position >= swiper.minTranslate()) {
            position = swiper.minTranslate();
          }

          if (position <= swiper.maxTranslate()) {
            position = swiper.maxTranslate();
          }

          swiper.setTransition(0);
          swiper.setTranslate(position);
          swiper.updateProgress();
          swiper.updateActiveIndex();
          swiper.updateSlidesClasses();

          if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {
            swiper.updateSlidesClasses();
          }

          if (swiper.params.freeModeSticky) {
            // When wheel scrolling starts with sticky (aka snap) enabled, then detect
            // the end of a momentum scroll by storing recent (N=15?) wheel events.
            // 1. do all N events have decreasing or same (absolute value) delta?
            // 2. did all N events arrive in the last M (M=500?) msecs?
            // 3. does the earliest event have an (absolute value) delta that's
            //    at least P (P=1?) larger than the most recent event's delta?
            // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?
            // If 1-4 are "yes" then we're near the end of a momuntum scroll deceleration.
            // Snap immediately and ignore remaining wheel events in this scroll.
            // See comment above for "remaining wheel events in this scroll" determination.
            // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.
            clearTimeout(swiper.mousewheel.timeout);
            swiper.mousewheel.timeout = undefined;
            var recentWheelEvents$1 = swiper.mousewheel.recentWheelEvents;

            if (recentWheelEvents$1.length >= 15) {
              recentWheelEvents$1.shift(); // only store the last N events
            }

            var prevEvent$1 = recentWheelEvents$1.length ? recentWheelEvents$1[recentWheelEvents$1.length - 1] : undefined;
            var firstEvent = recentWheelEvents$1[0];
            recentWheelEvents$1.push(newEvent$1);

            if (prevEvent$1 && (newEvent$1.delta > prevEvent$1.delta || newEvent$1.direction !== prevEvent$1.direction)) {
              // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.
              recentWheelEvents$1.splice(0);
            } else if (recentWheelEvents$1.length >= 15 && newEvent$1.time - firstEvent.time < 500 && firstEvent.delta - newEvent$1.delta >= 1 && newEvent$1.delta <= 6) {
              // We're at the end of the deceleration of a momentum scroll, so there's no need
              // to wait for more events. Snap ASAP on the next tick.
              // Also, because there's some remaining momentum we'll bias the snap in the
              // direction of the ongoing scroll because it's better UX for the scroll to snap
              // in the same direction as the scroll instead of reversing to snap.  Therefore,
              // if it's already scrolled more than 20% in the current direction, keep going.
              var snapToThreshold = delta > 0 ? 0.8 : 0.2;
              swiper.mousewheel.lastEventBeforeSnap = newEvent$1;
              recentWheelEvents$1.splice(0);
              swiper.mousewheel.timeout = Utils.nextTick(function () {
                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
              }, 0); // no delay; move on next tick
            }

            if (!swiper.mousewheel.timeout) {
              // if we get here, then we haven't detected the end of a momentum scroll, so
              // we'll consider a scroll "complete" when there haven't been any wheel events
              // for 500ms.
              swiper.mousewheel.timeout = Utils.nextTick(function () {
                var snapToThreshold = 0.5;
                swiper.mousewheel.lastEventBeforeSnap = newEvent$1;
                recentWheelEvents$1.splice(0);
                swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);
              }, 500);
            }
          } // Emit event


          if (!ignoreWheelEvents) {
            swiper.emit('scroll', e);
          } // Stop autoplay


          if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) {
            swiper.autoplay.stop();
          } // Return page scroll on edge positions


          if (position === swiper.minTranslate() || position === swiper.maxTranslate()) {
            return true;
          }
        }
      }

      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }

      return false;
    },
    animateSlider: function animateSlider(newEvent) {
      var swiper = this; // If the movement is NOT big enough and
      // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):
      //   Don't go any further (avoid insignificant scroll movement).

      if (newEvent.delta >= 6 && Utils.now() - swiper.mousewheel.lastScrollTime < 60) {
        // Return false as a default
        return true;
      } // If user is scrolling towards the end:
      //   If the slider hasn't hit the latest slide or
      //   if the slider is a loop and
      //   if the slider isn't moving right now:
      //     Go to next slide and
      //     emit a scroll event.
      // Else (the user is scrolling towards the beginning) and
      // if the slider hasn't hit the first slide or
      // if the slider is a loop and
      // if the slider isn't moving right now:
      //   Go to prev slide and
      //   emit a scroll event.


      if (newEvent.direction < 0) {
        if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {
          swiper.slideNext();
          swiper.emit('scroll', newEvent.raw);
        }
      } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {
        swiper.slidePrev();
        swiper.emit('scroll', newEvent.raw);
      } // If you got here is because an animation has been triggered so store the current time


      swiper.mousewheel.lastScrollTime = new win.Date().getTime(); // Return false as a default

      return false;
    },
    releaseScroll: function releaseScroll(newEvent) {
      var swiper = this;
      var params = swiper.params.mousewheel;

      if (newEvent.direction < 0) {
        if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {
          // Return true to animate scroll on edges
          return true;
        }
      } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {
        // Return true to animate scroll on edges
        return true;
      }

      return false;
    },
    enable: function enable() {
      var swiper = this;
      var event = Mousewheel.event();

      if (swiper.params.cssMode) {
        swiper.wrapperEl.removeEventListener(event, swiper.mousewheel.handle);
        return true;
      }

      if (!event) {
        return false;
      }

      if (swiper.mousewheel.enabled) {
        return false;
      }

      var target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarged !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarged);
      }

      target.on('mouseenter', swiper.mousewheel.handleMouseEnter);
      target.on('mouseleave', swiper.mousewheel.handleMouseLeave);
      target.on(event, swiper.mousewheel.handle);
      swiper.mousewheel.enabled = true;
      return true;
    },
    disable: function disable() {
      var swiper = this;
      var event = Mousewheel.event();

      if (swiper.params.cssMode) {
        swiper.wrapperEl.addEventListener(event, swiper.mousewheel.handle);
        return true;
      }

      if (!event) {
        return false;
      }

      if (!swiper.mousewheel.enabled) {
        return false;
      }

      var target = swiper.$el;

      if (swiper.params.mousewheel.eventsTarged !== 'container') {
        target = $(swiper.params.mousewheel.eventsTarged);
      }

      target.off(event, swiper.mousewheel.handle);
      swiper.mousewheel.enabled = false;
      return true;
    }
  };
  var Mousewheel$1 = {
    name: 'mousewheel',
    params: {
      mousewheel: {
        enabled: false,
        releaseOnEdges: false,
        invert: false,
        forceToAxis: false,
        sensitivity: 1,
        eventsTarged: 'container'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        mousewheel: {
          enabled: false,
          enable: Mousewheel.enable.bind(swiper),
          disable: Mousewheel.disable.bind(swiper),
          handle: Mousewheel.handle.bind(swiper),
          handleMouseEnter: Mousewheel.handleMouseEnter.bind(swiper),
          handleMouseLeave: Mousewheel.handleMouseLeave.bind(swiper),
          animateSlider: Mousewheel.animateSlider.bind(swiper),
          releaseScroll: Mousewheel.releaseScroll.bind(swiper),
          lastScrollTime: Utils.now(),
          lastEventBeforeSnap: undefined,
          recentWheelEvents: []
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {
          swiper.mousewheel.disable();
        }

        if (swiper.params.mousewheel.enabled) {
          swiper.mousewheel.enable();
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.params.cssMode) {
          swiper.mousewheel.enable();
        }

        if (swiper.mousewheel.enabled) {
          swiper.mousewheel.disable();
        }
      }
    }
  };
  var Navigation = {
    update: function update() {
      // Update Navigation Buttons
      var swiper = this;
      var params = swiper.params.navigation;

      if (swiper.params.loop) {
        return;
      }

      var ref = swiper.navigation;
      var $nextEl = ref.$nextEl;
      var $prevEl = ref.$prevEl;

      if ($prevEl && $prevEl.length > 0) {
        if (swiper.isBeginning) {
          $prevEl.addClass(params.disabledClass);
        } else {
          $prevEl.removeClass(params.disabledClass);
        }

        $prevEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }

      if ($nextEl && $nextEl.length > 0) {
        if (swiper.isEnd) {
          $nextEl.addClass(params.disabledClass);
        } else {
          $nextEl.removeClass(params.disabledClass);
        }

        $nextEl[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
      }
    },
    onPrevClick: function onPrevClick(e) {
      var swiper = this;
      e.preventDefault();

      if (swiper.isBeginning && !swiper.params.loop) {
        return;
      }

      swiper.slidePrev();
    },
    onNextClick: function onNextClick(e) {
      var swiper = this;
      e.preventDefault();

      if (swiper.isEnd && !swiper.params.loop) {
        return;
      }

      swiper.slideNext();
    },
    init: function init() {
      var swiper = this;
      var params = swiper.params.navigation;

      if (!(params.nextEl || params.prevEl)) {
        return;
      }

      var $nextEl;
      var $prevEl;

      if (params.nextEl) {
        $nextEl = $(params.nextEl);

        if (swiper.params.uniqueNavElements && typeof params.nextEl === 'string' && $nextEl.length > 1 && swiper.$el.find(params.nextEl).length === 1) {
          $nextEl = swiper.$el.find(params.nextEl);
        }
      }

      if (params.prevEl) {
        $prevEl = $(params.prevEl);

        if (swiper.params.uniqueNavElements && typeof params.prevEl === 'string' && $prevEl.length > 1 && swiper.$el.find(params.prevEl).length === 1) {
          $prevEl = swiper.$el.find(params.prevEl);
        }
      }

      if ($nextEl && $nextEl.length > 0) {
        $nextEl.on('click', swiper.navigation.onNextClick);
      }

      if ($prevEl && $prevEl.length > 0) {
        $prevEl.on('click', swiper.navigation.onPrevClick);
      }

      Utils.extend(swiper.navigation, {
        $nextEl: $nextEl,
        nextEl: $nextEl && $nextEl[0],
        $prevEl: $prevEl,
        prevEl: $prevEl && $prevEl[0]
      });
    },
    destroy: function destroy() {
      var swiper = this;
      var ref = swiper.navigation;
      var $nextEl = ref.$nextEl;
      var $prevEl = ref.$prevEl;

      if ($nextEl && $nextEl.length) {
        $nextEl.off('click', swiper.navigation.onNextClick);
        $nextEl.removeClass(swiper.params.navigation.disabledClass);
      }

      if ($prevEl && $prevEl.length) {
        $prevEl.off('click', swiper.navigation.onPrevClick);
        $prevEl.removeClass(swiper.params.navigation.disabledClass);
      }
    }
  };
  var Navigation$1 = {
    name: 'navigation',
    params: {
      navigation: {
        nextEl: null,
        prevEl: null,
        hideOnClick: false,
        disabledClass: 'swiper-button-disabled',
        hiddenClass: 'swiper-button-hidden',
        lockClass: 'swiper-button-lock'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        navigation: {
          init: Navigation.init.bind(swiper),
          update: Navigation.update.bind(swiper),
          destroy: Navigation.destroy.bind(swiper),
          onNextClick: Navigation.onNextClick.bind(swiper),
          onPrevClick: Navigation.onPrevClick.bind(swiper)
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;
        swiper.navigation.init();
        swiper.navigation.update();
      },
      toEdge: function toEdge() {
        var swiper = this;
        swiper.navigation.update();
      },
      fromEdge: function fromEdge() {
        var swiper = this;
        swiper.navigation.update();
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.navigation.destroy();
      },
      click: function click(e) {
        var swiper = this;
        var ref = swiper.navigation;
        var $nextEl = ref.$nextEl;
        var $prevEl = ref.$prevEl;

        if (swiper.params.navigation.hideOnClick && !$(e.target).is($prevEl) && !$(e.target).is($nextEl)) {
          var isHidden;

          if ($nextEl) {
            isHidden = $nextEl.hasClass(swiper.params.navigation.hiddenClass);
          } else if ($prevEl) {
            isHidden = $prevEl.hasClass(swiper.params.navigation.hiddenClass);
          }

          if (isHidden === true) {
            swiper.emit('navigationShow', swiper);
          } else {
            swiper.emit('navigationHide', swiper);
          }

          if ($nextEl) {
            $nextEl.toggleClass(swiper.params.navigation.hiddenClass);
          }

          if ($prevEl) {
            $prevEl.toggleClass(swiper.params.navigation.hiddenClass);
          }
        }
      }
    }
  };
  var Pagination = {
    update: function update() {
      // Render || Update Pagination bullets/items
      var swiper = this;
      var rtl = swiper.rtl;
      var params = swiper.params.pagination;

      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
        return;
      }

      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      var $el = swiper.pagination.$el; // Current/Total

      var current;
      var total = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

      if (swiper.params.loop) {
        current = Math.ceil((swiper.activeIndex - swiper.loopedSlides) / swiper.params.slidesPerGroup);

        if (current > slidesLength - 1 - swiper.loopedSlides * 2) {
          current -= slidesLength - swiper.loopedSlides * 2;
        }

        if (current > total - 1) {
          current -= total;
        }

        if (current < 0 && swiper.params.paginationType !== 'bullets') {
          current = total + current;
        }
      } else if (typeof swiper.snapIndex !== 'undefined') {
        current = swiper.snapIndex;
      } else {
        current = swiper.activeIndex || 0;
      } // Types


      if (params.type === 'bullets' && swiper.pagination.bullets && swiper.pagination.bullets.length > 0) {
        var bullets = swiper.pagination.bullets;
        var firstIndex;
        var lastIndex;
        var midIndex;

        if (params.dynamicBullets) {
          swiper.pagination.bulletSize = bullets.eq(0)[swiper.isHorizontal() ? 'outerWidth' : 'outerHeight'](true);
          $el.css(swiper.isHorizontal() ? 'width' : 'height', swiper.pagination.bulletSize * (params.dynamicMainBullets + 4) + "px");

          if (params.dynamicMainBullets > 1 && swiper.previousIndex !== undefined) {
            swiper.pagination.dynamicBulletIndex += current - swiper.previousIndex;

            if (swiper.pagination.dynamicBulletIndex > params.dynamicMainBullets - 1) {
              swiper.pagination.dynamicBulletIndex = params.dynamicMainBullets - 1;
            } else if (swiper.pagination.dynamicBulletIndex < 0) {
              swiper.pagination.dynamicBulletIndex = 0;
            }
          }

          firstIndex = current - swiper.pagination.dynamicBulletIndex;
          lastIndex = firstIndex + (Math.min(bullets.length, params.dynamicMainBullets) - 1);
          midIndex = (lastIndex + firstIndex) / 2;
        }

        bullets.removeClass(params.bulletActiveClass + " " + params.bulletActiveClass + "-next " + params.bulletActiveClass + "-next-next " + params.bulletActiveClass + "-prev " + params.bulletActiveClass + "-prev-prev " + params.bulletActiveClass + "-main");

        if ($el.length > 1) {
          bullets.each(function (index, bullet) {
            var $bullet = $(bullet);
            var bulletIndex = $bullet.index();

            if (bulletIndex === current) {
              $bullet.addClass(params.bulletActiveClass);
            }

            if (params.dynamicBullets) {
              if (bulletIndex >= firstIndex && bulletIndex <= lastIndex) {
                $bullet.addClass(params.bulletActiveClass + "-main");
              }

              if (bulletIndex === firstIndex) {
                $bullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
              }

              if (bulletIndex === lastIndex) {
                $bullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
              }
            }
          });
        } else {
          var $bullet = bullets.eq(current);
          var bulletIndex = $bullet.index();
          $bullet.addClass(params.bulletActiveClass);

          if (params.dynamicBullets) {
            var $firstDisplayedBullet = bullets.eq(firstIndex);
            var $lastDisplayedBullet = bullets.eq(lastIndex);

            for (var i = firstIndex; i <= lastIndex; i += 1) {
              bullets.eq(i).addClass(params.bulletActiveClass + "-main");
            }

            if (swiper.params.loop) {
              if (bulletIndex >= bullets.length - params.dynamicMainBullets) {
                for (var i$1 = params.dynamicMainBullets; i$1 >= 0; i$1 -= 1) {
                  bullets.eq(bullets.length - i$1).addClass(params.bulletActiveClass + "-main");
                }

                bullets.eq(bullets.length - params.dynamicMainBullets - 1).addClass(params.bulletActiveClass + "-prev");
              } else {
                $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
                $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
              }
            } else {
              $firstDisplayedBullet.prev().addClass(params.bulletActiveClass + "-prev").prev().addClass(params.bulletActiveClass + "-prev-prev");
              $lastDisplayedBullet.next().addClass(params.bulletActiveClass + "-next").next().addClass(params.bulletActiveClass + "-next-next");
            }
          }
        }

        if (params.dynamicBullets) {
          var dynamicBulletsLength = Math.min(bullets.length, params.dynamicMainBullets + 4);
          var bulletsOffset = (swiper.pagination.bulletSize * dynamicBulletsLength - swiper.pagination.bulletSize) / 2 - midIndex * swiper.pagination.bulletSize;
          var offsetProp = rtl ? 'right' : 'left';
          bullets.css(swiper.isHorizontal() ? offsetProp : 'top', bulletsOffset + "px");
        }
      }

      if (params.type === 'fraction') {
        $el.find("." + params.currentClass).text(params.formatFractionCurrent(current + 1));
        $el.find("." + params.totalClass).text(params.formatFractionTotal(total));
      }

      if (params.type === 'progressbar') {
        var progressbarDirection;

        if (params.progressbarOpposite) {
          progressbarDirection = swiper.isHorizontal() ? 'vertical' : 'horizontal';
        } else {
          progressbarDirection = swiper.isHorizontal() ? 'horizontal' : 'vertical';
        }

        var scale = (current + 1) / total;
        var scaleX = 1;
        var scaleY = 1;

        if (progressbarDirection === 'horizontal') {
          scaleX = scale;
        } else {
          scaleY = scale;
        }

        $el.find("." + params.progressbarFillClass).transform("translate3d(0,0,0) scaleX(" + scaleX + ") scaleY(" + scaleY + ")").transition(swiper.params.speed);
      }

      if (params.type === 'custom' && params.renderCustom) {
        $el.html(params.renderCustom(swiper, current + 1, total));
        swiper.emit('paginationRender', swiper, $el[0]);
      } else {
        swiper.emit('paginationUpdate', swiper, $el[0]);
      }

      $el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](params.lockClass);
    },
    render: function render() {
      // Render Container
      var swiper = this;
      var params = swiper.params.pagination;

      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
        return;
      }

      var slidesLength = swiper.virtual && swiper.params.virtual.enabled ? swiper.virtual.slides.length : swiper.slides.length;
      var $el = swiper.pagination.$el;
      var paginationHTML = '';

      if (params.type === 'bullets') {
        var numberOfBullets = swiper.params.loop ? Math.ceil((slidesLength - swiper.loopedSlides * 2) / swiper.params.slidesPerGroup) : swiper.snapGrid.length;

        for (var i = 0; i < numberOfBullets; i += 1) {
          if (params.renderBullet) {
            paginationHTML += params.renderBullet.call(swiper, i, params.bulletClass);
          } else {
            paginationHTML += "<" + params.bulletElement + " class=\"" + params.bulletClass + "\"></" + params.bulletElement + ">";
          }
        }

        $el.html(paginationHTML);
        swiper.pagination.bullets = $el.find("." + params.bulletClass);
      }

      if (params.type === 'fraction') {
        if (params.renderFraction) {
          paginationHTML = params.renderFraction.call(swiper, params.currentClass, params.totalClass);
        } else {
          paginationHTML = "<span class=\"" + params.currentClass + "\"></span>" + ' / ' + "<span class=\"" + params.totalClass + "\"></span>";
        }

        $el.html(paginationHTML);
      }

      if (params.type === 'progressbar') {
        if (params.renderProgressbar) {
          paginationHTML = params.renderProgressbar.call(swiper, params.progressbarFillClass);
        } else {
          paginationHTML = "<span class=\"" + params.progressbarFillClass + "\"></span>";
        }

        $el.html(paginationHTML);
      }

      if (params.type !== 'custom') {
        swiper.emit('paginationRender', swiper.pagination.$el[0]);
      }
    },
    init: function init() {
      var swiper = this;
      var params = swiper.params.pagination;

      if (!params.el) {
        return;
      }

      var $el = $(params.el);

      if ($el.length === 0) {
        return;
      }

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && swiper.$el.find(params.el).length === 1) {
        $el = swiper.$el.find(params.el);
      }

      if (params.type === 'bullets' && params.clickable) {
        $el.addClass(params.clickableClass);
      }

      $el.addClass(params.modifierClass + params.type);

      if (params.type === 'bullets' && params.dynamicBullets) {
        $el.addClass("" + params.modifierClass + params.type + "-dynamic");
        swiper.pagination.dynamicBulletIndex = 0;

        if (params.dynamicMainBullets < 1) {
          params.dynamicMainBullets = 1;
        }
      }

      if (params.type === 'progressbar' && params.progressbarOpposite) {
        $el.addClass(params.progressbarOppositeClass);
      }

      if (params.clickable) {
        $el.on('click', "." + params.bulletClass, function onClick(e) {
          e.preventDefault();
          var index = $(this).index() * swiper.params.slidesPerGroup;

          if (swiper.params.loop) {
            index += swiper.loopedSlides;
          }

          swiper.slideTo(index);
        });
      }

      Utils.extend(swiper.pagination, {
        $el: $el,
        el: $el[0]
      });
    },
    destroy: function destroy() {
      var swiper = this;
      var params = swiper.params.pagination;

      if (!params.el || !swiper.pagination.el || !swiper.pagination.$el || swiper.pagination.$el.length === 0) {
        return;
      }

      var $el = swiper.pagination.$el;
      $el.removeClass(params.hiddenClass);
      $el.removeClass(params.modifierClass + params.type);

      if (swiper.pagination.bullets) {
        swiper.pagination.bullets.removeClass(params.bulletActiveClass);
      }

      if (params.clickable) {
        $el.off('click', "." + params.bulletClass);
      }
    }
  };
  var Pagination$1 = {
    name: 'pagination',
    params: {
      pagination: {
        el: null,
        bulletElement: 'span',
        clickable: false,
        hideOnClick: false,
        renderBullet: null,
        renderProgressbar: null,
        renderFraction: null,
        renderCustom: null,
        progressbarOpposite: false,
        type: 'bullets',
        // 'bullets' or 'progressbar' or 'fraction' or 'custom'
        dynamicBullets: false,
        dynamicMainBullets: 1,
        formatFractionCurrent: function (number) {
          return number;
        },
        formatFractionTotal: function (number) {
          return number;
        },
        bulletClass: 'swiper-pagination-bullet',
        bulletActiveClass: 'swiper-pagination-bullet-active',
        modifierClass: 'swiper-pagination-',
        // NEW
        currentClass: 'swiper-pagination-current',
        totalClass: 'swiper-pagination-total',
        hiddenClass: 'swiper-pagination-hidden',
        progressbarFillClass: 'swiper-pagination-progressbar-fill',
        progressbarOppositeClass: 'swiper-pagination-progressbar-opposite',
        clickableClass: 'swiper-pagination-clickable',
        // NEW
        lockClass: 'swiper-pagination-lock'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        pagination: {
          init: Pagination.init.bind(swiper),
          render: Pagination.render.bind(swiper),
          update: Pagination.update.bind(swiper),
          destroy: Pagination.destroy.bind(swiper),
          dynamicBulletIndex: 0
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;
        swiper.pagination.init();
        swiper.pagination.render();
        swiper.pagination.update();
      },
      activeIndexChange: function activeIndexChange() {
        var swiper = this;

        if (swiper.params.loop) {
          swiper.pagination.update();
        } else if (typeof swiper.snapIndex === 'undefined') {
          swiper.pagination.update();
        }
      },
      snapIndexChange: function snapIndexChange() {
        var swiper = this;

        if (!swiper.params.loop) {
          swiper.pagination.update();
        }
      },
      slidesLengthChange: function slidesLengthChange() {
        var swiper = this;

        if (swiper.params.loop) {
          swiper.pagination.render();
          swiper.pagination.update();
        }
      },
      snapGridLengthChange: function snapGridLengthChange() {
        var swiper = this;

        if (!swiper.params.loop) {
          swiper.pagination.render();
          swiper.pagination.update();
        }
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.pagination.destroy();
      },
      click: function click(e) {
        var swiper = this;

        if (swiper.params.pagination.el && swiper.params.pagination.hideOnClick && swiper.pagination.$el.length > 0 && !$(e.target).hasClass(swiper.params.pagination.bulletClass)) {
          var isHidden = swiper.pagination.$el.hasClass(swiper.params.pagination.hiddenClass);

          if (isHidden === true) {
            swiper.emit('paginationShow', swiper);
          } else {
            swiper.emit('paginationHide', swiper);
          }

          swiper.pagination.$el.toggleClass(swiper.params.pagination.hiddenClass);
        }
      }
    }
  };
  var Scrollbar = {
    setTranslate: function setTranslate() {
      var swiper = this;

      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var rtl = swiper.rtlTranslate;
      var progress = swiper.progress;
      var dragSize = scrollbar.dragSize;
      var trackSize = scrollbar.trackSize;
      var $dragEl = scrollbar.$dragEl;
      var $el = scrollbar.$el;
      var params = swiper.params.scrollbar;
      var newSize = dragSize;
      var newPos = (trackSize - dragSize) * progress;

      if (rtl) {
        newPos = -newPos;

        if (newPos > 0) {
          newSize = dragSize - newPos;
          newPos = 0;
        } else if (-newPos + dragSize > trackSize) {
          newSize = trackSize + newPos;
        }
      } else if (newPos < 0) {
        newSize = dragSize + newPos;
        newPos = 0;
      } else if (newPos + dragSize > trackSize) {
        newSize = trackSize - newPos;
      }

      if (swiper.isHorizontal()) {
        $dragEl.transform("translate3d(" + newPos + "px, 0, 0)");
        $dragEl[0].style.width = newSize + "px";
      } else {
        $dragEl.transform("translate3d(0px, " + newPos + "px, 0)");
        $dragEl[0].style.height = newSize + "px";
      }

      if (params.hide) {
        clearTimeout(swiper.scrollbar.timeout);
        $el[0].style.opacity = 1;
        swiper.scrollbar.timeout = setTimeout(function () {
          $el[0].style.opacity = 0;
          $el.transition(400);
        }, 1000);
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;

      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
        return;
      }

      swiper.scrollbar.$dragEl.transition(duration);
    },
    updateSize: function updateSize() {
      var swiper = this;

      if (!swiper.params.scrollbar.el || !swiper.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var $dragEl = scrollbar.$dragEl;
      var $el = scrollbar.$el;
      $dragEl[0].style.width = '';
      $dragEl[0].style.height = '';
      var trackSize = swiper.isHorizontal() ? $el[0].offsetWidth : $el[0].offsetHeight;
      var divider = swiper.size / swiper.virtualSize;
      var moveDivider = divider * (trackSize / swiper.size);
      var dragSize;

      if (swiper.params.scrollbar.dragSize === 'auto') {
        dragSize = trackSize * divider;
      } else {
        dragSize = parseInt(swiper.params.scrollbar.dragSize, 10);
      }

      if (swiper.isHorizontal()) {
        $dragEl[0].style.width = dragSize + "px";
      } else {
        $dragEl[0].style.height = dragSize + "px";
      }

      if (divider >= 1) {
        $el[0].style.display = 'none';
      } else {
        $el[0].style.display = '';
      }

      if (swiper.params.scrollbar.hide) {
        $el[0].style.opacity = 0;
      }

      Utils.extend(scrollbar, {
        trackSize: trackSize,
        divider: divider,
        moveDivider: moveDivider,
        dragSize: dragSize
      });
      scrollbar.$el[swiper.params.watchOverflow && swiper.isLocked ? 'addClass' : 'removeClass'](swiper.params.scrollbar.lockClass);
    },
    getPointerPosition: function getPointerPosition(e) {
      var swiper = this;

      if (swiper.isHorizontal()) {
        return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientX : e.clientX;
      }

      return e.type === 'touchstart' || e.type === 'touchmove' ? e.targetTouches[0].clientY : e.clientY;
    },
    setDragPosition: function setDragPosition(e) {
      var swiper = this;
      var scrollbar = swiper.scrollbar;
      var rtl = swiper.rtlTranslate;
      var $el = scrollbar.$el;
      var dragSize = scrollbar.dragSize;
      var trackSize = scrollbar.trackSize;
      var dragStartPos = scrollbar.dragStartPos;
      var positionRatio;
      positionRatio = (scrollbar.getPointerPosition(e) - $el.offset()[swiper.isHorizontal() ? 'left' : 'top'] - (dragStartPos !== null ? dragStartPos : dragSize / 2)) / (trackSize - dragSize);
      positionRatio = Math.max(Math.min(positionRatio, 1), 0);

      if (rtl) {
        positionRatio = 1 - positionRatio;
      }

      var position = swiper.minTranslate() + (swiper.maxTranslate() - swiper.minTranslate()) * positionRatio;
      swiper.updateProgress(position);
      swiper.setTranslate(position);
      swiper.updateActiveIndex();
      swiper.updateSlidesClasses();
    },
    onDragStart: function onDragStart(e) {
      var swiper = this;
      var params = swiper.params.scrollbar;
      var scrollbar = swiper.scrollbar;
      var $wrapperEl = swiper.$wrapperEl;
      var $el = scrollbar.$el;
      var $dragEl = scrollbar.$dragEl;
      swiper.scrollbar.isTouched = true;
      swiper.scrollbar.dragStartPos = e.target === $dragEl[0] || e.target === $dragEl ? scrollbar.getPointerPosition(e) - e.target.getBoundingClientRect()[swiper.isHorizontal() ? 'left' : 'top'] : null;
      e.preventDefault();
      e.stopPropagation();
      $wrapperEl.transition(100);
      $dragEl.transition(100);
      scrollbar.setDragPosition(e);
      clearTimeout(swiper.scrollbar.dragTimeout);
      $el.transition(0);

      if (params.hide) {
        $el.css('opacity', 1);
      }

      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', 'none');
      }

      swiper.emit('scrollbarDragStart', e);
    },
    onDragMove: function onDragMove(e) {
      var swiper = this;
      var scrollbar = swiper.scrollbar;
      var $wrapperEl = swiper.$wrapperEl;
      var $el = scrollbar.$el;
      var $dragEl = scrollbar.$dragEl;

      if (!swiper.scrollbar.isTouched) {
        return;
      }

      if (e.preventDefault) {
        e.preventDefault();
      } else {
        e.returnValue = false;
      }

      scrollbar.setDragPosition(e);
      $wrapperEl.transition(0);
      $el.transition(0);
      $dragEl.transition(0);
      swiper.emit('scrollbarDragMove', e);
    },
    onDragEnd: function onDragEnd(e) {
      var swiper = this;
      var params = swiper.params.scrollbar;
      var scrollbar = swiper.scrollbar;
      var $wrapperEl = swiper.$wrapperEl;
      var $el = scrollbar.$el;

      if (!swiper.scrollbar.isTouched) {
        return;
      }

      swiper.scrollbar.isTouched = false;

      if (swiper.params.cssMode) {
        swiper.$wrapperEl.css('scroll-snap-type', '');
        $wrapperEl.transition('');
      }

      if (params.hide) {
        clearTimeout(swiper.scrollbar.dragTimeout);
        swiper.scrollbar.dragTimeout = Utils.nextTick(function () {
          $el.css('opacity', 0);
          $el.transition(400);
        }, 1000);
      }

      swiper.emit('scrollbarDragEnd', e);

      if (params.snapOnRelease) {
        swiper.slideToClosest();
      }
    },
    enableDraggable: function enableDraggable() {
      var swiper = this;

      if (!swiper.params.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var touchEventsTouch = swiper.touchEventsTouch;
      var touchEventsDesktop = swiper.touchEventsDesktop;
      var params = swiper.params;
      var $el = scrollbar.$el;
      var target = $el[0];
      var activeListener = Support.passiveListener && params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      var passiveListener = Support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;

      if (!Support.touch) {
        target.addEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
        doc.addEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
        doc.addEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
      } else {
        target.addEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
        target.addEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
        target.addEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
    },
    disableDraggable: function disableDraggable() {
      var swiper = this;

      if (!swiper.params.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var touchEventsTouch = swiper.touchEventsTouch;
      var touchEventsDesktop = swiper.touchEventsDesktop;
      var params = swiper.params;
      var $el = scrollbar.$el;
      var target = $el[0];
      var activeListener = Support.passiveListener && params.passiveListeners ? {
        passive: false,
        capture: false
      } : false;
      var passiveListener = Support.passiveListener && params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;

      if (!Support.touch) {
        target.removeEventListener(touchEventsDesktop.start, swiper.scrollbar.onDragStart, activeListener);
        doc.removeEventListener(touchEventsDesktop.move, swiper.scrollbar.onDragMove, activeListener);
        doc.removeEventListener(touchEventsDesktop.end, swiper.scrollbar.onDragEnd, passiveListener);
      } else {
        target.removeEventListener(touchEventsTouch.start, swiper.scrollbar.onDragStart, activeListener);
        target.removeEventListener(touchEventsTouch.move, swiper.scrollbar.onDragMove, activeListener);
        target.removeEventListener(touchEventsTouch.end, swiper.scrollbar.onDragEnd, passiveListener);
      }
    },
    init: function init() {
      var swiper = this;

      if (!swiper.params.scrollbar.el) {
        return;
      }

      var scrollbar = swiper.scrollbar;
      var $swiperEl = swiper.$el;
      var params = swiper.params.scrollbar;
      var $el = $(params.el);

      if (swiper.params.uniqueNavElements && typeof params.el === 'string' && $el.length > 1 && $swiperEl.find(params.el).length === 1) {
        $el = $swiperEl.find(params.el);
      }

      var $dragEl = $el.find("." + swiper.params.scrollbar.dragClass);

      if ($dragEl.length === 0) {
        $dragEl = $("<div class=\"" + swiper.params.scrollbar.dragClass + "\"></div>");
        $el.append($dragEl);
      }

      Utils.extend(scrollbar, {
        $el: $el,
        el: $el[0],
        $dragEl: $dragEl,
        dragEl: $dragEl[0]
      });

      if (params.draggable) {
        scrollbar.enableDraggable();
      }
    },
    destroy: function destroy() {
      var swiper = this;
      swiper.scrollbar.disableDraggable();
    }
  };
  var Scrollbar$1 = {
    name: 'scrollbar',
    params: {
      scrollbar: {
        el: null,
        dragSize: 'auto',
        hide: false,
        draggable: false,
        snapOnRelease: true,
        lockClass: 'swiper-scrollbar-lock',
        dragClass: 'swiper-scrollbar-drag'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        scrollbar: {
          init: Scrollbar.init.bind(swiper),
          destroy: Scrollbar.destroy.bind(swiper),
          updateSize: Scrollbar.updateSize.bind(swiper),
          setTranslate: Scrollbar.setTranslate.bind(swiper),
          setTransition: Scrollbar.setTransition.bind(swiper),
          enableDraggable: Scrollbar.enableDraggable.bind(swiper),
          disableDraggable: Scrollbar.disableDraggable.bind(swiper),
          setDragPosition: Scrollbar.setDragPosition.bind(swiper),
          getPointerPosition: Scrollbar.getPointerPosition.bind(swiper),
          onDragStart: Scrollbar.onDragStart.bind(swiper),
          onDragMove: Scrollbar.onDragMove.bind(swiper),
          onDragEnd: Scrollbar.onDragEnd.bind(swiper),
          isTouched: false,
          timeout: null,
          dragTimeout: null
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;
        swiper.scrollbar.init();
        swiper.scrollbar.updateSize();
        swiper.scrollbar.setTranslate();
      },
      update: function update() {
        var swiper = this;
        swiper.scrollbar.updateSize();
      },
      resize: function resize() {
        var swiper = this;
        swiper.scrollbar.updateSize();
      },
      observerUpdate: function observerUpdate() {
        var swiper = this;
        swiper.scrollbar.updateSize();
      },
      setTranslate: function setTranslate() {
        var swiper = this;
        swiper.scrollbar.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;
        swiper.scrollbar.setTransition(duration);
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.scrollbar.destroy();
      }
    }
  };
  var Parallax = {
    setTransform: function setTransform(el, progress) {
      var swiper = this;
      var rtl = swiper.rtl;
      var $el = $(el);
      var rtlFactor = rtl ? -1 : 1;
      var p = $el.attr('data-swiper-parallax') || '0';
      var x = $el.attr('data-swiper-parallax-x');
      var y = $el.attr('data-swiper-parallax-y');
      var scale = $el.attr('data-swiper-parallax-scale');
      var opacity = $el.attr('data-swiper-parallax-opacity');

      if (x || y) {
        x = x || '0';
        y = y || '0';
      } else if (swiper.isHorizontal()) {
        x = p;
        y = '0';
      } else {
        y = p;
        x = '0';
      }

      if (x.indexOf('%') >= 0) {
        x = parseInt(x, 10) * progress * rtlFactor + "%";
      } else {
        x = x * progress * rtlFactor + "px";
      }

      if (y.indexOf('%') >= 0) {
        y = parseInt(y, 10) * progress + "%";
      } else {
        y = y * progress + "px";
      }

      if (typeof opacity !== 'undefined' && opacity !== null) {
        var currentOpacity = opacity - (opacity - 1) * (1 - Math.abs(progress));
        $el[0].style.opacity = currentOpacity;
      }

      if (typeof scale === 'undefined' || scale === null) {
        $el.transform("translate3d(" + x + ", " + y + ", 0px)");
      } else {
        var currentScale = scale - (scale - 1) * (1 - Math.abs(progress));
        $el.transform("translate3d(" + x + ", " + y + ", 0px) scale(" + currentScale + ")");
      }
    },
    setTranslate: function setTranslate() {
      var swiper = this;
      var $el = swiper.$el;
      var slides = swiper.slides;
      var progress = swiper.progress;
      var snapGrid = swiper.snapGrid;
      $el.children('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (index, el) {
        swiper.parallax.setTransform(el, progress);
      });
      slides.each(function (slideIndex, slideEl) {
        var slideProgress = slideEl.progress;

        if (swiper.params.slidesPerGroup > 1 && swiper.params.slidesPerView !== 'auto') {
          slideProgress += Math.ceil(slideIndex / 2) - progress * (snapGrid.length - 1);
        }

        slideProgress = Math.min(Math.max(slideProgress, -1), 1);
        $(slideEl).find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (index, el) {
          swiper.parallax.setTransform(el, slideProgress);
        });
      });
    },
    setTransition: function setTransition(duration) {
      if (duration === void 0) duration = this.params.speed;
      var swiper = this;
      var $el = swiper.$el;
      $el.find('[data-swiper-parallax], [data-swiper-parallax-x], [data-swiper-parallax-y], [data-swiper-parallax-opacity], [data-swiper-parallax-scale]').each(function (index, parallaxEl) {
        var $parallaxEl = $(parallaxEl);
        var parallaxDuration = parseInt($parallaxEl.attr('data-swiper-parallax-duration'), 10) || duration;

        if (duration === 0) {
          parallaxDuration = 0;
        }

        $parallaxEl.transition(parallaxDuration);
      });
    }
  };
  var Parallax$1 = {
    name: 'parallax',
    params: {
      parallax: {
        enabled: false
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        parallax: {
          setTransform: Parallax.setTransform.bind(swiper),
          setTranslate: Parallax.setTranslate.bind(swiper),
          setTransition: Parallax.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (!swiper.params.parallax.enabled) {
          return;
        }

        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      },
      init: function init() {
        var swiper = this;

        if (!swiper.params.parallax.enabled) {
          return;
        }

        swiper.parallax.setTranslate();
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (!swiper.params.parallax.enabled) {
          return;
        }

        swiper.parallax.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (!swiper.params.parallax.enabled) {
          return;
        }

        swiper.parallax.setTransition(duration);
      }
    }
  };
  var Zoom = {
    // Calc Scale From Multi-touches
    getDistanceBetweenTouches: function getDistanceBetweenTouches(e) {
      if (e.targetTouches.length < 2) {
        return 1;
      }

      var x1 = e.targetTouches[0].pageX;
      var y1 = e.targetTouches[0].pageY;
      var x2 = e.targetTouches[1].pageX;
      var y2 = e.targetTouches[1].pageY;
      var distance = Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2));
      return distance;
    },
    // Events
    onGestureStart: function onGestureStart(e) {
      var swiper = this;
      var params = swiper.params.zoom;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;
      zoom.fakeGestureTouched = false;
      zoom.fakeGestureMoved = false;

      if (!Support.gestures) {
        if (e.type !== 'touchstart' || e.type === 'touchstart' && e.targetTouches.length < 2) {
          return;
        }

        zoom.fakeGestureTouched = true;
        gesture.scaleStart = Zoom.getDistanceBetweenTouches(e);
      }

      if (!gesture.$slideEl || !gesture.$slideEl.length) {
        gesture.$slideEl = $(e.target).closest("." + swiper.params.slideClass);

        if (gesture.$slideEl.length === 0) {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }

        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
        gesture.maxRatio = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

        if (gesture.$imageWrapEl.length === 0) {
          gesture.$imageEl = undefined;
          return;
        }
      }

      if (gesture.$imageEl) {
        gesture.$imageEl.transition(0);
      }

      swiper.zoom.isScaling = true;
    },
    onGestureChange: function onGestureChange(e) {
      var swiper = this;
      var params = swiper.params.zoom;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;

      if (!Support.gestures) {
        if (e.type !== 'touchmove' || e.type === 'touchmove' && e.targetTouches.length < 2) {
          return;
        }

        zoom.fakeGestureMoved = true;
        gesture.scaleMove = Zoom.getDistanceBetweenTouches(e);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      if (Support.gestures) {
        zoom.scale = e.scale * zoom.currentScale;
      } else {
        zoom.scale = gesture.scaleMove / gesture.scaleStart * zoom.currentScale;
      }

      if (zoom.scale > gesture.maxRatio) {
        zoom.scale = gesture.maxRatio - 1 + Math.pow(zoom.scale - gesture.maxRatio + 1, 0.5);
      }

      if (zoom.scale < params.minRatio) {
        zoom.scale = params.minRatio + 1 - Math.pow(params.minRatio - zoom.scale + 1, 0.5);
      }

      gesture.$imageEl.transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    onGestureEnd: function onGestureEnd(e) {
      var swiper = this;
      var params = swiper.params.zoom;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;

      if (!Support.gestures) {
        if (!zoom.fakeGestureTouched || !zoom.fakeGestureMoved) {
          return;
        }

        if (e.type !== 'touchend' || e.type === 'touchend' && e.changedTouches.length < 2 && !Device.android) {
          return;
        }

        zoom.fakeGestureTouched = false;
        zoom.fakeGestureMoved = false;
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      zoom.scale = Math.max(Math.min(zoom.scale, gesture.maxRatio), params.minRatio);
      gesture.$imageEl.transition(swiper.params.speed).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
      zoom.currentScale = zoom.scale;
      zoom.isScaling = false;

      if (zoom.scale === 1) {
        gesture.$slideEl = undefined;
      }
    },
    onTouchStart: function onTouchStart(e) {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;
      var image = zoom.image;

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      if (image.isTouched) {
        return;
      }

      if (Device.android) {
        e.preventDefault();
      }

      image.isTouched = true;
      image.touchesStart.x = e.type === 'touchstart' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesStart.y = e.type === 'touchstart' ? e.targetTouches[0].pageY : e.pageY;
    },
    onTouchMove: function onTouchMove(e) {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;
      var image = zoom.image;
      var velocity = zoom.velocity;

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      swiper.allowClick = false;

      if (!image.isTouched || !gesture.$slideEl) {
        return;
      }

      if (!image.isMoved) {
        image.width = gesture.$imageEl[0].offsetWidth;
        image.height = gesture.$imageEl[0].offsetHeight;
        image.startX = Utils.getTranslate(gesture.$imageWrapEl[0], 'x') || 0;
        image.startY = Utils.getTranslate(gesture.$imageWrapEl[0], 'y') || 0;
        gesture.slideWidth = gesture.$slideEl[0].offsetWidth;
        gesture.slideHeight = gesture.$slideEl[0].offsetHeight;
        gesture.$imageWrapEl.transition(0);

        if (swiper.rtl) {
          image.startX = -image.startX;
          image.startY = -image.startY;
        }
      } // Define if we need image drag


      var scaledWidth = image.width * zoom.scale;
      var scaledHeight = image.height * zoom.scale;

      if (scaledWidth < gesture.slideWidth && scaledHeight < gesture.slideHeight) {
        return;
      }

      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.touchesCurrent.x = e.type === 'touchmove' ? e.targetTouches[0].pageX : e.pageX;
      image.touchesCurrent.y = e.type === 'touchmove' ? e.targetTouches[0].pageY : e.pageY;

      if (!image.isMoved && !zoom.isScaling) {
        if (swiper.isHorizontal() && (Math.floor(image.minX) === Math.floor(image.startX) && image.touchesCurrent.x < image.touchesStart.x || Math.floor(image.maxX) === Math.floor(image.startX) && image.touchesCurrent.x > image.touchesStart.x)) {
          image.isTouched = false;
          return;
        }

        if (!swiper.isHorizontal() && (Math.floor(image.minY) === Math.floor(image.startY) && image.touchesCurrent.y < image.touchesStart.y || Math.floor(image.maxY) === Math.floor(image.startY) && image.touchesCurrent.y > image.touchesStart.y)) {
          image.isTouched = false;
          return;
        }
      }

      e.preventDefault();
      e.stopPropagation();
      image.isMoved = true;
      image.currentX = image.touchesCurrent.x - image.touchesStart.x + image.startX;
      image.currentY = image.touchesCurrent.y - image.touchesStart.y + image.startY;

      if (image.currentX < image.minX) {
        image.currentX = image.minX + 1 - Math.pow(image.minX - image.currentX + 1, 0.8);
      }

      if (image.currentX > image.maxX) {
        image.currentX = image.maxX - 1 + Math.pow(image.currentX - image.maxX + 1, 0.8);
      }

      if (image.currentY < image.minY) {
        image.currentY = image.minY + 1 - Math.pow(image.minY - image.currentY + 1, 0.8);
      }

      if (image.currentY > image.maxY) {
        image.currentY = image.maxY - 1 + Math.pow(image.currentY - image.maxY + 1, 0.8);
      } // Velocity


      if (!velocity.prevPositionX) {
        velocity.prevPositionX = image.touchesCurrent.x;
      }

      if (!velocity.prevPositionY) {
        velocity.prevPositionY = image.touchesCurrent.y;
      }

      if (!velocity.prevTime) {
        velocity.prevTime = Date.now();
      }

      velocity.x = (image.touchesCurrent.x - velocity.prevPositionX) / (Date.now() - velocity.prevTime) / 2;
      velocity.y = (image.touchesCurrent.y - velocity.prevPositionY) / (Date.now() - velocity.prevTime) / 2;

      if (Math.abs(image.touchesCurrent.x - velocity.prevPositionX) < 2) {
        velocity.x = 0;
      }

      if (Math.abs(image.touchesCurrent.y - velocity.prevPositionY) < 2) {
        velocity.y = 0;
      }

      velocity.prevPositionX = image.touchesCurrent.x;
      velocity.prevPositionY = image.touchesCurrent.y;
      velocity.prevTime = Date.now();
      gesture.$imageWrapEl.transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTouchEnd: function onTouchEnd() {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;
      var image = zoom.image;
      var velocity = zoom.velocity;

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      if (!image.isTouched || !image.isMoved) {
        image.isTouched = false;
        image.isMoved = false;
        return;
      }

      image.isTouched = false;
      image.isMoved = false;
      var momentumDurationX = 300;
      var momentumDurationY = 300;
      var momentumDistanceX = velocity.x * momentumDurationX;
      var newPositionX = image.currentX + momentumDistanceX;
      var momentumDistanceY = velocity.y * momentumDurationY;
      var newPositionY = image.currentY + momentumDistanceY; // Fix duration

      if (velocity.x !== 0) {
        momentumDurationX = Math.abs((newPositionX - image.currentX) / velocity.x);
      }

      if (velocity.y !== 0) {
        momentumDurationY = Math.abs((newPositionY - image.currentY) / velocity.y);
      }

      var momentumDuration = Math.max(momentumDurationX, momentumDurationY);
      image.currentX = newPositionX;
      image.currentY = newPositionY; // Define if we need image drag

      var scaledWidth = image.width * zoom.scale;
      var scaledHeight = image.height * zoom.scale;
      image.minX = Math.min(gesture.slideWidth / 2 - scaledWidth / 2, 0);
      image.maxX = -image.minX;
      image.minY = Math.min(gesture.slideHeight / 2 - scaledHeight / 2, 0);
      image.maxY = -image.minY;
      image.currentX = Math.max(Math.min(image.currentX, image.maxX), image.minX);
      image.currentY = Math.max(Math.min(image.currentY, image.maxY), image.minY);
      gesture.$imageWrapEl.transition(momentumDuration).transform("translate3d(" + image.currentX + "px, " + image.currentY + "px,0)");
    },
    onTransitionEnd: function onTransitionEnd() {
      var swiper = this;
      var zoom = swiper.zoom;
      var gesture = zoom.gesture;

      if (gesture.$slideEl && swiper.previousIndex !== swiper.activeIndex) {
        if (gesture.$imageEl) {
          gesture.$imageEl.transform('translate3d(0,0,0) scale(1)');
        }

        if (gesture.$imageWrapEl) {
          gesture.$imageWrapEl.transform('translate3d(0,0,0)');
        }

        zoom.scale = 1;
        zoom.currentScale = 1;
        gesture.$slideEl = undefined;
        gesture.$imageEl = undefined;
        gesture.$imageWrapEl = undefined;
      }
    },
    // Toggle Zoom
    toggle: function toggle(e) {
      var swiper = this;
      var zoom = swiper.zoom;

      if (zoom.scale && zoom.scale !== 1) {
        // Zoom Out
        zoom.out();
      } else {
        // Zoom In
        zoom.in(e);
      }
    },
    in: function in$1(e) {
      var swiper = this;
      var zoom = swiper.zoom;
      var params = swiper.params.zoom;
      var gesture = zoom.gesture;
      var image = zoom.image;

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }

        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      gesture.$slideEl.addClass("" + params.zoomedSlideClass);
      var touchX;
      var touchY;
      var offsetX;
      var offsetY;
      var diffX;
      var diffY;
      var translateX;
      var translateY;
      var imageWidth;
      var imageHeight;
      var scaledWidth;
      var scaledHeight;
      var translateMinX;
      var translateMinY;
      var translateMaxX;
      var translateMaxY;
      var slideWidth;
      var slideHeight;

      if (typeof image.touchesStart.x === 'undefined' && e) {
        touchX = e.type === 'touchend' ? e.changedTouches[0].pageX : e.pageX;
        touchY = e.type === 'touchend' ? e.changedTouches[0].pageY : e.pageY;
      } else {
        touchX = image.touchesStart.x;
        touchY = image.touchesStart.y;
      }

      zoom.scale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;
      zoom.currentScale = gesture.$imageWrapEl.attr('data-swiper-zoom') || params.maxRatio;

      if (e) {
        slideWidth = gesture.$slideEl[0].offsetWidth;
        slideHeight = gesture.$slideEl[0].offsetHeight;
        offsetX = gesture.$slideEl.offset().left;
        offsetY = gesture.$slideEl.offset().top;
        diffX = offsetX + slideWidth / 2 - touchX;
        diffY = offsetY + slideHeight / 2 - touchY;
        imageWidth = gesture.$imageEl[0].offsetWidth;
        imageHeight = gesture.$imageEl[0].offsetHeight;
        scaledWidth = imageWidth * zoom.scale;
        scaledHeight = imageHeight * zoom.scale;
        translateMinX = Math.min(slideWidth / 2 - scaledWidth / 2, 0);
        translateMinY = Math.min(slideHeight / 2 - scaledHeight / 2, 0);
        translateMaxX = -translateMinX;
        translateMaxY = -translateMinY;
        translateX = diffX * zoom.scale;
        translateY = diffY * zoom.scale;

        if (translateX < translateMinX) {
          translateX = translateMinX;
        }

        if (translateX > translateMaxX) {
          translateX = translateMaxX;
        }

        if (translateY < translateMinY) {
          translateY = translateMinY;
        }

        if (translateY > translateMaxY) {
          translateY = translateMaxY;
        }
      } else {
        translateX = 0;
        translateY = 0;
      }

      gesture.$imageWrapEl.transition(300).transform("translate3d(" + translateX + "px, " + translateY + "px,0)");
      gesture.$imageEl.transition(300).transform("translate3d(0,0,0) scale(" + zoom.scale + ")");
    },
    out: function out() {
      var swiper = this;
      var zoom = swiper.zoom;
      var params = swiper.params.zoom;
      var gesture = zoom.gesture;

      if (!gesture.$slideEl) {
        if (swiper.params.virtual && swiper.params.virtual.enabled && swiper.virtual) {
          gesture.$slideEl = swiper.$wrapperEl.children("." + swiper.params.slideActiveClass);
        } else {
          gesture.$slideEl = swiper.slides.eq(swiper.activeIndex);
        }

        gesture.$imageEl = gesture.$slideEl.find('img, svg, canvas, picture, .swiper-zoom-target');
        gesture.$imageWrapEl = gesture.$imageEl.parent("." + params.containerClass);
      }

      if (!gesture.$imageEl || gesture.$imageEl.length === 0) {
        return;
      }

      zoom.scale = 1;
      zoom.currentScale = 1;
      gesture.$imageWrapEl.transition(300).transform('translate3d(0,0,0)');
      gesture.$imageEl.transition(300).transform('translate3d(0,0,0) scale(1)');
      gesture.$slideEl.removeClass("" + params.zoomedSlideClass);
      gesture.$slideEl = undefined;
    },
    // Attach/Detach Events
    enable: function enable() {
      var swiper = this;
      var zoom = swiper.zoom;

      if (zoom.enabled) {
        return;
      }

      zoom.enabled = true;
      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      var activeListenerWithCapture = Support.passiveListener ? {
        passive: false,
        capture: true
      } : true;
      var slideSelector = "." + swiper.params.slideClass; // Scale image

      if (Support.gestures) {
        swiper.$wrapperEl.on('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.on('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
        swiper.$wrapperEl.on('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.on(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.on(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
        swiper.$wrapperEl.on(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);

        if (swiper.touchEvents.cancel) {
          swiper.$wrapperEl.on(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
        }
      } // Move image


      swiper.$wrapperEl.on(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
    },
    disable: function disable() {
      var swiper = this;
      var zoom = swiper.zoom;

      if (!zoom.enabled) {
        return;
      }

      swiper.zoom.enabled = false;
      var passiveListener = swiper.touchEvents.start === 'touchstart' && Support.passiveListener && swiper.params.passiveListeners ? {
        passive: true,
        capture: false
      } : false;
      var activeListenerWithCapture = Support.passiveListener ? {
        passive: false,
        capture: true
      } : true;
      var slideSelector = "." + swiper.params.slideClass; // Scale image

      if (Support.gestures) {
        swiper.$wrapperEl.off('gesturestart', slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.off('gesturechange', slideSelector, zoom.onGestureChange, passiveListener);
        swiper.$wrapperEl.off('gestureend', slideSelector, zoom.onGestureEnd, passiveListener);
      } else if (swiper.touchEvents.start === 'touchstart') {
        swiper.$wrapperEl.off(swiper.touchEvents.start, slideSelector, zoom.onGestureStart, passiveListener);
        swiper.$wrapperEl.off(swiper.touchEvents.move, slideSelector, zoom.onGestureChange, activeListenerWithCapture);
        swiper.$wrapperEl.off(swiper.touchEvents.end, slideSelector, zoom.onGestureEnd, passiveListener);

        if (swiper.touchEvents.cancel) {
          swiper.$wrapperEl.off(swiper.touchEvents.cancel, slideSelector, zoom.onGestureEnd, passiveListener);
        }
      } // Move image


      swiper.$wrapperEl.off(swiper.touchEvents.move, "." + swiper.params.zoom.containerClass, zoom.onTouchMove, activeListenerWithCapture);
    }
  };
  var Zoom$1 = {
    name: 'zoom',
    params: {
      zoom: {
        enabled: false,
        maxRatio: 3,
        minRatio: 1,
        toggle: true,
        containerClass: 'swiper-zoom-container',
        zoomedSlideClass: 'swiper-slide-zoomed'
      }
    },
    create: function create() {
      var swiper = this;
      var zoom = {
        enabled: false,
        scale: 1,
        currentScale: 1,
        isScaling: false,
        gesture: {
          $slideEl: undefined,
          slideWidth: undefined,
          slideHeight: undefined,
          $imageEl: undefined,
          $imageWrapEl: undefined,
          maxRatio: 3
        },
        image: {
          isTouched: undefined,
          isMoved: undefined,
          currentX: undefined,
          currentY: undefined,
          minX: undefined,
          minY: undefined,
          maxX: undefined,
          maxY: undefined,
          width: undefined,
          height: undefined,
          startX: undefined,
          startY: undefined,
          touchesStart: {},
          touchesCurrent: {}
        },
        velocity: {
          x: undefined,
          y: undefined,
          prevPositionX: undefined,
          prevPositionY: undefined,
          prevTime: undefined
        }
      };
      'onGestureStart onGestureChange onGestureEnd onTouchStart onTouchMove onTouchEnd onTransitionEnd toggle enable disable in out'.split(' ').forEach(function (methodName) {
        zoom[methodName] = Zoom[methodName].bind(swiper);
      });
      Utils.extend(swiper, {
        zoom: zoom
      });
      var scale = 1;
      Object.defineProperty(swiper.zoom, 'scale', {
        get: function get() {
          return scale;
        },
        set: function set(value) {
          if (scale !== value) {
            var imageEl = swiper.zoom.gesture.$imageEl ? swiper.zoom.gesture.$imageEl[0] : undefined;
            var slideEl = swiper.zoom.gesture.$slideEl ? swiper.zoom.gesture.$slideEl[0] : undefined;
            swiper.emit('zoomChange', value, imageEl, slideEl);
          }

          scale = value;
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.zoom.enabled) {
          swiper.zoom.enable();
        }
      },
      destroy: function destroy() {
        var swiper = this;
        swiper.zoom.disable();
      },
      touchStart: function touchStart(e) {
        var swiper = this;

        if (!swiper.zoom.enabled) {
          return;
        }

        swiper.zoom.onTouchStart(e);
      },
      touchEnd: function touchEnd(e) {
        var swiper = this;

        if (!swiper.zoom.enabled) {
          return;
        }

        swiper.zoom.onTouchEnd(e);
      },
      doubleTap: function doubleTap(e) {
        var swiper = this;

        if (swiper.params.zoom.enabled && swiper.zoom.enabled && swiper.params.zoom.toggle) {
          swiper.zoom.toggle(e);
        }
      },
      transitionEnd: function transitionEnd() {
        var swiper = this;

        if (swiper.zoom.enabled && swiper.params.zoom.enabled) {
          swiper.zoom.onTransitionEnd();
        }
      },
      slideChange: function slideChange() {
        var swiper = this;

        if (swiper.zoom.enabled && swiper.params.zoom.enabled && swiper.params.cssMode) {
          swiper.zoom.onTransitionEnd();
        }
      }
    }
  };
  var Lazy = {
    loadInSlide: function loadInSlide(index, loadInDuplicate) {
      if (loadInDuplicate === void 0) loadInDuplicate = true;
      var swiper = this;
      var params = swiper.params.lazy;

      if (typeof index === 'undefined') {
        return;
      }

      if (swiper.slides.length === 0) {
        return;
      }

      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var $slideEl = isVirtual ? swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-swiper-slide-index=\"" + index + "\"]") : swiper.slides.eq(index);
      var $images = $slideEl.find("." + params.elementClass + ":not(." + params.loadedClass + "):not(." + params.loadingClass + ")");

      if ($slideEl.hasClass(params.elementClass) && !$slideEl.hasClass(params.loadedClass) && !$slideEl.hasClass(params.loadingClass)) {
        $images = $images.add($slideEl[0]);
      }

      if ($images.length === 0) {
        return;
      }

      $images.each(function (imageIndex, imageEl) {
        var $imageEl = $(imageEl);
        $imageEl.addClass(params.loadingClass);
        var background = $imageEl.attr('data-background');
        var src = $imageEl.attr('data-src');
        var srcset = $imageEl.attr('data-srcset');
        var sizes = $imageEl.attr('data-sizes');
        swiper.loadImage($imageEl[0], src || background, srcset, sizes, false, function () {
          if (typeof swiper === 'undefined' || swiper === null || !swiper || swiper && !swiper.params || swiper.destroyed) {
            return;
          }

          if (background) {
            $imageEl.css('background-image', "url(\"" + background + "\")");
            $imageEl.removeAttr('data-background');
          } else {
            if (srcset) {
              $imageEl.attr('srcset', srcset);
              $imageEl.removeAttr('data-srcset');
            }

            if (sizes) {
              $imageEl.attr('sizes', sizes);
              $imageEl.removeAttr('data-sizes');
            }

            if (src) {
              $imageEl.attr('src', src);
              $imageEl.removeAttr('data-src');
            }
          }

          $imageEl.addClass(params.loadedClass).removeClass(params.loadingClass);
          $slideEl.find("." + params.preloaderClass).remove();

          if (swiper.params.loop && loadInDuplicate) {
            var slideOriginalIndex = $slideEl.attr('data-swiper-slide-index');

            if ($slideEl.hasClass(swiper.params.slideDuplicateClass)) {
              var originalSlide = swiper.$wrapperEl.children("[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]:not(." + swiper.params.slideDuplicateClass + ")");
              swiper.lazy.loadInSlide(originalSlide.index(), false);
            } else {
              var duplicatedSlide = swiper.$wrapperEl.children("." + swiper.params.slideDuplicateClass + "[data-swiper-slide-index=\"" + slideOriginalIndex + "\"]");
              swiper.lazy.loadInSlide(duplicatedSlide.index(), false);
            }
          }

          swiper.emit('lazyImageReady', $slideEl[0], $imageEl[0]);

          if (swiper.params.autoHeight) {
            swiper.updateAutoHeight();
          }
        });
        swiper.emit('lazyImageLoad', $slideEl[0], $imageEl[0]);
      });
    },
    load: function load() {
      var swiper = this;
      var $wrapperEl = swiper.$wrapperEl;
      var swiperParams = swiper.params;
      var slides = swiper.slides;
      var activeIndex = swiper.activeIndex;
      var isVirtual = swiper.virtual && swiperParams.virtual.enabled;
      var params = swiperParams.lazy;
      var slidesPerView = swiperParams.slidesPerView;

      if (slidesPerView === 'auto') {
        slidesPerView = 0;
      }

      function slideExist(index) {
        if (isVirtual) {
          if ($wrapperEl.children("." + swiperParams.slideClass + "[data-swiper-slide-index=\"" + index + "\"]").length) {
            return true;
          }
        } else if (slides[index]) {
          return true;
        }

        return false;
      }

      function slideIndex(slideEl) {
        if (isVirtual) {
          return $(slideEl).attr('data-swiper-slide-index');
        }

        return $(slideEl).index();
      }

      if (!swiper.lazy.initialImageLoaded) {
        swiper.lazy.initialImageLoaded = true;
      }

      if (swiper.params.watchSlidesVisibility) {
        $wrapperEl.children("." + swiperParams.slideVisibleClass).each(function (elIndex, slideEl) {
          var index = isVirtual ? $(slideEl).attr('data-swiper-slide-index') : $(slideEl).index();
          swiper.lazy.loadInSlide(index);
        });
      } else if (slidesPerView > 1) {
        for (var i = activeIndex; i < activeIndex + slidesPerView; i += 1) {
          if (slideExist(i)) {
            swiper.lazy.loadInSlide(i);
          }
        }
      } else {
        swiper.lazy.loadInSlide(activeIndex);
      }

      if (params.loadPrevNext) {
        if (slidesPerView > 1 || params.loadPrevNextAmount && params.loadPrevNextAmount > 1) {
          var amount = params.loadPrevNextAmount;
          var spv = slidesPerView;
          var maxIndex = Math.min(activeIndex + spv + Math.max(amount, spv), slides.length);
          var minIndex = Math.max(activeIndex - Math.max(spv, amount), 0); // Next Slides

          for (var i$1 = activeIndex + slidesPerView; i$1 < maxIndex; i$1 += 1) {
            if (slideExist(i$1)) {
              swiper.lazy.loadInSlide(i$1);
            }
          } // Prev Slides


          for (var i$2 = minIndex; i$2 < activeIndex; i$2 += 1) {
            if (slideExist(i$2)) {
              swiper.lazy.loadInSlide(i$2);
            }
          }
        } else {
          var nextSlide = $wrapperEl.children("." + swiperParams.slideNextClass);

          if (nextSlide.length > 0) {
            swiper.lazy.loadInSlide(slideIndex(nextSlide));
          }

          var prevSlide = $wrapperEl.children("." + swiperParams.slidePrevClass);

          if (prevSlide.length > 0) {
            swiper.lazy.loadInSlide(slideIndex(prevSlide));
          }
        }
      }
    }
  };
  var Lazy$1 = {
    name: 'lazy',
    params: {
      lazy: {
        enabled: false,
        loadPrevNext: false,
        loadPrevNextAmount: 1,
        loadOnTransitionStart: false,
        elementClass: 'swiper-lazy',
        loadingClass: 'swiper-lazy-loading',
        loadedClass: 'swiper-lazy-loaded',
        preloaderClass: 'swiper-lazy-preloader'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        lazy: {
          initialImageLoaded: false,
          load: Lazy.load.bind(swiper),
          loadInSlide: Lazy.loadInSlide.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.lazy.enabled && swiper.params.preloadImages) {
          swiper.params.preloadImages = false;
        }
      },
      init: function init() {
        var swiper = this;

        if (swiper.params.lazy.enabled && !swiper.params.loop && swiper.params.initialSlide === 0) {
          swiper.lazy.load();
        }
      },
      scroll: function scroll() {
        var swiper = this;

        if (swiper.params.freeMode && !swiper.params.freeModeSticky) {
          swiper.lazy.load();
        }
      },
      resize: function resize() {
        var swiper = this;

        if (swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      },
      scrollbarDragMove: function scrollbarDragMove() {
        var swiper = this;

        if (swiper.params.lazy.enabled) {
          swiper.lazy.load();
        }
      },
      transitionStart: function transitionStart() {
        var swiper = this;

        if (swiper.params.lazy.enabled) {
          if (swiper.params.lazy.loadOnTransitionStart || !swiper.params.lazy.loadOnTransitionStart && !swiper.lazy.initialImageLoaded) {
            swiper.lazy.load();
          }
        }
      },
      transitionEnd: function transitionEnd() {
        var swiper = this;

        if (swiper.params.lazy.enabled && !swiper.params.lazy.loadOnTransitionStart) {
          swiper.lazy.load();
        }
      },
      slideChange: function slideChange() {
        var swiper = this;

        if (swiper.params.lazy.enabled && swiper.params.cssMode) {
          swiper.lazy.load();
        }
      }
    }
  };
  /* eslint no-bitwise: ["error", { "allow": [">>"] }] */

  var Controller = {
    LinearSpline: function LinearSpline(x, y) {
      var binarySearch = function search() {
        var maxIndex;
        var minIndex;
        var guess;
        return function (array, val) {
          minIndex = -1;
          maxIndex = array.length;

          while (maxIndex - minIndex > 1) {
            guess = maxIndex + minIndex >> 1;

            if (array[guess] <= val) {
              minIndex = guess;
            } else {
              maxIndex = guess;
            }
          }

          return maxIndex;
        };
      }();

      this.x = x;
      this.y = y;
      this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:
      // (x1,y1) is the known point before given value,
      // (x3,y3) is the known point after given value.

      var i1;
      var i3;

      this.interpolate = function interpolate(x2) {
        if (!x2) {
          return 0;
        } // Get the indexes of x1 and x3 (the array indexes before and after given x2):


        i3 = binarySearch(this.x, x2);
        i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:
        // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1

        return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];
      };

      return this;
    },
    // xxx: for now i will just save one spline function to to
    getInterpolateFunction: function getInterpolateFunction(c) {
      var swiper = this;

      if (!swiper.controller.spline) {
        swiper.controller.spline = swiper.params.loop ? new Controller.LinearSpline(swiper.slidesGrid, c.slidesGrid) : new Controller.LinearSpline(swiper.snapGrid, c.snapGrid);
      }
    },
    setTranslate: function setTranslate(setTranslate$1, byController) {
      var swiper = this;
      var controlled = swiper.controller.control;
      var multiplier;
      var controlledTranslate;

      function setControlledTranslate(c) {
        // this will create an Interpolate function based on the snapGrids
        // x is the Grid of the scrolled scroller and y will be the controlled scroller
        // it makes sense to create this only once and recall it for the interpolation
        // the function does a lot of value caching for performance
        var translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;

        if (swiper.params.controller.by === 'slide') {
          swiper.controller.getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid
          // but it did not work out

          controlledTranslate = -swiper.controller.spline.interpolate(-translate);
        }

        if (!controlledTranslate || swiper.params.controller.by === 'container') {
          multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());
          controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();
        }

        if (swiper.params.controller.inverse) {
          controlledTranslate = c.maxTranslate() - controlledTranslate;
        }

        c.updateProgress(controlledTranslate);
        c.setTranslate(controlledTranslate, swiper);
        c.updateActiveIndex();
        c.updateSlidesClasses();
      }

      if (Array.isArray(controlled)) {
        for (var i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTranslate(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTranslate(controlled);
      }
    },
    setTransition: function setTransition(duration, byController) {
      var swiper = this;
      var controlled = swiper.controller.control;
      var i;

      function setControlledTransition(c) {
        c.setTransition(duration, swiper);

        if (duration !== 0) {
          c.transitionStart();

          if (c.params.autoHeight) {
            Utils.nextTick(function () {
              c.updateAutoHeight();
            });
          }

          c.$wrapperEl.transitionEnd(function () {
            if (!controlled) {
              return;
            }

            if (c.params.loop && swiper.params.controller.by === 'slide') {
              c.loopFix();
            }

            c.transitionEnd();
          });
        }
      }

      if (Array.isArray(controlled)) {
        for (i = 0; i < controlled.length; i += 1) {
          if (controlled[i] !== byController && controlled[i] instanceof Swiper) {
            setControlledTransition(controlled[i]);
          }
        }
      } else if (controlled instanceof Swiper && byController !== controlled) {
        setControlledTransition(controlled);
      }
    }
  };
  var Controller$1 = {
    name: 'controller',
    params: {
      controller: {
        control: undefined,
        inverse: false,
        by: 'slide' // or 'container'

      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        controller: {
          control: swiper.params.controller.control,
          getInterpolateFunction: Controller.getInterpolateFunction.bind(swiper),
          setTranslate: Controller.setTranslate.bind(swiper),
          setTransition: Controller.setTransition.bind(swiper)
        }
      });
    },
    on: {
      update: function update() {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      resize: function resize() {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      observerUpdate: function observerUpdate() {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        if (swiper.controller.spline) {
          swiper.controller.spline = undefined;
          delete swiper.controller.spline;
        }
      },
      setTranslate: function setTranslate(translate, byController) {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        swiper.controller.setTranslate(translate, byController);
      },
      setTransition: function setTransition(duration, byController) {
        var swiper = this;

        if (!swiper.controller.control) {
          return;
        }

        swiper.controller.setTransition(duration, byController);
      }
    }
  };
  var a11y = {
    makeElFocusable: function makeElFocusable($el) {
      $el.attr('tabIndex', '0');
      return $el;
    },
    addElRole: function addElRole($el, role) {
      $el.attr('role', role);
      return $el;
    },
    addElLabel: function addElLabel($el, label) {
      $el.attr('aria-label', label);
      return $el;
    },
    disableEl: function disableEl($el) {
      $el.attr('aria-disabled', true);
      return $el;
    },
    enableEl: function enableEl($el) {
      $el.attr('aria-disabled', false);
      return $el;
    },
    onEnterKey: function onEnterKey(e) {
      var swiper = this;
      var params = swiper.params.a11y;

      if (e.keyCode !== 13) {
        return;
      }

      var $targetEl = $(e.target);

      if (swiper.navigation && swiper.navigation.$nextEl && $targetEl.is(swiper.navigation.$nextEl)) {
        if (!(swiper.isEnd && !swiper.params.loop)) {
          swiper.slideNext();
        }

        if (swiper.isEnd) {
          swiper.a11y.notify(params.lastSlideMessage);
        } else {
          swiper.a11y.notify(params.nextSlideMessage);
        }
      }

      if (swiper.navigation && swiper.navigation.$prevEl && $targetEl.is(swiper.navigation.$prevEl)) {
        if (!(swiper.isBeginning && !swiper.params.loop)) {
          swiper.slidePrev();
        }

        if (swiper.isBeginning) {
          swiper.a11y.notify(params.firstSlideMessage);
        } else {
          swiper.a11y.notify(params.prevSlideMessage);
        }
      }

      if (swiper.pagination && $targetEl.is("." + swiper.params.pagination.bulletClass)) {
        $targetEl[0].click();
      }
    },
    notify: function notify(message) {
      var swiper = this;
      var notification = swiper.a11y.liveRegion;

      if (notification.length === 0) {
        return;
      }

      notification.html('');
      notification.html(message);
    },
    updateNavigation: function updateNavigation() {
      var swiper = this;

      if (swiper.params.loop || !swiper.navigation) {
        return;
      }

      var ref = swiper.navigation;
      var $nextEl = ref.$nextEl;
      var $prevEl = ref.$prevEl;

      if ($prevEl && $prevEl.length > 0) {
        if (swiper.isBeginning) {
          swiper.a11y.disableEl($prevEl);
        } else {
          swiper.a11y.enableEl($prevEl);
        }
      }

      if ($nextEl && $nextEl.length > 0) {
        if (swiper.isEnd) {
          swiper.a11y.disableEl($nextEl);
        } else {
          swiper.a11y.enableEl($nextEl);
        }
      }
    },
    updatePagination: function updatePagination() {
      var swiper = this;
      var params = swiper.params.a11y;

      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.bullets.each(function (bulletIndex, bulletEl) {
          var $bulletEl = $(bulletEl);
          swiper.a11y.makeElFocusable($bulletEl);
          swiper.a11y.addElRole($bulletEl, 'button');
          swiper.a11y.addElLabel($bulletEl, params.paginationBulletMessage.replace(/{{index}}/, $bulletEl.index() + 1));
        });
      }
    },
    init: function init() {
      var swiper = this;
      swiper.$el.append(swiper.a11y.liveRegion); // Navigation

      var params = swiper.params.a11y;
      var $nextEl;
      var $prevEl;

      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }

      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }

      if ($nextEl) {
        swiper.a11y.makeElFocusable($nextEl);
        swiper.a11y.addElRole($nextEl, 'button');
        swiper.a11y.addElLabel($nextEl, params.nextSlideMessage);
        $nextEl.on('keydown', swiper.a11y.onEnterKey);
      }

      if ($prevEl) {
        swiper.a11y.makeElFocusable($prevEl);
        swiper.a11y.addElRole($prevEl, 'button');
        swiper.a11y.addElLabel($prevEl, params.prevSlideMessage);
        $prevEl.on('keydown', swiper.a11y.onEnterKey);
      } // Pagination


      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.$el.on('keydown', "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
      }
    },
    destroy: function destroy() {
      var swiper = this;

      if (swiper.a11y.liveRegion && swiper.a11y.liveRegion.length > 0) {
        swiper.a11y.liveRegion.remove();
      }

      var $nextEl;
      var $prevEl;

      if (swiper.navigation && swiper.navigation.$nextEl) {
        $nextEl = swiper.navigation.$nextEl;
      }

      if (swiper.navigation && swiper.navigation.$prevEl) {
        $prevEl = swiper.navigation.$prevEl;
      }

      if ($nextEl) {
        $nextEl.off('keydown', swiper.a11y.onEnterKey);
      }

      if ($prevEl) {
        $prevEl.off('keydown', swiper.a11y.onEnterKey);
      } // Pagination


      if (swiper.pagination && swiper.params.pagination.clickable && swiper.pagination.bullets && swiper.pagination.bullets.length) {
        swiper.pagination.$el.off('keydown', "." + swiper.params.pagination.bulletClass, swiper.a11y.onEnterKey);
      }
    }
  };
  var A11y = {
    name: 'a11y',
    params: {
      a11y: {
        enabled: true,
        notificationClass: 'swiper-notification',
        prevSlideMessage: 'Previous slide',
        nextSlideMessage: 'Next slide',
        firstSlideMessage: 'This is the first slide',
        lastSlideMessage: 'This is the last slide',
        paginationBulletMessage: 'Go to slide {{index}}'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        a11y: {
          liveRegion: $("<span class=\"" + swiper.params.a11y.notificationClass + "\" aria-live=\"assertive\" aria-atomic=\"true\"></span>")
        }
      });
      Object.keys(a11y).forEach(function (methodName) {
        swiper.a11y[methodName] = a11y[methodName].bind(swiper);
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.init();
        swiper.a11y.updateNavigation();
      },
      toEdge: function toEdge() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.updateNavigation();
      },
      fromEdge: function fromEdge() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.updateNavigation();
      },
      paginationUpdate: function paginationUpdate() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.updatePagination();
      },
      destroy: function destroy() {
        var swiper = this;

        if (!swiper.params.a11y.enabled) {
          return;
        }

        swiper.a11y.destroy();
      }
    }
  };
  var History = {
    init: function init() {
      var swiper = this;

      if (!swiper.params.history) {
        return;
      }

      if (!win.history || !win.history.pushState) {
        swiper.params.history.enabled = false;
        swiper.params.hashNavigation.enabled = true;
        return;
      }

      var history = swiper.history;
      history.initialized = true;
      history.paths = History.getPathValues();

      if (!history.paths.key && !history.paths.value) {
        return;
      }

      history.scrollToSlide(0, history.paths.value, swiper.params.runCallbacksOnInit);

      if (!swiper.params.history.replaceState) {
        win.addEventListener('popstate', swiper.history.setHistoryPopState);
      }
    },
    destroy: function destroy() {
      var swiper = this;

      if (!swiper.params.history.replaceState) {
        win.removeEventListener('popstate', swiper.history.setHistoryPopState);
      }
    },
    setHistoryPopState: function setHistoryPopState() {
      var swiper = this;
      swiper.history.paths = History.getPathValues();
      swiper.history.scrollToSlide(swiper.params.speed, swiper.history.paths.value, false);
    },
    getPathValues: function getPathValues() {
      var pathArray = win.location.pathname.slice(1).split('/').filter(function (part) {
        return part !== '';
      });
      var total = pathArray.length;
      var key = pathArray[total - 2];
      var value = pathArray[total - 1];
      return {
        key: key,
        value: value
      };
    },
    setHistory: function setHistory(key, index) {
      var swiper = this;

      if (!swiper.history.initialized || !swiper.params.history.enabled) {
        return;
      }

      var slide = swiper.slides.eq(index);
      var value = History.slugify(slide.attr('data-history'));

      if (!win.location.pathname.includes(key)) {
        value = key + "/" + value;
      }

      var currentState = win.history.state;

      if (currentState && currentState.value === value) {
        return;
      }

      if (swiper.params.history.replaceState) {
        win.history.replaceState({
          value: value
        }, null, value);
      } else {
        win.history.pushState({
          value: value
        }, null, value);
      }
    },
    slugify: function slugify(text) {
      return text.toString().replace(/\s+/g, '-').replace(/[^\w-]+/g, '').replace(/--+/g, '-').replace(/^-+/, '').replace(/-+$/, '');
    },
    scrollToSlide: function scrollToSlide(speed, value, runCallbacks) {
      var swiper = this;

      if (value) {
        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
          var slide = swiper.slides.eq(i);
          var slideHistory = History.slugify(slide.attr('data-history'));

          if (slideHistory === value && !slide.hasClass(swiper.params.slideDuplicateClass)) {
            var index = slide.index();
            swiper.slideTo(index, speed, runCallbacks);
          }
        }
      } else {
        swiper.slideTo(0, speed, runCallbacks);
      }
    }
  };
  var History$1 = {
    name: 'history',
    params: {
      history: {
        enabled: false,
        replaceState: false,
        key: 'slides'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        history: {
          init: History.init.bind(swiper),
          setHistory: History.setHistory.bind(swiper),
          setHistoryPopState: History.setHistoryPopState.bind(swiper),
          scrollToSlide: History.scrollToSlide.bind(swiper),
          destroy: History.destroy.bind(swiper)
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.history.enabled) {
          swiper.history.init();
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.params.history.enabled) {
          swiper.history.destroy();
        }
      },
      transitionEnd: function transitionEnd() {
        var swiper = this;

        if (swiper.history.initialized) {
          swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      },
      slideChange: function slideChange() {
        var swiper = this;

        if (swiper.history.initialized && swiper.params.cssMode) {
          swiper.history.setHistory(swiper.params.history.key, swiper.activeIndex);
        }
      }
    }
  };
  var HashNavigation = {
    onHashCange: function onHashCange() {
      var swiper = this;
      var newHash = doc.location.hash.replace('#', '');
      var activeSlideHash = swiper.slides.eq(swiper.activeIndex).attr('data-hash');

      if (newHash !== activeSlideHash) {
        var newIndex = swiper.$wrapperEl.children("." + swiper.params.slideClass + "[data-hash=\"" + newHash + "\"]").index();

        if (typeof newIndex === 'undefined') {
          return;
        }

        swiper.slideTo(newIndex);
      }
    },
    setHash: function setHash() {
      var swiper = this;

      if (!swiper.hashNavigation.initialized || !swiper.params.hashNavigation.enabled) {
        return;
      }

      if (swiper.params.hashNavigation.replaceState && win.history && win.history.replaceState) {
        win.history.replaceState(null, null, "#" + swiper.slides.eq(swiper.activeIndex).attr('data-hash') || '');
      } else {
        var slide = swiper.slides.eq(swiper.activeIndex);
        var hash = slide.attr('data-hash') || slide.attr('data-history');
        doc.location.hash = hash || '';
      }
    },
    init: function init() {
      var swiper = this;

      if (!swiper.params.hashNavigation.enabled || swiper.params.history && swiper.params.history.enabled) {
        return;
      }

      swiper.hashNavigation.initialized = true;
      var hash = doc.location.hash.replace('#', '');

      if (hash) {
        var speed = 0;

        for (var i = 0, length = swiper.slides.length; i < length; i += 1) {
          var slide = swiper.slides.eq(i);
          var slideHash = slide.attr('data-hash') || slide.attr('data-history');

          if (slideHash === hash && !slide.hasClass(swiper.params.slideDuplicateClass)) {
            var index = slide.index();
            swiper.slideTo(index, speed, swiper.params.runCallbacksOnInit, true);
          }
        }
      }

      if (swiper.params.hashNavigation.watchState) {
        $(win).on('hashchange', swiper.hashNavigation.onHashCange);
      }
    },
    destroy: function destroy() {
      var swiper = this;

      if (swiper.params.hashNavigation.watchState) {
        $(win).off('hashchange', swiper.hashNavigation.onHashCange);
      }
    }
  };
  var HashNavigation$1 = {
    name: 'hash-navigation',
    params: {
      hashNavigation: {
        enabled: false,
        replaceState: false,
        watchState: false
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        hashNavigation: {
          initialized: false,
          init: HashNavigation.init.bind(swiper),
          destroy: HashNavigation.destroy.bind(swiper),
          setHash: HashNavigation.setHash.bind(swiper),
          onHashCange: HashNavigation.onHashCange.bind(swiper)
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.hashNavigation.enabled) {
          swiper.hashNavigation.init();
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.params.hashNavigation.enabled) {
          swiper.hashNavigation.destroy();
        }
      },
      transitionEnd: function transitionEnd() {
        var swiper = this;

        if (swiper.hashNavigation.initialized) {
          swiper.hashNavigation.setHash();
        }
      },
      slideChange: function slideChange() {
        var swiper = this;

        if (swiper.hashNavigation.initialized && swiper.params.cssMode) {
          swiper.hashNavigation.setHash();
        }
      }
    }
  };
  /* eslint no-underscore-dangle: "off" */

  var Autoplay = {
    run: function run() {
      var swiper = this;
      var $activeSlideEl = swiper.slides.eq(swiper.activeIndex);
      var delay = swiper.params.autoplay.delay;

      if ($activeSlideEl.attr('data-swiper-autoplay')) {
        delay = $activeSlideEl.attr('data-swiper-autoplay') || swiper.params.autoplay.delay;
      }

      clearTimeout(swiper.autoplay.timeout);
      swiper.autoplay.timeout = Utils.nextTick(function () {
        if (swiper.params.autoplay.reverseDirection) {
          if (swiper.params.loop) {
            swiper.loopFix();
            swiper.slidePrev(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.isBeginning) {
            swiper.slidePrev(swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else if (!swiper.params.autoplay.stopOnLastSlide) {
            swiper.slideTo(swiper.slides.length - 1, swiper.params.speed, true, true);
            swiper.emit('autoplay');
          } else {
            swiper.autoplay.stop();
          }
        } else if (swiper.params.loop) {
          swiper.loopFix();
          swiper.slideNext(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.isEnd) {
          swiper.slideNext(swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else if (!swiper.params.autoplay.stopOnLastSlide) {
          swiper.slideTo(0, swiper.params.speed, true, true);
          swiper.emit('autoplay');
        } else {
          swiper.autoplay.stop();
        }

        if (swiper.params.cssMode && swiper.autoplay.running) {
          swiper.autoplay.run();
        }
      }, delay);
    },
    start: function start() {
      var swiper = this;

      if (typeof swiper.autoplay.timeout !== 'undefined') {
        return false;
      }

      if (swiper.autoplay.running) {
        return false;
      }

      swiper.autoplay.running = true;
      swiper.emit('autoplayStart');
      swiper.autoplay.run();
      return true;
    },
    stop: function stop() {
      var swiper = this;

      if (!swiper.autoplay.running) {
        return false;
      }

      if (typeof swiper.autoplay.timeout === 'undefined') {
        return false;
      }

      if (swiper.autoplay.timeout) {
        clearTimeout(swiper.autoplay.timeout);
        swiper.autoplay.timeout = undefined;
      }

      swiper.autoplay.running = false;
      swiper.emit('autoplayStop');
      return true;
    },
    pause: function pause(speed) {
      var swiper = this;

      if (!swiper.autoplay.running) {
        return;
      }

      if (swiper.autoplay.paused) {
        return;
      }

      if (swiper.autoplay.timeout) {
        clearTimeout(swiper.autoplay.timeout);
      }

      swiper.autoplay.paused = true;

      if (speed === 0 || !swiper.params.autoplay.waitForTransition) {
        swiper.autoplay.paused = false;
        swiper.autoplay.run();
      } else {
        swiper.$wrapperEl[0].addEventListener('transitionend', swiper.autoplay.onTransitionEnd);
        swiper.$wrapperEl[0].addEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
      }
    }
  };
  var Autoplay$1 = {
    name: 'autoplay',
    params: {
      autoplay: {
        enabled: false,
        delay: 3000,
        waitForTransition: true,
        disableOnInteraction: true,
        stopOnLastSlide: false,
        reverseDirection: false
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        autoplay: {
          running: false,
          paused: false,
          run: Autoplay.run.bind(swiper),
          start: Autoplay.start.bind(swiper),
          stop: Autoplay.stop.bind(swiper),
          pause: Autoplay.pause.bind(swiper),
          onVisibilityChange: function onVisibilityChange() {
            if (document.visibilityState === 'hidden' && swiper.autoplay.running) {
              swiper.autoplay.pause();
            }

            if (document.visibilityState === 'visible' && swiper.autoplay.paused) {
              swiper.autoplay.run();
              swiper.autoplay.paused = false;
            }
          },
          onTransitionEnd: function onTransitionEnd(e) {
            if (!swiper || swiper.destroyed || !swiper.$wrapperEl) {
              return;
            }

            if (e.target !== this) {
              return;
            }

            swiper.$wrapperEl[0].removeEventListener('transitionend', swiper.autoplay.onTransitionEnd);
            swiper.$wrapperEl[0].removeEventListener('webkitTransitionEnd', swiper.autoplay.onTransitionEnd);
            swiper.autoplay.paused = false;

            if (!swiper.autoplay.running) {
              swiper.autoplay.stop();
            } else {
              swiper.autoplay.run();
            }
          }
        }
      });
    },
    on: {
      init: function init() {
        var swiper = this;

        if (swiper.params.autoplay.enabled) {
          swiper.autoplay.start();
          document.addEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
        }
      },
      beforeTransitionStart: function beforeTransitionStart(speed, internal) {
        var swiper = this;

        if (swiper.autoplay.running) {
          if (internal || !swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.pause(speed);
          } else {
            swiper.autoplay.stop();
          }
        }
      },
      sliderFirstMove: function sliderFirstMove() {
        var swiper = this;

        if (swiper.autoplay.running) {
          if (swiper.params.autoplay.disableOnInteraction) {
            swiper.autoplay.stop();
          } else {
            swiper.autoplay.pause();
          }
        }
      },
      touchEnd: function touchEnd() {
        var swiper = this;

        if (swiper.params.cssMode && swiper.autoplay.paused && !swiper.params.autoplay.disableOnInteraction) {
          swiper.autoplay.run();
        }
      },
      destroy: function destroy() {
        var swiper = this;

        if (swiper.autoplay.running) {
          swiper.autoplay.stop();
        }

        document.removeEventListener('visibilitychange', swiper.autoplay.onVisibilityChange);
      }
    }
  };
  var Fade = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var slides = swiper.slides;

      for (var i = 0; i < slides.length; i += 1) {
        var $slideEl = swiper.slides.eq(i);
        var offset = $slideEl[0].swiperSlideOffset;
        var tx = -offset;

        if (!swiper.params.virtualTranslate) {
          tx -= swiper.translate;
        }

        var ty = 0;

        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
        }

        var slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);
        $slideEl.css({
          opacity: slideOpacity
        }).transform("translate3d(" + tx + "px, " + ty + "px, 0px)");
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      var slides = swiper.slides;
      var $wrapperEl = swiper.$wrapperEl;
      slides.transition(duration);

      if (swiper.params.virtualTranslate && duration !== 0) {
        var eventTriggered = false;
        slides.transitionEnd(function () {
          if (eventTriggered) {
            return;
          }

          if (!swiper || swiper.destroyed) {
            return;
          }

          eventTriggered = true;
          swiper.animating = false;
          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

          for (var i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    }
  };
  var EffectFade = {
    name: 'effect-fade',
    params: {
      fadeEffect: {
        crossFade: false
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        fadeEffect: {
          setTranslate: Fade.setTranslate.bind(swiper),
          setTransition: Fade.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.effect !== 'fade') {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "fade");
        var overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: true
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (swiper.params.effect !== 'fade') {
          return;
        }

        swiper.fadeEffect.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (swiper.params.effect !== 'fade') {
          return;
        }

        swiper.fadeEffect.setTransition(duration);
      }
    }
  };
  var Cube = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var $el = swiper.$el;
      var $wrapperEl = swiper.$wrapperEl;
      var slides = swiper.slides;
      var swiperWidth = swiper.width;
      var swiperHeight = swiper.height;
      var rtl = swiper.rtlTranslate;
      var swiperSize = swiper.size;
      var params = swiper.params.cubeEffect;
      var isHorizontal = swiper.isHorizontal();
      var isVirtual = swiper.virtual && swiper.params.virtual.enabled;
      var wrapperRotate = 0;
      var $cubeShadowEl;

      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl = $wrapperEl.find('.swiper-cube-shadow');

          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $wrapperEl.append($cubeShadowEl);
          }

          $cubeShadowEl.css({
            height: swiperWidth + "px"
          });
        } else {
          $cubeShadowEl = $el.find('.swiper-cube-shadow');

          if ($cubeShadowEl.length === 0) {
            $cubeShadowEl = $('<div class="swiper-cube-shadow"></div>');
            $el.append($cubeShadowEl);
          }
        }
      }

      for (var i = 0; i < slides.length; i += 1) {
        var $slideEl = slides.eq(i);
        var slideIndex = i;

        if (isVirtual) {
          slideIndex = parseInt($slideEl.attr('data-swiper-slide-index'), 10);
        }

        var slideAngle = slideIndex * 90;
        var round = Math.floor(slideAngle / 360);

        if (rtl) {
          slideAngle = -slideAngle;
          round = Math.floor(-slideAngle / 360);
        }

        var progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        var tx = 0;
        var ty = 0;
        var tz = 0;

        if (slideIndex % 4 === 0) {
          tx = -round * 4 * swiperSize;
          tz = 0;
        } else if ((slideIndex - 1) % 4 === 0) {
          tx = 0;
          tz = -round * 4 * swiperSize;
        } else if ((slideIndex - 2) % 4 === 0) {
          tx = swiperSize + round * 4 * swiperSize;
          tz = swiperSize;
        } else if ((slideIndex - 3) % 4 === 0) {
          tx = -swiperSize;
          tz = 3 * swiperSize + swiperSize * 4 * round;
        }

        if (rtl) {
          tx = -tx;
        }

        if (!isHorizontal) {
          ty = tx;
          tx = 0;
        }

        var transform = "rotateX(" + (isHorizontal ? 0 : -slideAngle) + "deg) rotateY(" + (isHorizontal ? slideAngle : 0) + "deg) translate3d(" + tx + "px, " + ty + "px, " + tz + "px)";

        if (progress <= 1 && progress > -1) {
          wrapperRotate = slideIndex * 90 + progress * 90;

          if (rtl) {
            wrapperRotate = -slideIndex * 90 - progress * 90;
          }
        }

        $slideEl.transform(transform);

        if (params.slideShadows) {
          // Set shadows
          var shadowBefore = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          var shadowAfter = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if (shadowBefore.length === 0) {
            shadowBefore = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
            $slideEl.append(shadowBefore);
          }

          if (shadowAfter.length === 0) {
            shadowAfter = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
            $slideEl.append(shadowAfter);
          }

          if (shadowBefore.length) {
            shadowBefore[0].style.opacity = Math.max(-progress, 0);
          }

          if (shadowAfter.length) {
            shadowAfter[0].style.opacity = Math.max(progress, 0);
          }
        }
      }

      $wrapperEl.css({
        '-webkit-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
        '-moz-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
        '-ms-transform-origin': "50% 50% -" + swiperSize / 2 + "px",
        'transform-origin': "50% 50% -" + swiperSize / 2 + "px"
      });

      if (params.shadow) {
        if (isHorizontal) {
          $cubeShadowEl.transform("translate3d(0px, " + (swiperWidth / 2 + params.shadowOffset) + "px, " + -swiperWidth / 2 + "px) rotateX(90deg) rotateZ(0deg) scale(" + params.shadowScale + ")");
        } else {
          var shadowAngle = Math.abs(wrapperRotate) - Math.floor(Math.abs(wrapperRotate) / 90) * 90;
          var multiplier = 1.5 - (Math.sin(shadowAngle * 2 * Math.PI / 360) / 2 + Math.cos(shadowAngle * 2 * Math.PI / 360) / 2);
          var scale1 = params.shadowScale;
          var scale2 = params.shadowScale / multiplier;
          var offset = params.shadowOffset;
          $cubeShadowEl.transform("scale3d(" + scale1 + ", 1, " + scale2 + ") translate3d(0px, " + (swiperHeight / 2 + offset) + "px, " + -swiperHeight / 2 / scale2 + "px) rotateX(-90deg)");
        }
      }

      var zFactor = Browser.isSafari || Browser.isUiWebView ? -swiperSize / 2 : 0;
      $wrapperEl.transform("translate3d(0px,0," + zFactor + "px) rotateX(" + (swiper.isHorizontal() ? 0 : wrapperRotate) + "deg) rotateY(" + (swiper.isHorizontal() ? -wrapperRotate : 0) + "deg)");
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      var $el = swiper.$el;
      var slides = swiper.slides;
      slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

      if (swiper.params.cubeEffect.shadow && !swiper.isHorizontal()) {
        $el.find('.swiper-cube-shadow').transition(duration);
      }
    }
  };
  var EffectCube = {
    name: 'effect-cube',
    params: {
      cubeEffect: {
        slideShadows: true,
        shadow: true,
        shadowOffset: 20,
        shadowScale: 0.94
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        cubeEffect: {
          setTranslate: Cube.setTranslate.bind(swiper),
          setTransition: Cube.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.effect !== 'cube') {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "cube");
        swiper.classNames.push(swiper.params.containerModifierClass + "3d");
        var overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          resistanceRatio: 0,
          spaceBetween: 0,
          centeredSlides: false,
          virtualTranslate: true
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (swiper.params.effect !== 'cube') {
          return;
        }

        swiper.cubeEffect.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (swiper.params.effect !== 'cube') {
          return;
        }

        swiper.cubeEffect.setTransition(duration);
      }
    }
  };
  var Flip = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var slides = swiper.slides;
      var rtl = swiper.rtlTranslate;

      for (var i = 0; i < slides.length; i += 1) {
        var $slideEl = slides.eq(i);
        var progress = $slideEl[0].progress;

        if (swiper.params.flipEffect.limitRotation) {
          progress = Math.max(Math.min($slideEl[0].progress, 1), -1);
        }

        var offset = $slideEl[0].swiperSlideOffset;
        var rotate = -180 * progress;
        var rotateY = rotate;
        var rotateX = 0;
        var tx = -offset;
        var ty = 0;

        if (!swiper.isHorizontal()) {
          ty = tx;
          tx = 0;
          rotateX = -rotateY;
          rotateY = 0;
        } else if (rtl) {
          rotateY = -rotateY;
        }

        $slideEl[0].style.zIndex = -Math.abs(Math.round(progress)) + slides.length;

        if (swiper.params.flipEffect.slideShadows) {
          // Set shadows
          var shadowBefore = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          var shadowAfter = swiper.isHorizontal() ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if (shadowBefore.length === 0) {
            shadowBefore = $("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'left' : 'top') + "\"></div>");
            $slideEl.append(shadowBefore);
          }

          if (shadowAfter.length === 0) {
            shadowAfter = $("<div class=\"swiper-slide-shadow-" + (swiper.isHorizontal() ? 'right' : 'bottom') + "\"></div>");
            $slideEl.append(shadowAfter);
          }

          if (shadowBefore.length) {
            shadowBefore[0].style.opacity = Math.max(-progress, 0);
          }

          if (shadowAfter.length) {
            shadowAfter[0].style.opacity = Math.max(progress, 0);
          }
        }

        $slideEl.transform("translate3d(" + tx + "px, " + ty + "px, 0px) rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)");
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      var slides = swiper.slides;
      var activeIndex = swiper.activeIndex;
      var $wrapperEl = swiper.$wrapperEl;
      slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);

      if (swiper.params.virtualTranslate && duration !== 0) {
        var eventTriggered = false; // eslint-disable-next-line

        slides.eq(activeIndex).transitionEnd(function onTransitionEnd() {
          if (eventTriggered) {
            return;
          }

          if (!swiper || swiper.destroyed) {
            return;
          } // if (!$(this).hasClass(swiper.params.slideActiveClass)) return;


          eventTriggered = true;
          swiper.animating = false;
          var triggerEvents = ['webkitTransitionEnd', 'transitionend'];

          for (var i = 0; i < triggerEvents.length; i += 1) {
            $wrapperEl.trigger(triggerEvents[i]);
          }
        });
      }
    }
  };
  var EffectFlip = {
    name: 'effect-flip',
    params: {
      flipEffect: {
        slideShadows: true,
        limitRotation: true
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        flipEffect: {
          setTranslate: Flip.setTranslate.bind(swiper),
          setTransition: Flip.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.effect !== 'flip') {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "flip");
        swiper.classNames.push(swiper.params.containerModifierClass + "3d");
        var overwriteParams = {
          slidesPerView: 1,
          slidesPerColumn: 1,
          slidesPerGroup: 1,
          watchSlidesProgress: true,
          spaceBetween: 0,
          virtualTranslate: true
        };
        Utils.extend(swiper.params, overwriteParams);
        Utils.extend(swiper.originalParams, overwriteParams);
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (swiper.params.effect !== 'flip') {
          return;
        }

        swiper.flipEffect.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (swiper.params.effect !== 'flip') {
          return;
        }

        swiper.flipEffect.setTransition(duration);
      }
    }
  };
  var Coverflow = {
    setTranslate: function setTranslate() {
      var swiper = this;
      var swiperWidth = swiper.width;
      var swiperHeight = swiper.height;
      var slides = swiper.slides;
      var $wrapperEl = swiper.$wrapperEl;
      var slidesSizesGrid = swiper.slidesSizesGrid;
      var params = swiper.params.coverflowEffect;
      var isHorizontal = swiper.isHorizontal();
      var transform = swiper.translate;
      var center = isHorizontal ? -transform + swiperWidth / 2 : -transform + swiperHeight / 2;
      var rotate = isHorizontal ? params.rotate : -params.rotate;
      var translate = params.depth; // Each slide offset from center

      for (var i = 0, length = slides.length; i < length; i += 1) {
        var $slideEl = slides.eq(i);
        var slideSize = slidesSizesGrid[i];
        var slideOffset = $slideEl[0].swiperSlideOffset;
        var offsetMultiplier = (center - slideOffset - slideSize / 2) / slideSize * params.modifier;
        var rotateY = isHorizontal ? rotate * offsetMultiplier : 0;
        var rotateX = isHorizontal ? 0 : rotate * offsetMultiplier; // var rotateZ = 0

        var translateZ = -translate * Math.abs(offsetMultiplier);
        var stretch = params.stretch; // Allow percentage to make a relative stretch for responsive sliders

        if (typeof stretch === 'string' && stretch.indexOf('%') !== -1) {
          stretch = parseFloat(params.stretch) / 100 * slideSize;
        }

        var translateY = isHorizontal ? 0 : stretch * offsetMultiplier;
        var translateX = isHorizontal ? stretch * offsetMultiplier : 0; // Fix for ultra small values

        if (Math.abs(translateX) < 0.001) {
          translateX = 0;
        }

        if (Math.abs(translateY) < 0.001) {
          translateY = 0;
        }

        if (Math.abs(translateZ) < 0.001) {
          translateZ = 0;
        }

        if (Math.abs(rotateY) < 0.001) {
          rotateY = 0;
        }

        if (Math.abs(rotateX) < 0.001) {
          rotateX = 0;
        }

        var slideTransform = "translate3d(" + translateX + "px," + translateY + "px," + translateZ + "px)  rotateX(" + rotateX + "deg) rotateY(" + rotateY + "deg)";
        $slideEl.transform(slideTransform);
        $slideEl[0].style.zIndex = -Math.abs(Math.round(offsetMultiplier)) + 1;

        if (params.slideShadows) {
          // Set shadows
          var $shadowBeforeEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-left') : $slideEl.find('.swiper-slide-shadow-top');
          var $shadowAfterEl = isHorizontal ? $slideEl.find('.swiper-slide-shadow-right') : $slideEl.find('.swiper-slide-shadow-bottom');

          if ($shadowBeforeEl.length === 0) {
            $shadowBeforeEl = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'left' : 'top') + "\"></div>");
            $slideEl.append($shadowBeforeEl);
          }

          if ($shadowAfterEl.length === 0) {
            $shadowAfterEl = $("<div class=\"swiper-slide-shadow-" + (isHorizontal ? 'right' : 'bottom') + "\"></div>");
            $slideEl.append($shadowAfterEl);
          }

          if ($shadowBeforeEl.length) {
            $shadowBeforeEl[0].style.opacity = offsetMultiplier > 0 ? offsetMultiplier : 0;
          }

          if ($shadowAfterEl.length) {
            $shadowAfterEl[0].style.opacity = -offsetMultiplier > 0 ? -offsetMultiplier : 0;
          }
        }
      } // Set correct perspective for IE10


      if (Support.pointerEvents || Support.prefixedPointerEvents) {
        var ws = $wrapperEl[0].style;
        ws.perspectiveOrigin = center + "px 50%";
      }
    },
    setTransition: function setTransition(duration) {
      var swiper = this;
      swiper.slides.transition(duration).find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').transition(duration);
    }
  };
  var EffectCoverflow = {
    name: 'effect-coverflow',
    params: {
      coverflowEffect: {
        rotate: 50,
        stretch: 0,
        depth: 100,
        modifier: 1,
        slideShadows: true
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        coverflowEffect: {
          setTranslate: Coverflow.setTranslate.bind(swiper),
          setTransition: Coverflow.setTransition.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;

        if (swiper.params.effect !== 'coverflow') {
          return;
        }

        swiper.classNames.push(swiper.params.containerModifierClass + "coverflow");
        swiper.classNames.push(swiper.params.containerModifierClass + "3d");
        swiper.params.watchSlidesProgress = true;
        swiper.originalParams.watchSlidesProgress = true;
      },
      setTranslate: function setTranslate() {
        var swiper = this;

        if (swiper.params.effect !== 'coverflow') {
          return;
        }

        swiper.coverflowEffect.setTranslate();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;

        if (swiper.params.effect !== 'coverflow') {
          return;
        }

        swiper.coverflowEffect.setTransition(duration);
      }
    }
  };
  var Thumbs = {
    init: function init() {
      var swiper = this;
      var ref = swiper.params;
      var thumbsParams = ref.thumbs;
      var SwiperClass = swiper.constructor;

      if (thumbsParams.swiper instanceof SwiperClass) {
        swiper.thumbs.swiper = thumbsParams.swiper;
        Utils.extend(swiper.thumbs.swiper.originalParams, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
        Utils.extend(swiper.thumbs.swiper.params, {
          watchSlidesProgress: true,
          slideToClickedSlide: false
        });
      } else if (Utils.isObject(thumbsParams.swiper)) {
        swiper.thumbs.swiper = new SwiperClass(Utils.extend({}, thumbsParams.swiper, {
          watchSlidesVisibility: true,
          watchSlidesProgress: true,
          slideToClickedSlide: false
        }));
        swiper.thumbs.swiperCreated = true;
      }

      swiper.thumbs.swiper.$el.addClass(swiper.params.thumbs.thumbsContainerClass);
      swiper.thumbs.swiper.on('tap', swiper.thumbs.onThumbClick);
    },
    onThumbClick: function onThumbClick() {
      var swiper = this;
      var thumbsSwiper = swiper.thumbs.swiper;

      if (!thumbsSwiper) {
        return;
      }

      var clickedIndex = thumbsSwiper.clickedIndex;
      var clickedSlide = thumbsSwiper.clickedSlide;

      if (clickedSlide && $(clickedSlide).hasClass(swiper.params.thumbs.slideThumbActiveClass)) {
        return;
      }

      if (typeof clickedIndex === 'undefined' || clickedIndex === null) {
        return;
      }

      var slideToIndex;

      if (thumbsSwiper.params.loop) {
        slideToIndex = parseInt($(thumbsSwiper.clickedSlide).attr('data-swiper-slide-index'), 10);
      } else {
        slideToIndex = clickedIndex;
      }

      if (swiper.params.loop) {
        var currentIndex = swiper.activeIndex;

        if (swiper.slides.eq(currentIndex).hasClass(swiper.params.slideDuplicateClass)) {
          swiper.loopFix(); // eslint-disable-next-line

          swiper._clientLeft = swiper.$wrapperEl[0].clientLeft;
          currentIndex = swiper.activeIndex;
        }

        var prevIndex = swiper.slides.eq(currentIndex).prevAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();
        var nextIndex = swiper.slides.eq(currentIndex).nextAll("[data-swiper-slide-index=\"" + slideToIndex + "\"]").eq(0).index();

        if (typeof prevIndex === 'undefined') {
          slideToIndex = nextIndex;
        } else if (typeof nextIndex === 'undefined') {
          slideToIndex = prevIndex;
        } else if (nextIndex - currentIndex < currentIndex - prevIndex) {
          slideToIndex = nextIndex;
        } else {
          slideToIndex = prevIndex;
        }
      }

      swiper.slideTo(slideToIndex);
    },
    update: function update(initial) {
      var swiper = this;
      var thumbsSwiper = swiper.thumbs.swiper;

      if (!thumbsSwiper) {
        return;
      }

      var slidesPerView = thumbsSwiper.params.slidesPerView === 'auto' ? thumbsSwiper.slidesPerViewDynamic() : thumbsSwiper.params.slidesPerView;

      if (swiper.realIndex !== thumbsSwiper.realIndex) {
        var currentThumbsIndex = thumbsSwiper.activeIndex;
        var newThumbsIndex;

        if (thumbsSwiper.params.loop) {
          if (thumbsSwiper.slides.eq(currentThumbsIndex).hasClass(thumbsSwiper.params.slideDuplicateClass)) {
            thumbsSwiper.loopFix(); // eslint-disable-next-line

            thumbsSwiper._clientLeft = thumbsSwiper.$wrapperEl[0].clientLeft;
            currentThumbsIndex = thumbsSwiper.activeIndex;
          } // Find actual thumbs index to slide to


          var prevThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).prevAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();
          var nextThumbsIndex = thumbsSwiper.slides.eq(currentThumbsIndex).nextAll("[data-swiper-slide-index=\"" + swiper.realIndex + "\"]").eq(0).index();

          if (typeof prevThumbsIndex === 'undefined') {
            newThumbsIndex = nextThumbsIndex;
          } else if (typeof nextThumbsIndex === 'undefined') {
            newThumbsIndex = prevThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex === currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = currentThumbsIndex;
          } else if (nextThumbsIndex - currentThumbsIndex < currentThumbsIndex - prevThumbsIndex) {
            newThumbsIndex = nextThumbsIndex;
          } else {
            newThumbsIndex = prevThumbsIndex;
          }
        } else {
          newThumbsIndex = swiper.realIndex;
        }

        if (thumbsSwiper.visibleSlidesIndexes && thumbsSwiper.visibleSlidesIndexes.indexOf(newThumbsIndex) < 0) {
          if (thumbsSwiper.params.centeredSlides) {
            if (newThumbsIndex > currentThumbsIndex) {
              newThumbsIndex = newThumbsIndex - Math.floor(slidesPerView / 2) + 1;
            } else {
              newThumbsIndex = newThumbsIndex + Math.floor(slidesPerView / 2) - 1;
            }
          } else if (newThumbsIndex > currentThumbsIndex) {
            newThumbsIndex = newThumbsIndex - slidesPerView + 1;
          }

          thumbsSwiper.slideTo(newThumbsIndex, initial ? 0 : undefined);
        }
      } // Activate thumbs


      var thumbsToActivate = 1;
      var thumbActiveClass = swiper.params.thumbs.slideThumbActiveClass;

      if (swiper.params.slidesPerView > 1 && !swiper.params.centeredSlides) {
        thumbsToActivate = swiper.params.slidesPerView;
      }

      if (!swiper.params.thumbs.multipleActiveThumbs) {
        thumbsToActivate = 1;
      }

      thumbsToActivate = Math.floor(thumbsToActivate);
      thumbsSwiper.slides.removeClass(thumbActiveClass);

      if (thumbsSwiper.params.loop || thumbsSwiper.params.virtual && thumbsSwiper.params.virtual.enabled) {
        for (var i = 0; i < thumbsToActivate; i += 1) {
          thumbsSwiper.$wrapperEl.children("[data-swiper-slide-index=\"" + (swiper.realIndex + i) + "\"]").addClass(thumbActiveClass);
        }
      } else {
        for (var i$1 = 0; i$1 < thumbsToActivate; i$1 += 1) {
          thumbsSwiper.slides.eq(swiper.realIndex + i$1).addClass(thumbActiveClass);
        }
      }
    }
  };
  var Thumbs$1 = {
    name: 'thumbs',
    params: {
      thumbs: {
        multipleActiveThumbs: true,
        swiper: null,
        slideThumbActiveClass: 'swiper-slide-thumb-active',
        thumbsContainerClass: 'swiper-container-thumbs'
      }
    },
    create: function create() {
      var swiper = this;
      Utils.extend(swiper, {
        thumbs: {
          swiper: null,
          init: Thumbs.init.bind(swiper),
          update: Thumbs.update.bind(swiper),
          onThumbClick: Thumbs.onThumbClick.bind(swiper)
        }
      });
    },
    on: {
      beforeInit: function beforeInit() {
        var swiper = this;
        var ref = swiper.params;
        var thumbs = ref.thumbs;

        if (!thumbs || !thumbs.swiper) {
          return;
        }

        swiper.thumbs.init();
        swiper.thumbs.update(true);
      },
      slideChange: function slideChange() {
        var swiper = this;

        if (!swiper.thumbs.swiper) {
          return;
        }

        swiper.thumbs.update();
      },
      update: function update() {
        var swiper = this;

        if (!swiper.thumbs.swiper) {
          return;
        }

        swiper.thumbs.update();
      },
      resize: function resize() {
        var swiper = this;

        if (!swiper.thumbs.swiper) {
          return;
        }

        swiper.thumbs.update();
      },
      observerUpdate: function observerUpdate() {
        var swiper = this;

        if (!swiper.thumbs.swiper) {
          return;
        }

        swiper.thumbs.update();
      },
      setTransition: function setTransition(duration) {
        var swiper = this;
        var thumbsSwiper = swiper.thumbs.swiper;

        if (!thumbsSwiper) {
          return;
        }

        thumbsSwiper.setTransition(duration);
      },
      beforeDestroy: function beforeDestroy() {
        var swiper = this;
        var thumbsSwiper = swiper.thumbs.swiper;

        if (!thumbsSwiper) {
          return;
        }

        if (swiper.thumbs.swiperCreated && thumbsSwiper) {
          thumbsSwiper.destroy();
        }
      }
    }
  }; // Swiper Class

  var components = [Device$1, Support$1, Browser$1, Resize, Observer$1, Virtual$1, Keyboard$1, Mousewheel$1, Navigation$1, Pagination$1, Scrollbar$1, Parallax$1, Zoom$1, Lazy$1, Controller$1, A11y, History$1, HashNavigation$1, Autoplay$1, EffectFade, EffectCube, EffectFlip, EffectCoverflow, Thumbs$1];

  if (typeof Swiper.use === 'undefined') {
    Swiper.use = Swiper.Class.use;
    Swiper.installModule = Swiper.Class.installModule;
  }

  Swiper.use(components);
  return Swiper;
});
"use strict";

var html = document.querySelector('html'),
    siteHamburger = document.querySelector('.hamburger'),
    closeMenu = document.querySelector('.offcanvas__close'),
    nav = document.querySelector('.header');
var scrollPos = 0;
siteHamburger.addEventListener('click', toggleMobileMenu);

function toggleMobileMenu() {
  siteHamburger.classList.toggle('active');
  html.classList.toggle('mobile-menu-open');
}

if (document.querySelector('body').getAttribute('data-page') === 'home') {
  var checkPosition = function checkPosition() {
    var windowY = window.scrollY;

    if (windowY > 0) {
      nav.classList.add('header--state2');
    } else {
      nav.classList.remove('header--state2');
    }

    scrollPos = windowY;
  };

  window.addEventListener('scroll', checkPosition);

  if (window.scrollY > 0) {
    nav.classList.add('header--state2');
  } else {
    nav.classList.remove('header--state2');
  }
}

if (document.querySelector('body').getAttribute('data-page') !== 'home') {
  var _checkPosition = function _checkPosition() {
    var windowY = window.scrollY;

    if (windowY > 0) {
      nav.classList.add('header--scrolled');
    } else {
      nav.classList.remove('header--scrolled');
    }

    scrollPos = windowY;
  };

  window.addEventListener('scroll', _checkPosition);

  if (window.scrollY > 0) {
    nav.classList.add('header--scrolled');
  } else {
    nav.classList.remove('header--scrolled');
  }
}

var bioStyle = Array.from(document.querySelectorAll('.home__option-title'));

var _loop = function _loop(i, l) {
  bioStyle[i].onclick = function () {
    for (var j = 0; j < l; j++) {
      if (bioStyle[j] != this) {
        bioStyle[j].parentElement.classList.remove("active");
      }
    }

    this.parentElement.classList.toggle('active');
  };
};

for (var i = 0, l = bioStyle.length; i < l; i++) {
  _loop(i, l);
}

var scroll = new SmoothScroll('a[href*="#"]', {
  offset: 82,
  speed: 500
});
"use strict";

new universalParallax().init();
"use strict";

var element = document.querySelector('.form__select');

if (element.length) {
  var choices = new Choices(element);
} // var instance = OverlayScrollbars(document.getElementById('desktop'));


OverlayScrollbars(document.getElementById('desktop'), {});
OverlayScrollbars(document.getElementById('tablet'), {});
OverlayScrollbars(document.getElementById('mobile'), {}); // desktop-button
// tablet-button
// mobile-button
// desktop-block
// tablet-block
// mobile-block
"use strict";

var mySwiper = new Swiper('.site-slider__portfolio', {
  spaceBetween: 15,
  direction: 'horizontal',
  slidesPerView: 1,
  breakpoints: {
    640: {
      slidesPerView: 2
    },
    850: {
      slidesPerView: 3,
      loop: false
    }
  },
  navigation: {
    nextEl: '.swiper-button-next',
    prevEl: '.swiper-button-prev'
  } // // If we need pagination
  // pagination: {
  //     el: '.swiper-pagination',
  // },

});
var reviewSlide = new Swiper('.site-slider__reviews', {
  direction: 'horizontal',
  slidesPerView: 1,
  autoplay: {
    delay: 3500,
    speed: 1000,
    disableOnInteraction: false
  },
  pagination: {
    el: '.swiper-pagination',
    clickable: true
  }
});
var statsSlider = new Swiper('.home__stats', {
  spaceBetween: 15,
  direction: 'horizontal',
  slidesPerView: 1,
  loop: true,
  breakpoints: {
    450: {
      slidesPerView: 2
    },
    640: {
      slidesPerView: 3
    },
    850: {
      slidesPerView: 4
    },
    1040: {
      slidesPerView: 5
    }
  },
  navigation: {
    nextEl: '.swiper-button-next',
    prevEl: '.swiper-button-prev'
  } // // If we need pagination
  // pagination: {
  //     el: '.swiper-pagination',
  // },

});